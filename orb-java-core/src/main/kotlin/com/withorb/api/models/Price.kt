// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.withorb.api.core.BaseDeserializer
import com.withorb.api.core.BaseSerializer
import com.withorb.api.core.Enum
import com.withorb.api.core.ExcludeMissing
import com.withorb.api.core.JsonField
import com.withorb.api.core.JsonMissing
import com.withorb.api.core.JsonValue
import com.withorb.api.core.NoAutoDetect
import com.withorb.api.core.checkKnown
import com.withorb.api.core.checkRequired
import com.withorb.api.core.getOrThrow
import com.withorb.api.core.immutableEmptyMap
import com.withorb.api.core.toImmutable
import com.withorb.api.errors.OrbInvalidDataException
import java.time.OffsetDateTime
import java.util.Objects
import java.util.Optional
import kotlin.jvm.optionals.getOrNull

/**
 * The Price resource represents a price that can be billed on a subscription, resulting in a charge
 * on an invoice in the form of an invoice line item. Prices take a quantity and determine an amount
 * to bill.
 *
 * Orb supports a few different pricing models out of the box. Each of these models is serialized
 * differently in a given Price object. The model_type field determines the key for the
 * configuration object that is present.
 *
 * For more on the types of prices, see
 * [the core concepts documentation](/core-concepts#plan-and-price)
 */
@JsonDeserialize(using = Price.Deserializer::class)
@JsonSerialize(using = Price.Serializer::class)
class Price
private constructor(
    private val unit: UnitPrice? = null,
    private val packagePrice: PackagePrice? = null,
    private val matrix: MatrixPrice? = null,
    private val tiered: TieredPrice? = null,
    private val tieredBps: TieredBpsPrice? = null,
    private val bps: BpsPrice? = null,
    private val bulkBps: BulkBpsPrice? = null,
    private val bulk: BulkPrice? = null,
    private val thresholdTotalAmount: ThresholdTotalAmountPrice? = null,
    private val tieredPackage: TieredPackagePrice? = null,
    private val groupedTiered: GroupedTieredPrice? = null,
    private val tieredWithMinimum: TieredWithMinimumPrice? = null,
    private val tieredPackageWithMinimum: TieredPackageWithMinimumPrice? = null,
    private val packageWithAllocation: PackageWithAllocationPrice? = null,
    private val unitWithPercent: UnitWithPercentPrice? = null,
    private val matrixWithAllocation: MatrixWithAllocationPrice? = null,
    private val tieredWithProration: TieredWithProrationPrice? = null,
    private val unitWithProration: UnitWithProrationPrice? = null,
    private val groupedAllocation: GroupedAllocationPrice? = null,
    private val groupedWithProratedMinimum: GroupedWithProratedMinimumPrice? = null,
    private val groupedWithMeteredMinimum: GroupedWithMeteredMinimumPrice? = null,
    private val matrixWithDisplayName: MatrixWithDisplayNamePrice? = null,
    private val bulkWithProration: BulkWithProrationPrice? = null,
    private val groupedTieredPackage: GroupedTieredPackagePrice? = null,
    private val maxGroupTieredPackage: MaxGroupTieredPackagePrice? = null,
    private val scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricingPrice? = null,
    private val scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricingPrice? = null,
    private val cumulativeGroupedBulk: CumulativeGroupedBulkPrice? = null,
    private val _json: JsonValue? = null,
) {

    fun unit(): Optional<UnitPrice> = Optional.ofNullable(unit)

    fun packagePrice(): Optional<PackagePrice> = Optional.ofNullable(packagePrice)

    fun matrix(): Optional<MatrixPrice> = Optional.ofNullable(matrix)

    fun tiered(): Optional<TieredPrice> = Optional.ofNullable(tiered)

    fun tieredBps(): Optional<TieredBpsPrice> = Optional.ofNullable(tieredBps)

    fun bps(): Optional<BpsPrice> = Optional.ofNullable(bps)

    fun bulkBps(): Optional<BulkBpsPrice> = Optional.ofNullable(bulkBps)

    fun bulk(): Optional<BulkPrice> = Optional.ofNullable(bulk)

    fun thresholdTotalAmount(): Optional<ThresholdTotalAmountPrice> =
        Optional.ofNullable(thresholdTotalAmount)

    fun tieredPackage(): Optional<TieredPackagePrice> = Optional.ofNullable(tieredPackage)

    fun groupedTiered(): Optional<GroupedTieredPrice> = Optional.ofNullable(groupedTiered)

    fun tieredWithMinimum(): Optional<TieredWithMinimumPrice> =
        Optional.ofNullable(tieredWithMinimum)

    fun tieredPackageWithMinimum(): Optional<TieredPackageWithMinimumPrice> =
        Optional.ofNullable(tieredPackageWithMinimum)

    fun packageWithAllocation(): Optional<PackageWithAllocationPrice> =
        Optional.ofNullable(packageWithAllocation)

    fun unitWithPercent(): Optional<UnitWithPercentPrice> = Optional.ofNullable(unitWithPercent)

    fun matrixWithAllocation(): Optional<MatrixWithAllocationPrice> =
        Optional.ofNullable(matrixWithAllocation)

    fun tieredWithProration(): Optional<TieredWithProrationPrice> =
        Optional.ofNullable(tieredWithProration)

    fun unitWithProration(): Optional<UnitWithProrationPrice> =
        Optional.ofNullable(unitWithProration)

    fun groupedAllocation(): Optional<GroupedAllocationPrice> =
        Optional.ofNullable(groupedAllocation)

    fun groupedWithProratedMinimum(): Optional<GroupedWithProratedMinimumPrice> =
        Optional.ofNullable(groupedWithProratedMinimum)

    fun groupedWithMeteredMinimum(): Optional<GroupedWithMeteredMinimumPrice> =
        Optional.ofNullable(groupedWithMeteredMinimum)

    fun matrixWithDisplayName(): Optional<MatrixWithDisplayNamePrice> =
        Optional.ofNullable(matrixWithDisplayName)

    fun bulkWithProration(): Optional<BulkWithProrationPrice> =
        Optional.ofNullable(bulkWithProration)

    fun groupedTieredPackage(): Optional<GroupedTieredPackagePrice> =
        Optional.ofNullable(groupedTieredPackage)

    fun maxGroupTieredPackage(): Optional<MaxGroupTieredPackagePrice> =
        Optional.ofNullable(maxGroupTieredPackage)

    fun scalableMatrixWithUnitPricing(): Optional<ScalableMatrixWithUnitPricingPrice> =
        Optional.ofNullable(scalableMatrixWithUnitPricing)

    fun scalableMatrixWithTieredPricing(): Optional<ScalableMatrixWithTieredPricingPrice> =
        Optional.ofNullable(scalableMatrixWithTieredPricing)

    fun cumulativeGroupedBulk(): Optional<CumulativeGroupedBulkPrice> =
        Optional.ofNullable(cumulativeGroupedBulk)

    fun isUnit(): Boolean = unit != null

    fun isPackagePrice(): Boolean = packagePrice != null

    fun isMatrix(): Boolean = matrix != null

    fun isTiered(): Boolean = tiered != null

    fun isTieredBps(): Boolean = tieredBps != null

    fun isBps(): Boolean = bps != null

    fun isBulkBps(): Boolean = bulkBps != null

    fun isBulk(): Boolean = bulk != null

    fun isThresholdTotalAmount(): Boolean = thresholdTotalAmount != null

    fun isTieredPackage(): Boolean = tieredPackage != null

    fun isGroupedTiered(): Boolean = groupedTiered != null

    fun isTieredWithMinimum(): Boolean = tieredWithMinimum != null

    fun isTieredPackageWithMinimum(): Boolean = tieredPackageWithMinimum != null

    fun isPackageWithAllocation(): Boolean = packageWithAllocation != null

    fun isUnitWithPercent(): Boolean = unitWithPercent != null

    fun isMatrixWithAllocation(): Boolean = matrixWithAllocation != null

    fun isTieredWithProration(): Boolean = tieredWithProration != null

    fun isUnitWithProration(): Boolean = unitWithProration != null

    fun isGroupedAllocation(): Boolean = groupedAllocation != null

    fun isGroupedWithProratedMinimum(): Boolean = groupedWithProratedMinimum != null

    fun isGroupedWithMeteredMinimum(): Boolean = groupedWithMeteredMinimum != null

    fun isMatrixWithDisplayName(): Boolean = matrixWithDisplayName != null

    fun isBulkWithProration(): Boolean = bulkWithProration != null

    fun isGroupedTieredPackage(): Boolean = groupedTieredPackage != null

    fun isMaxGroupTieredPackage(): Boolean = maxGroupTieredPackage != null

    fun isScalableMatrixWithUnitPricing(): Boolean = scalableMatrixWithUnitPricing != null

    fun isScalableMatrixWithTieredPricing(): Boolean = scalableMatrixWithTieredPricing != null

    fun isCumulativeGroupedBulk(): Boolean = cumulativeGroupedBulk != null

    fun asUnit(): UnitPrice = unit.getOrThrow("unit")

    fun asPackagePrice(): PackagePrice = packagePrice.getOrThrow("packagePrice")

    fun asMatrix(): MatrixPrice = matrix.getOrThrow("matrix")

    fun asTiered(): TieredPrice = tiered.getOrThrow("tiered")

    fun asTieredBps(): TieredBpsPrice = tieredBps.getOrThrow("tieredBps")

    fun asBps(): BpsPrice = bps.getOrThrow("bps")

    fun asBulkBps(): BulkBpsPrice = bulkBps.getOrThrow("bulkBps")

    fun asBulk(): BulkPrice = bulk.getOrThrow("bulk")

    fun asThresholdTotalAmount(): ThresholdTotalAmountPrice =
        thresholdTotalAmount.getOrThrow("thresholdTotalAmount")

    fun asTieredPackage(): TieredPackagePrice = tieredPackage.getOrThrow("tieredPackage")

    fun asGroupedTiered(): GroupedTieredPrice = groupedTiered.getOrThrow("groupedTiered")

    fun asTieredWithMinimum(): TieredWithMinimumPrice =
        tieredWithMinimum.getOrThrow("tieredWithMinimum")

    fun asTieredPackageWithMinimum(): TieredPackageWithMinimumPrice =
        tieredPackageWithMinimum.getOrThrow("tieredPackageWithMinimum")

    fun asPackageWithAllocation(): PackageWithAllocationPrice =
        packageWithAllocation.getOrThrow("packageWithAllocation")

    fun asUnitWithPercent(): UnitWithPercentPrice = unitWithPercent.getOrThrow("unitWithPercent")

    fun asMatrixWithAllocation(): MatrixWithAllocationPrice =
        matrixWithAllocation.getOrThrow("matrixWithAllocation")

    fun asTieredWithProration(): TieredWithProrationPrice =
        tieredWithProration.getOrThrow("tieredWithProration")

    fun asUnitWithProration(): UnitWithProrationPrice =
        unitWithProration.getOrThrow("unitWithProration")

    fun asGroupedAllocation(): GroupedAllocationPrice =
        groupedAllocation.getOrThrow("groupedAllocation")

    fun asGroupedWithProratedMinimum(): GroupedWithProratedMinimumPrice =
        groupedWithProratedMinimum.getOrThrow("groupedWithProratedMinimum")

    fun asGroupedWithMeteredMinimum(): GroupedWithMeteredMinimumPrice =
        groupedWithMeteredMinimum.getOrThrow("groupedWithMeteredMinimum")

    fun asMatrixWithDisplayName(): MatrixWithDisplayNamePrice =
        matrixWithDisplayName.getOrThrow("matrixWithDisplayName")

    fun asBulkWithProration(): BulkWithProrationPrice =
        bulkWithProration.getOrThrow("bulkWithProration")

    fun asGroupedTieredPackage(): GroupedTieredPackagePrice =
        groupedTieredPackage.getOrThrow("groupedTieredPackage")

    fun asMaxGroupTieredPackage(): MaxGroupTieredPackagePrice =
        maxGroupTieredPackage.getOrThrow("maxGroupTieredPackage")

    fun asScalableMatrixWithUnitPricing(): ScalableMatrixWithUnitPricingPrice =
        scalableMatrixWithUnitPricing.getOrThrow("scalableMatrixWithUnitPricing")

    fun asScalableMatrixWithTieredPricing(): ScalableMatrixWithTieredPricingPrice =
        scalableMatrixWithTieredPricing.getOrThrow("scalableMatrixWithTieredPricing")

    fun asCumulativeGroupedBulk(): CumulativeGroupedBulkPrice =
        cumulativeGroupedBulk.getOrThrow("cumulativeGroupedBulk")

    fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

    fun <T> accept(visitor: Visitor<T>): T {
        return when {
            unit != null -> visitor.visitUnit(unit)
            packagePrice != null -> visitor.visitPackagePrice(packagePrice)
            matrix != null -> visitor.visitMatrix(matrix)
            tiered != null -> visitor.visitTiered(tiered)
            tieredBps != null -> visitor.visitTieredBps(tieredBps)
            bps != null -> visitor.visitBps(bps)
            bulkBps != null -> visitor.visitBulkBps(bulkBps)
            bulk != null -> visitor.visitBulk(bulk)
            thresholdTotalAmount != null -> visitor.visitThresholdTotalAmount(thresholdTotalAmount)
            tieredPackage != null -> visitor.visitTieredPackage(tieredPackage)
            groupedTiered != null -> visitor.visitGroupedTiered(groupedTiered)
            tieredWithMinimum != null -> visitor.visitTieredWithMinimum(tieredWithMinimum)
            tieredPackageWithMinimum != null ->
                visitor.visitTieredPackageWithMinimum(tieredPackageWithMinimum)
            packageWithAllocation != null ->
                visitor.visitPackageWithAllocation(packageWithAllocation)
            unitWithPercent != null -> visitor.visitUnitWithPercent(unitWithPercent)
            matrixWithAllocation != null -> visitor.visitMatrixWithAllocation(matrixWithAllocation)
            tieredWithProration != null -> visitor.visitTieredWithProration(tieredWithProration)
            unitWithProration != null -> visitor.visitUnitWithProration(unitWithProration)
            groupedAllocation != null -> visitor.visitGroupedAllocation(groupedAllocation)
            groupedWithProratedMinimum != null ->
                visitor.visitGroupedWithProratedMinimum(groupedWithProratedMinimum)
            groupedWithMeteredMinimum != null ->
                visitor.visitGroupedWithMeteredMinimum(groupedWithMeteredMinimum)
            matrixWithDisplayName != null ->
                visitor.visitMatrixWithDisplayName(matrixWithDisplayName)
            bulkWithProration != null -> visitor.visitBulkWithProration(bulkWithProration)
            groupedTieredPackage != null -> visitor.visitGroupedTieredPackage(groupedTieredPackage)
            maxGroupTieredPackage != null ->
                visitor.visitMaxGroupTieredPackage(maxGroupTieredPackage)
            scalableMatrixWithUnitPricing != null ->
                visitor.visitScalableMatrixWithUnitPricing(scalableMatrixWithUnitPricing)
            scalableMatrixWithTieredPricing != null ->
                visitor.visitScalableMatrixWithTieredPricing(scalableMatrixWithTieredPricing)
            cumulativeGroupedBulk != null ->
                visitor.visitCumulativeGroupedBulk(cumulativeGroupedBulk)
            else -> visitor.unknown(_json)
        }
    }

    private var validated: Boolean = false

    fun validate(): Price = apply {
        if (validated) {
            return@apply
        }

        accept(
            object : Visitor<Unit> {
                override fun visitUnit(unit: UnitPrice) {
                    unit.validate()
                }

                override fun visitPackagePrice(packagePrice: PackagePrice) {
                    packagePrice.validate()
                }

                override fun visitMatrix(matrix: MatrixPrice) {
                    matrix.validate()
                }

                override fun visitTiered(tiered: TieredPrice) {
                    tiered.validate()
                }

                override fun visitTieredBps(tieredBps: TieredBpsPrice) {
                    tieredBps.validate()
                }

                override fun visitBps(bps: BpsPrice) {
                    bps.validate()
                }

                override fun visitBulkBps(bulkBps: BulkBpsPrice) {
                    bulkBps.validate()
                }

                override fun visitBulk(bulk: BulkPrice) {
                    bulk.validate()
                }

                override fun visitThresholdTotalAmount(
                    thresholdTotalAmount: ThresholdTotalAmountPrice
                ) {
                    thresholdTotalAmount.validate()
                }

                override fun visitTieredPackage(tieredPackage: TieredPackagePrice) {
                    tieredPackage.validate()
                }

                override fun visitGroupedTiered(groupedTiered: GroupedTieredPrice) {
                    groupedTiered.validate()
                }

                override fun visitTieredWithMinimum(tieredWithMinimum: TieredWithMinimumPrice) {
                    tieredWithMinimum.validate()
                }

                override fun visitTieredPackageWithMinimum(
                    tieredPackageWithMinimum: TieredPackageWithMinimumPrice
                ) {
                    tieredPackageWithMinimum.validate()
                }

                override fun visitPackageWithAllocation(
                    packageWithAllocation: PackageWithAllocationPrice
                ) {
                    packageWithAllocation.validate()
                }

                override fun visitUnitWithPercent(unitWithPercent: UnitWithPercentPrice) {
                    unitWithPercent.validate()
                }

                override fun visitMatrixWithAllocation(
                    matrixWithAllocation: MatrixWithAllocationPrice
                ) {
                    matrixWithAllocation.validate()
                }

                override fun visitTieredWithProration(
                    tieredWithProration: TieredWithProrationPrice
                ) {
                    tieredWithProration.validate()
                }

                override fun visitUnitWithProration(unitWithProration: UnitWithProrationPrice) {
                    unitWithProration.validate()
                }

                override fun visitGroupedAllocation(groupedAllocation: GroupedAllocationPrice) {
                    groupedAllocation.validate()
                }

                override fun visitGroupedWithProratedMinimum(
                    groupedWithProratedMinimum: GroupedWithProratedMinimumPrice
                ) {
                    groupedWithProratedMinimum.validate()
                }

                override fun visitGroupedWithMeteredMinimum(
                    groupedWithMeteredMinimum: GroupedWithMeteredMinimumPrice
                ) {
                    groupedWithMeteredMinimum.validate()
                }

                override fun visitMatrixWithDisplayName(
                    matrixWithDisplayName: MatrixWithDisplayNamePrice
                ) {
                    matrixWithDisplayName.validate()
                }

                override fun visitBulkWithProration(bulkWithProration: BulkWithProrationPrice) {
                    bulkWithProration.validate()
                }

                override fun visitGroupedTieredPackage(
                    groupedTieredPackage: GroupedTieredPackagePrice
                ) {
                    groupedTieredPackage.validate()
                }

                override fun visitMaxGroupTieredPackage(
                    maxGroupTieredPackage: MaxGroupTieredPackagePrice
                ) {
                    maxGroupTieredPackage.validate()
                }

                override fun visitScalableMatrixWithUnitPricing(
                    scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricingPrice
                ) {
                    scalableMatrixWithUnitPricing.validate()
                }

                override fun visitScalableMatrixWithTieredPricing(
                    scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricingPrice
                ) {
                    scalableMatrixWithTieredPricing.validate()
                }

                override fun visitCumulativeGroupedBulk(
                    cumulativeGroupedBulk: CumulativeGroupedBulkPrice
                ) {
                    cumulativeGroupedBulk.validate()
                }
            }
        )
        validated = true
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return /* spotless:off */ other is Price && unit == other.unit && packagePrice == other.packagePrice && matrix == other.matrix && tiered == other.tiered && tieredBps == other.tieredBps && bps == other.bps && bulkBps == other.bulkBps && bulk == other.bulk && thresholdTotalAmount == other.thresholdTotalAmount && tieredPackage == other.tieredPackage && groupedTiered == other.groupedTiered && tieredWithMinimum == other.tieredWithMinimum && tieredPackageWithMinimum == other.tieredPackageWithMinimum && packageWithAllocation == other.packageWithAllocation && unitWithPercent == other.unitWithPercent && matrixWithAllocation == other.matrixWithAllocation && tieredWithProration == other.tieredWithProration && unitWithProration == other.unitWithProration && groupedAllocation == other.groupedAllocation && groupedWithProratedMinimum == other.groupedWithProratedMinimum && groupedWithMeteredMinimum == other.groupedWithMeteredMinimum && matrixWithDisplayName == other.matrixWithDisplayName && bulkWithProration == other.bulkWithProration && groupedTieredPackage == other.groupedTieredPackage && maxGroupTieredPackage == other.maxGroupTieredPackage && scalableMatrixWithUnitPricing == other.scalableMatrixWithUnitPricing && scalableMatrixWithTieredPricing == other.scalableMatrixWithTieredPricing && cumulativeGroupedBulk == other.cumulativeGroupedBulk /* spotless:on */
    }

    override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, packagePrice, matrix, tiered, tieredBps, bps, bulkBps, bulk, thresholdTotalAmount, tieredPackage, groupedTiered, tieredWithMinimum, tieredPackageWithMinimum, packageWithAllocation, unitWithPercent, matrixWithAllocation, tieredWithProration, unitWithProration, groupedAllocation, groupedWithProratedMinimum, groupedWithMeteredMinimum, matrixWithDisplayName, bulkWithProration, groupedTieredPackage, maxGroupTieredPackage, scalableMatrixWithUnitPricing, scalableMatrixWithTieredPricing, cumulativeGroupedBulk) /* spotless:on */

    override fun toString(): String =
        when {
            unit != null -> "Price{unit=$unit}"
            packagePrice != null -> "Price{packagePrice=$packagePrice}"
            matrix != null -> "Price{matrix=$matrix}"
            tiered != null -> "Price{tiered=$tiered}"
            tieredBps != null -> "Price{tieredBps=$tieredBps}"
            bps != null -> "Price{bps=$bps}"
            bulkBps != null -> "Price{bulkBps=$bulkBps}"
            bulk != null -> "Price{bulk=$bulk}"
            thresholdTotalAmount != null -> "Price{thresholdTotalAmount=$thresholdTotalAmount}"
            tieredPackage != null -> "Price{tieredPackage=$tieredPackage}"
            groupedTiered != null -> "Price{groupedTiered=$groupedTiered}"
            tieredWithMinimum != null -> "Price{tieredWithMinimum=$tieredWithMinimum}"
            tieredPackageWithMinimum != null ->
                "Price{tieredPackageWithMinimum=$tieredPackageWithMinimum}"
            packageWithAllocation != null -> "Price{packageWithAllocation=$packageWithAllocation}"
            unitWithPercent != null -> "Price{unitWithPercent=$unitWithPercent}"
            matrixWithAllocation != null -> "Price{matrixWithAllocation=$matrixWithAllocation}"
            tieredWithProration != null -> "Price{tieredWithProration=$tieredWithProration}"
            unitWithProration != null -> "Price{unitWithProration=$unitWithProration}"
            groupedAllocation != null -> "Price{groupedAllocation=$groupedAllocation}"
            groupedWithProratedMinimum != null ->
                "Price{groupedWithProratedMinimum=$groupedWithProratedMinimum}"
            groupedWithMeteredMinimum != null ->
                "Price{groupedWithMeteredMinimum=$groupedWithMeteredMinimum}"
            matrixWithDisplayName != null -> "Price{matrixWithDisplayName=$matrixWithDisplayName}"
            bulkWithProration != null -> "Price{bulkWithProration=$bulkWithProration}"
            groupedTieredPackage != null -> "Price{groupedTieredPackage=$groupedTieredPackage}"
            maxGroupTieredPackage != null -> "Price{maxGroupTieredPackage=$maxGroupTieredPackage}"
            scalableMatrixWithUnitPricing != null ->
                "Price{scalableMatrixWithUnitPricing=$scalableMatrixWithUnitPricing}"
            scalableMatrixWithTieredPricing != null ->
                "Price{scalableMatrixWithTieredPricing=$scalableMatrixWithTieredPricing}"
            cumulativeGroupedBulk != null -> "Price{cumulativeGroupedBulk=$cumulativeGroupedBulk}"
            _json != null -> "Price{_unknown=$_json}"
            else -> throw IllegalStateException("Invalid Price")
        }

    companion object {

        @JvmStatic fun ofUnit(unit: UnitPrice) = Price(unit = unit)

        @JvmStatic
        fun ofPackagePrice(packagePrice: PackagePrice) = Price(packagePrice = packagePrice)

        @JvmStatic fun ofMatrix(matrix: MatrixPrice) = Price(matrix = matrix)

        @JvmStatic fun ofTiered(tiered: TieredPrice) = Price(tiered = tiered)

        @JvmStatic fun ofTieredBps(tieredBps: TieredBpsPrice) = Price(tieredBps = tieredBps)

        @JvmStatic fun ofBps(bps: BpsPrice) = Price(bps = bps)

        @JvmStatic fun ofBulkBps(bulkBps: BulkBpsPrice) = Price(bulkBps = bulkBps)

        @JvmStatic fun ofBulk(bulk: BulkPrice) = Price(bulk = bulk)

        @JvmStatic
        fun ofThresholdTotalAmount(thresholdTotalAmount: ThresholdTotalAmountPrice) =
            Price(thresholdTotalAmount = thresholdTotalAmount)

        @JvmStatic
        fun ofTieredPackage(tieredPackage: TieredPackagePrice) =
            Price(tieredPackage = tieredPackage)

        @JvmStatic
        fun ofGroupedTiered(groupedTiered: GroupedTieredPrice) =
            Price(groupedTiered = groupedTiered)

        @JvmStatic
        fun ofTieredWithMinimum(tieredWithMinimum: TieredWithMinimumPrice) =
            Price(tieredWithMinimum = tieredWithMinimum)

        @JvmStatic
        fun ofTieredPackageWithMinimum(tieredPackageWithMinimum: TieredPackageWithMinimumPrice) =
            Price(tieredPackageWithMinimum = tieredPackageWithMinimum)

        @JvmStatic
        fun ofPackageWithAllocation(packageWithAllocation: PackageWithAllocationPrice) =
            Price(packageWithAllocation = packageWithAllocation)

        @JvmStatic
        fun ofUnitWithPercent(unitWithPercent: UnitWithPercentPrice) =
            Price(unitWithPercent = unitWithPercent)

        @JvmStatic
        fun ofMatrixWithAllocation(matrixWithAllocation: MatrixWithAllocationPrice) =
            Price(matrixWithAllocation = matrixWithAllocation)

        @JvmStatic
        fun ofTieredWithProration(tieredWithProration: TieredWithProrationPrice) =
            Price(tieredWithProration = tieredWithProration)

        @JvmStatic
        fun ofUnitWithProration(unitWithProration: UnitWithProrationPrice) =
            Price(unitWithProration = unitWithProration)

        @JvmStatic
        fun ofGroupedAllocation(groupedAllocation: GroupedAllocationPrice) =
            Price(groupedAllocation = groupedAllocation)

        @JvmStatic
        fun ofGroupedWithProratedMinimum(
            groupedWithProratedMinimum: GroupedWithProratedMinimumPrice
        ) = Price(groupedWithProratedMinimum = groupedWithProratedMinimum)

        @JvmStatic
        fun ofGroupedWithMeteredMinimum(groupedWithMeteredMinimum: GroupedWithMeteredMinimumPrice) =
            Price(groupedWithMeteredMinimum = groupedWithMeteredMinimum)

        @JvmStatic
        fun ofMatrixWithDisplayName(matrixWithDisplayName: MatrixWithDisplayNamePrice) =
            Price(matrixWithDisplayName = matrixWithDisplayName)

        @JvmStatic
        fun ofBulkWithProration(bulkWithProration: BulkWithProrationPrice) =
            Price(bulkWithProration = bulkWithProration)

        @JvmStatic
        fun ofGroupedTieredPackage(groupedTieredPackage: GroupedTieredPackagePrice) =
            Price(groupedTieredPackage = groupedTieredPackage)

        @JvmStatic
        fun ofMaxGroupTieredPackage(maxGroupTieredPackage: MaxGroupTieredPackagePrice) =
            Price(maxGroupTieredPackage = maxGroupTieredPackage)

        @JvmStatic
        fun ofScalableMatrixWithUnitPricing(
            scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricingPrice
        ) = Price(scalableMatrixWithUnitPricing = scalableMatrixWithUnitPricing)

        @JvmStatic
        fun ofScalableMatrixWithTieredPricing(
            scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricingPrice
        ) = Price(scalableMatrixWithTieredPricing = scalableMatrixWithTieredPricing)

        @JvmStatic
        fun ofCumulativeGroupedBulk(cumulativeGroupedBulk: CumulativeGroupedBulkPrice) =
            Price(cumulativeGroupedBulk = cumulativeGroupedBulk)
    }

    /** An interface that defines how to map each variant of [Price] to a value of type [T]. */
    interface Visitor<out T> {

        fun visitUnit(unit: UnitPrice): T

        fun visitPackagePrice(packagePrice: PackagePrice): T

        fun visitMatrix(matrix: MatrixPrice): T

        fun visitTiered(tiered: TieredPrice): T

        fun visitTieredBps(tieredBps: TieredBpsPrice): T

        fun visitBps(bps: BpsPrice): T

        fun visitBulkBps(bulkBps: BulkBpsPrice): T

        fun visitBulk(bulk: BulkPrice): T

        fun visitThresholdTotalAmount(thresholdTotalAmount: ThresholdTotalAmountPrice): T

        fun visitTieredPackage(tieredPackage: TieredPackagePrice): T

        fun visitGroupedTiered(groupedTiered: GroupedTieredPrice): T

        fun visitTieredWithMinimum(tieredWithMinimum: TieredWithMinimumPrice): T

        fun visitTieredPackageWithMinimum(
            tieredPackageWithMinimum: TieredPackageWithMinimumPrice
        ): T

        fun visitPackageWithAllocation(packageWithAllocation: PackageWithAllocationPrice): T

        fun visitUnitWithPercent(unitWithPercent: UnitWithPercentPrice): T

        fun visitMatrixWithAllocation(matrixWithAllocation: MatrixWithAllocationPrice): T

        fun visitTieredWithProration(tieredWithProration: TieredWithProrationPrice): T

        fun visitUnitWithProration(unitWithProration: UnitWithProrationPrice): T

        fun visitGroupedAllocation(groupedAllocation: GroupedAllocationPrice): T

        fun visitGroupedWithProratedMinimum(
            groupedWithProratedMinimum: GroupedWithProratedMinimumPrice
        ): T

        fun visitGroupedWithMeteredMinimum(
            groupedWithMeteredMinimum: GroupedWithMeteredMinimumPrice
        ): T

        fun visitMatrixWithDisplayName(matrixWithDisplayName: MatrixWithDisplayNamePrice): T

        fun visitBulkWithProration(bulkWithProration: BulkWithProrationPrice): T

        fun visitGroupedTieredPackage(groupedTieredPackage: GroupedTieredPackagePrice): T

        fun visitMaxGroupTieredPackage(maxGroupTieredPackage: MaxGroupTieredPackagePrice): T

        fun visitScalableMatrixWithUnitPricing(
            scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricingPrice
        ): T

        fun visitScalableMatrixWithTieredPricing(
            scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricingPrice
        ): T

        fun visitCumulativeGroupedBulk(cumulativeGroupedBulk: CumulativeGroupedBulkPrice): T

        /**
         * Maps an unknown variant of [Price] to a value of type [T].
         *
         * An instance of [Price] can contain an unknown variant if it was deserialized from data
         * that doesn't match any known variant. For example, if the SDK is on an older version than
         * the API, then the API may respond with new variants that the SDK is unaware of.
         *
         * @throws OrbInvalidDataException in the default implementation.
         */
        fun unknown(json: JsonValue?): T {
            throw OrbInvalidDataException("Unknown Price: $json")
        }
    }

    internal class Deserializer : BaseDeserializer<Price>(Price::class) {

        override fun ObjectCodec.deserialize(node: JsonNode): Price {
            val json = JsonValue.fromJsonNode(node)
            val modelType = json.asObject().getOrNull()?.get("model_type")?.asString()?.getOrNull()

            when (modelType) {
                "unit" -> {
                    tryDeserialize(node, jacksonTypeRef<UnitPrice>()) { it.validate() }
                        ?.let {
                            return Price(unit = it, _json = json)
                        }
                }
                "package" -> {
                    tryDeserialize(node, jacksonTypeRef<PackagePrice>()) { it.validate() }
                        ?.let {
                            return Price(packagePrice = it, _json = json)
                        }
                }
                "matrix" -> {
                    tryDeserialize(node, jacksonTypeRef<MatrixPrice>()) { it.validate() }
                        ?.let {
                            return Price(matrix = it, _json = json)
                        }
                }
                "tiered" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredPrice>()) { it.validate() }
                        ?.let {
                            return Price(tiered = it, _json = json)
                        }
                }
                "tiered_bps" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredBpsPrice>()) { it.validate() }
                        ?.let {
                            return Price(tieredBps = it, _json = json)
                        }
                }
                "bps" -> {
                    tryDeserialize(node, jacksonTypeRef<BpsPrice>()) { it.validate() }
                        ?.let {
                            return Price(bps = it, _json = json)
                        }
                }
                "bulk_bps" -> {
                    tryDeserialize(node, jacksonTypeRef<BulkBpsPrice>()) { it.validate() }
                        ?.let {
                            return Price(bulkBps = it, _json = json)
                        }
                }
                "bulk" -> {
                    tryDeserialize(node, jacksonTypeRef<BulkPrice>()) { it.validate() }
                        ?.let {
                            return Price(bulk = it, _json = json)
                        }
                }
                "threshold_total_amount" -> {
                    tryDeserialize(node, jacksonTypeRef<ThresholdTotalAmountPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(thresholdTotalAmount = it, _json = json)
                        }
                }
                "tiered_package" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredPackagePrice>()) { it.validate() }
                        ?.let {
                            return Price(tieredPackage = it, _json = json)
                        }
                }
                "grouped_tiered" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedTieredPrice>()) { it.validate() }
                        ?.let {
                            return Price(groupedTiered = it, _json = json)
                        }
                }
                "tiered_with_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredWithMinimumPrice>()) { it.validate() }
                        ?.let {
                            return Price(tieredWithMinimum = it, _json = json)
                        }
                }
                "tiered_package_with_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredPackageWithMinimumPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(tieredPackageWithMinimum = it, _json = json)
                        }
                }
                "package_with_allocation" -> {
                    tryDeserialize(node, jacksonTypeRef<PackageWithAllocationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(packageWithAllocation = it, _json = json)
                        }
                }
                "unit_with_percent" -> {
                    tryDeserialize(node, jacksonTypeRef<UnitWithPercentPrice>()) { it.validate() }
                        ?.let {
                            return Price(unitWithPercent = it, _json = json)
                        }
                }
                "matrix_with_allocation" -> {
                    tryDeserialize(node, jacksonTypeRef<MatrixWithAllocationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(matrixWithAllocation = it, _json = json)
                        }
                }
                "tiered_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(tieredWithProration = it, _json = json)
                        }
                }
                "unit_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<UnitWithProrationPrice>()) { it.validate() }
                        ?.let {
                            return Price(unitWithProration = it, _json = json)
                        }
                }
                "grouped_allocation" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedAllocationPrice>()) { it.validate() }
                        ?.let {
                            return Price(groupedAllocation = it, _json = json)
                        }
                }
                "grouped_with_prorated_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedWithProratedMinimumPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(groupedWithProratedMinimum = it, _json = json)
                        }
                }
                "grouped_with_metered_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedWithMeteredMinimumPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(groupedWithMeteredMinimum = it, _json = json)
                        }
                }
                "matrix_with_display_name" -> {
                    tryDeserialize(node, jacksonTypeRef<MatrixWithDisplayNamePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(matrixWithDisplayName = it, _json = json)
                        }
                }
                "bulk_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<BulkWithProrationPrice>()) { it.validate() }
                        ?.let {
                            return Price(bulkWithProration = it, _json = json)
                        }
                }
                "grouped_tiered_package" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedTieredPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(groupedTieredPackage = it, _json = json)
                        }
                }
                "max_group_tiered_package" -> {
                    tryDeserialize(node, jacksonTypeRef<MaxGroupTieredPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(maxGroupTieredPackage = it, _json = json)
                        }
                }
                "scalable_matrix_with_unit_pricing" -> {
                    tryDeserialize(node, jacksonTypeRef<ScalableMatrixWithUnitPricingPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(scalableMatrixWithUnitPricing = it, _json = json)
                        }
                }
                "scalable_matrix_with_tiered_pricing" -> {
                    tryDeserialize(node, jacksonTypeRef<ScalableMatrixWithTieredPricingPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(scalableMatrixWithTieredPricing = it, _json = json)
                        }
                }
                "cumulative_grouped_bulk" -> {
                    tryDeserialize(node, jacksonTypeRef<CumulativeGroupedBulkPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return Price(cumulativeGroupedBulk = it, _json = json)
                        }
                }
            }

            return Price(_json = json)
        }
    }

    internal class Serializer : BaseSerializer<Price>(Price::class) {

        override fun serialize(
            value: Price,
            generator: JsonGenerator,
            provider: SerializerProvider,
        ) {
            when {
                value.unit != null -> generator.writeObject(value.unit)
                value.packagePrice != null -> generator.writeObject(value.packagePrice)
                value.matrix != null -> generator.writeObject(value.matrix)
                value.tiered != null -> generator.writeObject(value.tiered)
                value.tieredBps != null -> generator.writeObject(value.tieredBps)
                value.bps != null -> generator.writeObject(value.bps)
                value.bulkBps != null -> generator.writeObject(value.bulkBps)
                value.bulk != null -> generator.writeObject(value.bulk)
                value.thresholdTotalAmount != null ->
                    generator.writeObject(value.thresholdTotalAmount)
                value.tieredPackage != null -> generator.writeObject(value.tieredPackage)
                value.groupedTiered != null -> generator.writeObject(value.groupedTiered)
                value.tieredWithMinimum != null -> generator.writeObject(value.tieredWithMinimum)
                value.tieredPackageWithMinimum != null ->
                    generator.writeObject(value.tieredPackageWithMinimum)
                value.packageWithAllocation != null ->
                    generator.writeObject(value.packageWithAllocation)
                value.unitWithPercent != null -> generator.writeObject(value.unitWithPercent)
                value.matrixWithAllocation != null ->
                    generator.writeObject(value.matrixWithAllocation)
                value.tieredWithProration != null ->
                    generator.writeObject(value.tieredWithProration)
                value.unitWithProration != null -> generator.writeObject(value.unitWithProration)
                value.groupedAllocation != null -> generator.writeObject(value.groupedAllocation)
                value.groupedWithProratedMinimum != null ->
                    generator.writeObject(value.groupedWithProratedMinimum)
                value.groupedWithMeteredMinimum != null ->
                    generator.writeObject(value.groupedWithMeteredMinimum)
                value.matrixWithDisplayName != null ->
                    generator.writeObject(value.matrixWithDisplayName)
                value.bulkWithProration != null -> generator.writeObject(value.bulkWithProration)
                value.groupedTieredPackage != null ->
                    generator.writeObject(value.groupedTieredPackage)
                value.maxGroupTieredPackage != null ->
                    generator.writeObject(value.maxGroupTieredPackage)
                value.scalableMatrixWithUnitPricing != null ->
                    generator.writeObject(value.scalableMatrixWithUnitPricing)
                value.scalableMatrixWithTieredPricing != null ->
                    generator.writeObject(value.scalableMatrixWithTieredPricing)
                value.cumulativeGroupedBulk != null ->
                    generator.writeObject(value.cumulativeGroupedBulk)
                value._json != null -> generator.writeObject(value._json)
                else -> throw IllegalStateException("Invalid Price")
            }
        }
    }

    @NoAutoDetect
    class UnitPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("unit_config")
        @ExcludeMissing
        private val unitConfig: JsonField<UnitConfig> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun unitConfig(): UnitConfig = unitConfig.getRequired("unit_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [unitConfig].
         *
         * Unlike [unitConfig], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("unit_config")
        @ExcludeMissing
        fun _unitConfig(): JsonField<UnitConfig> = unitConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): UnitPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            unitConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [UnitPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .unitConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [UnitPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var unitConfig: JsonField<UnitConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(unitPrice: UnitPrice) = apply {
                id = unitPrice.id
                billableMetric = unitPrice.billableMetric
                billingCycleConfiguration = unitPrice.billingCycleConfiguration
                cadence = unitPrice.cadence
                conversionRate = unitPrice.conversionRate
                createdAt = unitPrice.createdAt
                creditAllocation = unitPrice.creditAllocation
                currency = unitPrice.currency
                discount = unitPrice.discount
                externalPriceId = unitPrice.externalPriceId
                fixedPriceQuantity = unitPrice.fixedPriceQuantity
                invoicingCycleConfiguration = unitPrice.invoicingCycleConfiguration
                item = unitPrice.item
                maximum = unitPrice.maximum
                maximumAmount = unitPrice.maximumAmount
                metadata = unitPrice.metadata
                minimum = unitPrice.minimum
                minimumAmount = unitPrice.minimumAmount
                modelType = unitPrice.modelType
                name = unitPrice.name
                planPhaseOrder = unitPrice.planPhaseOrder
                priceType = unitPrice.priceType
                unitConfig = unitPrice.unitConfig
                dimensionalPriceConfiguration = unitPrice.dimensionalPriceConfiguration
                additionalProperties = unitPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun unitConfig(unitConfig: UnitConfig) = unitConfig(JsonField.of(unitConfig))

            /**
             * Sets [Builder.unitConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.unitConfig] with a well-typed [UnitConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun unitConfig(unitConfig: JsonField<UnitConfig>) = apply {
                this.unitConfig = unitConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): UnitPrice =
                UnitPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("unitConfig", unitConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT = of("unit")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                UNIT
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                UNIT,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    UNIT -> Value.UNIT
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    UNIT -> Known.UNIT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class UnitConfig
        @JsonCreator
        private constructor(
            @JsonProperty("unit_amount")
            @ExcludeMissing
            private val unitAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * Rate per unit of usage
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun unitAmount(): String = unitAmount.getRequired("unit_amount")

            /**
             * Returns the raw JSON value of [unitAmount].
             *
             * Unlike [unitAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("unit_amount")
            @ExcludeMissing
            fun _unitAmount(): JsonField<String> = unitAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): UnitConfig = apply {
                if (validated) {
                    return@apply
                }

                unitAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [UnitConfig].
                 *
                 * The following fields are required:
                 * ```java
                 * .unitAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [UnitConfig]. */
            class Builder internal constructor() {

                private var unitAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(unitConfig: UnitConfig) = apply {
                    unitAmount = unitConfig.unitAmount
                    additionalProperties = unitConfig.additionalProperties.toMutableMap()
                }

                /** Rate per unit of usage */
                fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                /**
                 * Sets [Builder.unitAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.unitAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun unitAmount(unitAmount: JsonField<String>) = apply {
                    this.unitAmount = unitAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): UnitConfig =
                    UnitConfig(
                        checkRequired("unitAmount", unitAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is UnitConfig && unitAmount == other.unitAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(unitAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "UnitConfig{unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is UnitPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && unitConfig == other.unitConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, unitConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "UnitPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, unitConfig=$unitConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class PackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("package_config")
        @ExcludeMissing
        private val packageConfig: JsonField<PackageConfig> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun packageConfig(): PackageConfig = packageConfig.getRequired("package_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [packageConfig].
         *
         * Unlike [packageConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("package_config")
        @ExcludeMissing
        fun _packageConfig(): JsonField<PackageConfig> = packageConfig

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): PackagePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            packageConfig().validate()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [PackagePrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .packageConfig()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [PackagePrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var packageConfig: JsonField<PackageConfig>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(packagePrice: PackagePrice) = apply {
                id = packagePrice.id
                billableMetric = packagePrice.billableMetric
                billingCycleConfiguration = packagePrice.billingCycleConfiguration
                cadence = packagePrice.cadence
                conversionRate = packagePrice.conversionRate
                createdAt = packagePrice.createdAt
                creditAllocation = packagePrice.creditAllocation
                currency = packagePrice.currency
                discount = packagePrice.discount
                externalPriceId = packagePrice.externalPriceId
                fixedPriceQuantity = packagePrice.fixedPriceQuantity
                invoicingCycleConfiguration = packagePrice.invoicingCycleConfiguration
                item = packagePrice.item
                maximum = packagePrice.maximum
                maximumAmount = packagePrice.maximumAmount
                metadata = packagePrice.metadata
                minimum = packagePrice.minimum
                minimumAmount = packagePrice.minimumAmount
                modelType = packagePrice.modelType
                name = packagePrice.name
                packageConfig = packagePrice.packageConfig
                planPhaseOrder = packagePrice.planPhaseOrder
                priceType = packagePrice.priceType
                dimensionalPriceConfiguration = packagePrice.dimensionalPriceConfiguration
                additionalProperties = packagePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun packageConfig(packageConfig: PackageConfig) =
                packageConfig(JsonField.of(packageConfig))

            /**
             * Sets [Builder.packageConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.packageConfig] with a well-typed [PackageConfig]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun packageConfig(packageConfig: JsonField<PackageConfig>) = apply {
                this.packageConfig = packageConfig
            }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): PackagePrice =
                PackagePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("packageConfig", packageConfig),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val PACKAGE = of("package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    PACKAGE -> Value.PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    PACKAGE -> Known.PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class PackageConfig
        @JsonCreator
        private constructor(
            @JsonProperty("package_amount")
            @ExcludeMissing
            private val packageAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("package_size")
            @ExcludeMissing
            private val packageSize: JsonField<Long> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * A currency amount to rate usage by
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun packageAmount(): String = packageAmount.getRequired("package_amount")

            /**
             * An integer amount to represent package size. For example, 1000 here would divide
             * usage by 1000 before multiplying by package_amount in rating
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun packageSize(): Long = packageSize.getRequired("package_size")

            /**
             * Returns the raw JSON value of [packageAmount].
             *
             * Unlike [packageAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("package_amount")
            @ExcludeMissing
            fun _packageAmount(): JsonField<String> = packageAmount

            /**
             * Returns the raw JSON value of [packageSize].
             *
             * Unlike [packageSize], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("package_size")
            @ExcludeMissing
            fun _packageSize(): JsonField<Long> = packageSize

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): PackageConfig = apply {
                if (validated) {
                    return@apply
                }

                packageAmount()
                packageSize()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [PackageConfig].
                 *
                 * The following fields are required:
                 * ```java
                 * .packageAmount()
                 * .packageSize()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [PackageConfig]. */
            class Builder internal constructor() {

                private var packageAmount: JsonField<String>? = null
                private var packageSize: JsonField<Long>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(packageConfig: PackageConfig) = apply {
                    packageAmount = packageConfig.packageAmount
                    packageSize = packageConfig.packageSize
                    additionalProperties = packageConfig.additionalProperties.toMutableMap()
                }

                /** A currency amount to rate usage by */
                fun packageAmount(packageAmount: String) =
                    packageAmount(JsonField.of(packageAmount))

                /**
                 * Sets [Builder.packageAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.packageAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun packageAmount(packageAmount: JsonField<String>) = apply {
                    this.packageAmount = packageAmount
                }

                /**
                 * An integer amount to represent package size. For example, 1000 here would divide
                 * usage by 1000 before multiplying by package_amount in rating
                 */
                fun packageSize(packageSize: Long) = packageSize(JsonField.of(packageSize))

                /**
                 * Sets [Builder.packageSize] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.packageSize] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun packageSize(packageSize: JsonField<Long>) = apply {
                    this.packageSize = packageSize
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): PackageConfig =
                    PackageConfig(
                        checkRequired("packageAmount", packageAmount),
                        checkRequired("packageSize", packageSize),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PackageConfig && packageAmount == other.packageAmount && packageSize == other.packageSize && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(packageAmount, packageSize, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "PackageConfig{packageAmount=$packageAmount, packageSize=$packageSize, additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is PackagePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && packageConfig == other.packageConfig && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, packageConfig, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "PackagePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, packageConfig=$packageConfig, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class MatrixPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("matrix_config")
        @ExcludeMissing
        private val matrixConfig: JsonField<MatrixConfig> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun matrixConfig(): MatrixConfig = matrixConfig.getRequired("matrix_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [matrixConfig].
         *
         * Unlike [matrixConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("matrix_config")
        @ExcludeMissing
        fun _matrixConfig(): JsonField<MatrixConfig> = matrixConfig

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): MatrixPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            matrixConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [MatrixPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [MatrixPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var matrixConfig: JsonField<MatrixConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(matrixPrice: MatrixPrice) = apply {
                id = matrixPrice.id
                billableMetric = matrixPrice.billableMetric
                billingCycleConfiguration = matrixPrice.billingCycleConfiguration
                cadence = matrixPrice.cadence
                conversionRate = matrixPrice.conversionRate
                createdAt = matrixPrice.createdAt
                creditAllocation = matrixPrice.creditAllocation
                currency = matrixPrice.currency
                discount = matrixPrice.discount
                externalPriceId = matrixPrice.externalPriceId
                fixedPriceQuantity = matrixPrice.fixedPriceQuantity
                invoicingCycleConfiguration = matrixPrice.invoicingCycleConfiguration
                item = matrixPrice.item
                matrixConfig = matrixPrice.matrixConfig
                maximum = matrixPrice.maximum
                maximumAmount = matrixPrice.maximumAmount
                metadata = matrixPrice.metadata
                minimum = matrixPrice.minimum
                minimumAmount = matrixPrice.minimumAmount
                modelType = matrixPrice.modelType
                name = matrixPrice.name
                planPhaseOrder = matrixPrice.planPhaseOrder
                priceType = matrixPrice.priceType
                dimensionalPriceConfiguration = matrixPrice.dimensionalPriceConfiguration
                additionalProperties = matrixPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun matrixConfig(matrixConfig: MatrixConfig) = matrixConfig(JsonField.of(matrixConfig))

            /**
             * Sets [Builder.matrixConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.matrixConfig] with a well-typed [MatrixConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun matrixConfig(matrixConfig: JsonField<MatrixConfig>) = apply {
                this.matrixConfig = matrixConfig
            }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): MatrixPrice =
                MatrixPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixConfig", matrixConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class MatrixConfig
        @JsonCreator
        private constructor(
            @JsonProperty("default_unit_amount")
            @ExcludeMissing
            private val defaultUnitAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensions")
            @ExcludeMissing
            private val dimensions: JsonField<List<String?>> = JsonMissing.of(),
            @JsonProperty("matrix_values")
            @ExcludeMissing
            private val matrixValues: JsonField<List<MatrixValue>> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * Default per unit rate for any usage not bucketed into a specified matrix_value
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun defaultUnitAmount(): String = defaultUnitAmount.getRequired("default_unit_amount")

            /**
             * One or two event property values to evaluate matrix groups by
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensions(): List<String?> = dimensions.getRequired("dimensions")

            /**
             * Matrix values for specified matrix grouping keys
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun matrixValues(): List<MatrixValue> = matrixValues.getRequired("matrix_values")

            /**
             * Returns the raw JSON value of [defaultUnitAmount].
             *
             * Unlike [defaultUnitAmount], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("default_unit_amount")
            @ExcludeMissing
            fun _defaultUnitAmount(): JsonField<String> = defaultUnitAmount

            /**
             * Returns the raw JSON value of [dimensions].
             *
             * Unlike [dimensions], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("dimensions")
            @ExcludeMissing
            fun _dimensions(): JsonField<List<String?>> = dimensions

            /**
             * Returns the raw JSON value of [matrixValues].
             *
             * Unlike [matrixValues], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("matrix_values")
            @ExcludeMissing
            fun _matrixValues(): JsonField<List<MatrixValue>> = matrixValues

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): MatrixConfig = apply {
                if (validated) {
                    return@apply
                }

                defaultUnitAmount()
                dimensions()
                matrixValues().forEach { it.validate() }
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [MatrixConfig].
                 *
                 * The following fields are required:
                 * ```java
                 * .defaultUnitAmount()
                 * .dimensions()
                 * .matrixValues()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [MatrixConfig]. */
            class Builder internal constructor() {

                private var defaultUnitAmount: JsonField<String>? = null
                private var dimensions: JsonField<MutableList<String?>>? = null
                private var matrixValues: JsonField<MutableList<MatrixValue>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(matrixConfig: MatrixConfig) = apply {
                    defaultUnitAmount = matrixConfig.defaultUnitAmount
                    dimensions = matrixConfig.dimensions.map { it.toMutableList() }
                    matrixValues = matrixConfig.matrixValues.map { it.toMutableList() }
                    additionalProperties = matrixConfig.additionalProperties.toMutableMap()
                }

                /**
                 * Default per unit rate for any usage not bucketed into a specified matrix_value
                 */
                fun defaultUnitAmount(defaultUnitAmount: String) =
                    defaultUnitAmount(JsonField.of(defaultUnitAmount))

                /**
                 * Sets [Builder.defaultUnitAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.defaultUnitAmount] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun defaultUnitAmount(defaultUnitAmount: JsonField<String>) = apply {
                    this.defaultUnitAmount = defaultUnitAmount
                }

                /** One or two event property values to evaluate matrix groups by */
                fun dimensions(dimensions: List<String?>) = dimensions(JsonField.of(dimensions))

                /**
                 * Sets [Builder.dimensions] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensions] with a well-typed `List<String?>`
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun dimensions(dimensions: JsonField<List<String?>>) = apply {
                    this.dimensions = dimensions.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensions].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimension(dimension: String) = apply {
                    dimensions =
                        (dimensions ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensions", it).add(dimension)
                        }
                }

                /** Matrix values for specified matrix grouping keys */
                fun matrixValues(matrixValues: List<MatrixValue>) =
                    matrixValues(JsonField.of(matrixValues))

                /**
                 * Sets [Builder.matrixValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.matrixValues] with a well-typed
                 * `List<MatrixValue>` value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun matrixValues(matrixValues: JsonField<List<MatrixValue>>) = apply {
                    this.matrixValues = matrixValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [MatrixValue] to [matrixValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addMatrixValue(matrixValue: MatrixValue) = apply {
                    matrixValues =
                        (matrixValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("matrixValues", it).add(matrixValue)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): MatrixConfig =
                    MatrixConfig(
                        checkRequired("defaultUnitAmount", defaultUnitAmount),
                        checkRequired("dimensions", dimensions).map { it.toImmutable() },
                        checkRequired("matrixValues", matrixValues).map { it.toImmutable() },
                        additionalProperties.toImmutable(),
                    )
            }

            @NoAutoDetect
            class MatrixValue
            @JsonCreator
            private constructor(
                @JsonProperty("dimension_values")
                @ExcludeMissing
                private val dimensionValues: JsonField<List<String?>> = JsonMissing.of(),
                @JsonProperty("unit_amount")
                @ExcludeMissing
                private val unitAmount: JsonField<String> = JsonMissing.of(),
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /**
                 * One or two matrix keys to filter usage to this Matrix value by. For example,
                 * ["region", "tier"] could be used to filter cloud usage by a cloud region and an
                 * instance tier.
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun dimensionValues(): List<String?> =
                    dimensionValues.getRequired("dimension_values")

                /**
                 * Unit price for the specified dimension_values
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * Returns the raw JSON value of [dimensionValues].
                 *
                 * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("dimension_values")
                @ExcludeMissing
                fun _dimensionValues(): JsonField<List<String?>> = dimensionValues

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                private var validated: Boolean = false

                fun validate(): MatrixValue = apply {
                    if (validated) {
                        return@apply
                    }

                    dimensionValues()
                    unitAmount()
                    validated = true
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [MatrixValue].
                     *
                     * The following fields are required:
                     * ```java
                     * .dimensionValues()
                     * .unitAmount()
                     * ```
                     */
                    @JvmStatic fun builder() = Builder()
                }

                /** A builder for [MatrixValue]. */
                class Builder internal constructor() {

                    private var dimensionValues: JsonField<MutableList<String?>>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(matrixValue: MatrixValue) = apply {
                        dimensionValues = matrixValue.dimensionValues.map { it.toMutableList() }
                        unitAmount = matrixValue.unitAmount
                        additionalProperties = matrixValue.additionalProperties.toMutableMap()
                    }

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    fun dimensionValues(dimensionValues: List<String?>) =
                        dimensionValues(JsonField.of(dimensionValues))

                    /**
                     * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.dimensionValues] with a well-typed
                     * `List<String?>` value instead. This method is primarily for setting the field
                     * to an undocumented or not yet supported value.
                     */
                    fun dimensionValues(dimensionValues: JsonField<List<String?>>) = apply {
                        this.dimensionValues = dimensionValues.map { it.toMutableList() }
                    }

                    /**
                     * Adds a single [String] to [dimensionValues].
                     *
                     * @throws IllegalStateException if the field was previously set to a non-list.
                     */
                    fun addDimensionValue(dimensionValue: String) = apply {
                        dimensionValues =
                            (dimensionValues ?: JsonField.of(mutableListOf())).also {
                                checkKnown("dimensionValues", it).add(dimensionValue)
                            }
                    }

                    /** Unit price for the specified dimension_values */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): MatrixValue =
                        MatrixValue(
                            checkRequired("dimensionValues", dimensionValues).map {
                                it.toImmutable()
                            },
                            checkRequired("unitAmount", unitAmount),
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is MatrixValue && dimensionValues == other.dimensionValues && unitAmount == other.unitAmount && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(dimensionValues, unitAmount, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "MatrixValue{dimensionValues=$dimensionValues, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is MatrixConfig && defaultUnitAmount == other.defaultUnitAmount && dimensions == other.dimensions && matrixValues == other.matrixValues && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(defaultUnitAmount, dimensions, matrixValues, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "MatrixConfig{defaultUnitAmount=$defaultUnitAmount, dimensions=$dimensions, matrixValues=$matrixValues, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX = of("matrix")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MATRIX
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MATRIX,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MATRIX -> Value.MATRIX
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MATRIX -> Known.MATRIX
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MatrixPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && matrixConfig == other.matrixConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, matrixConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MatrixPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixConfig=$matrixConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_config")
        @ExcludeMissing
        private val tieredConfig: JsonField<TieredConfig> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredConfig(): TieredConfig = tieredConfig.getRequired("tiered_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [tieredConfig].
         *
         * Unlike [tieredConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("tiered_config")
        @ExcludeMissing
        fun _tieredConfig(): JsonField<TieredConfig> = tieredConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .tieredConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredConfig: JsonField<TieredConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredPrice: TieredPrice) = apply {
                id = tieredPrice.id
                billableMetric = tieredPrice.billableMetric
                billingCycleConfiguration = tieredPrice.billingCycleConfiguration
                cadence = tieredPrice.cadence
                conversionRate = tieredPrice.conversionRate
                createdAt = tieredPrice.createdAt
                creditAllocation = tieredPrice.creditAllocation
                currency = tieredPrice.currency
                discount = tieredPrice.discount
                externalPriceId = tieredPrice.externalPriceId
                fixedPriceQuantity = tieredPrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredPrice.invoicingCycleConfiguration
                item = tieredPrice.item
                maximum = tieredPrice.maximum
                maximumAmount = tieredPrice.maximumAmount
                metadata = tieredPrice.metadata
                minimum = tieredPrice.minimum
                minimumAmount = tieredPrice.minimumAmount
                modelType = tieredPrice.modelType
                name = tieredPrice.name
                planPhaseOrder = tieredPrice.planPhaseOrder
                priceType = tieredPrice.priceType
                tieredConfig = tieredPrice.tieredConfig
                dimensionalPriceConfiguration = tieredPrice.dimensionalPriceConfiguration
                additionalProperties = tieredPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredConfig(tieredConfig: TieredConfig) = tieredConfig(JsonField.of(tieredConfig))

            /**
             * Sets [Builder.tieredConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredConfig] with a well-typed [TieredConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun tieredConfig(tieredConfig: JsonField<TieredConfig>) = apply {
                this.tieredConfig = tieredConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredPrice =
                TieredPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredConfig", tieredConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED = of("tiered")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED -> Value.TIERED
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED -> Known.TIERED
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class TieredConfig
        @JsonCreator
        private constructor(
            @JsonProperty("tiers")
            @ExcludeMissing
            private val tiers: JsonField<List<Tier>> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * Tiers for rating based on total usage quantities into the specified tier
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): TieredConfig = apply {
                if (validated) {
                    return@apply
                }

                tiers().forEach { it.validate() }
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [TieredConfig].
                 *
                 * The following fields are required:
                 * ```java
                 * .tiers()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [TieredConfig]. */
            class Builder internal constructor() {

                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredConfig: TieredConfig) = apply {
                    tiers = tieredConfig.tiers.map { it.toMutableList() }
                    additionalProperties = tieredConfig.additionalProperties.toMutableMap()
                }

                /** Tiers for rating based on total usage quantities into the specified tier */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): TieredConfig =
                    TieredConfig(
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toImmutable(),
                    )
            }

            @NoAutoDetect
            class Tier
            @JsonCreator
            private constructor(
                @JsonProperty("first_unit")
                @ExcludeMissing
                private val firstUnit: JsonField<Double> = JsonMissing.of(),
                @JsonProperty("unit_amount")
                @ExcludeMissing
                private val unitAmount: JsonField<String> = JsonMissing.of(),
                @JsonProperty("last_unit")
                @ExcludeMissing
                private val lastUnit: JsonField<Double> = JsonMissing.of(),
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /**
                 * Inclusive tier starting value
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun firstUnit(): Double = firstUnit.getRequired("first_unit")

                /**
                 * Amount per unit
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * Exclusive tier ending value. If null, this is treated as the last tier
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if
                 *   the server responded with an unexpected value).
                 */
                fun lastUnit(): Optional<Double> =
                    Optional.ofNullable(lastUnit.getNullable("last_unit"))

                /**
                 * Returns the raw JSON value of [firstUnit].
                 *
                 * Unlike [firstUnit], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("first_unit")
                @ExcludeMissing
                fun _firstUnit(): JsonField<Double> = firstUnit

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                /**
                 * Returns the raw JSON value of [lastUnit].
                 *
                 * Unlike [lastUnit], this method doesn't throw if the JSON field has an unexpected
                 * type.
                 */
                @JsonProperty("last_unit")
                @ExcludeMissing
                fun _lastUnit(): JsonField<Double> = lastUnit

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    firstUnit()
                    unitAmount()
                    lastUnit()
                    validated = true
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```java
                     * .firstUnit()
                     * .unitAmount()
                     * ```
                     */
                    @JvmStatic fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var firstUnit: JsonField<Double>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var lastUnit: JsonField<Double> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tier: Tier) = apply {
                        firstUnit = tier.firstUnit
                        unitAmount = tier.unitAmount
                        lastUnit = tier.lastUnit
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Inclusive tier starting value */
                    fun firstUnit(firstUnit: Double) = firstUnit(JsonField.of(firstUnit))

                    /**
                     * Sets [Builder.firstUnit] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.firstUnit] with a well-typed [Double] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun firstUnit(firstUnit: JsonField<Double>) = apply {
                        this.firstUnit = firstUnit
                    }

                    /** Amount per unit */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    /** Exclusive tier ending value. If null, this is treated as the last tier */
                    fun lastUnit(lastUnit: Double?) = lastUnit(JsonField.ofNullable(lastUnit))

                    /**
                     * Alias for [Builder.lastUnit].
                     *
                     * This unboxed primitive overload exists for backwards compatibility.
                     */
                    fun lastUnit(lastUnit: Double) = lastUnit(lastUnit as Double?)

                    /** Alias for calling [Builder.lastUnit] with `lastUnit.orElse(null)`. */
                    fun lastUnit(lastUnit: Optional<Double>) = lastUnit(lastUnit.getOrNull())

                    /**
                     * Sets [Builder.lastUnit] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.lastUnit] with a well-typed [Double] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun lastUnit(lastUnit: JsonField<Double>) = apply { this.lastUnit = lastUnit }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Tier =
                        Tier(
                            checkRequired("firstUnit", firstUnit),
                            checkRequired("unitAmount", unitAmount),
                            lastUnit,
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Tier && firstUnit == other.firstUnit && unitAmount == other.unitAmount && lastUnit == other.lastUnit && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(firstUnit, unitAmount, lastUnit, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{firstUnit=$firstUnit, unitAmount=$unitAmount, lastUnit=$lastUnit, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredConfig && tiers == other.tiers && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredConfig == other.tieredConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredConfig=$tieredConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredBpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_bps_config")
        @ExcludeMissing
        private val tieredBpsConfig: JsonField<TieredBpsConfig> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredBpsConfig(): TieredBpsConfig = tieredBpsConfig.getRequired("tiered_bps_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [tieredBpsConfig].
         *
         * Unlike [tieredBpsConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("tiered_bps_config")
        @ExcludeMissing
        fun _tieredBpsConfig(): JsonField<TieredBpsConfig> = tieredBpsConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredBpsPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredBpsConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredBpsPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .tieredBpsConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredBpsPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredBpsConfig: JsonField<TieredBpsConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredBpsPrice: TieredBpsPrice) = apply {
                id = tieredBpsPrice.id
                billableMetric = tieredBpsPrice.billableMetric
                billingCycleConfiguration = tieredBpsPrice.billingCycleConfiguration
                cadence = tieredBpsPrice.cadence
                conversionRate = tieredBpsPrice.conversionRate
                createdAt = tieredBpsPrice.createdAt
                creditAllocation = tieredBpsPrice.creditAllocation
                currency = tieredBpsPrice.currency
                discount = tieredBpsPrice.discount
                externalPriceId = tieredBpsPrice.externalPriceId
                fixedPriceQuantity = tieredBpsPrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredBpsPrice.invoicingCycleConfiguration
                item = tieredBpsPrice.item
                maximum = tieredBpsPrice.maximum
                maximumAmount = tieredBpsPrice.maximumAmount
                metadata = tieredBpsPrice.metadata
                minimum = tieredBpsPrice.minimum
                minimumAmount = tieredBpsPrice.minimumAmount
                modelType = tieredBpsPrice.modelType
                name = tieredBpsPrice.name
                planPhaseOrder = tieredBpsPrice.planPhaseOrder
                priceType = tieredBpsPrice.priceType
                tieredBpsConfig = tieredBpsPrice.tieredBpsConfig
                dimensionalPriceConfiguration = tieredBpsPrice.dimensionalPriceConfiguration
                additionalProperties = tieredBpsPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredBpsConfig(tieredBpsConfig: TieredBpsConfig) =
                tieredBpsConfig(JsonField.of(tieredBpsConfig))

            /**
             * Sets [Builder.tieredBpsConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredBpsConfig] with a well-typed [TieredBpsConfig]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun tieredBpsConfig(tieredBpsConfig: JsonField<TieredBpsConfig>) = apply {
                this.tieredBpsConfig = tieredBpsConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredBpsPrice =
                TieredBpsPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredBpsConfig", tieredBpsConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_BPS = of("tiered_bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_BPS
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_BPS,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_BPS -> Value.TIERED_BPS
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_BPS -> Known.TIERED_BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class TieredBpsConfig
        @JsonCreator
        private constructor(
            @JsonProperty("tiers")
            @ExcludeMissing
            private val tiers: JsonField<List<Tier>> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified tiers
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): TieredBpsConfig = apply {
                if (validated) {
                    return@apply
                }

                tiers().forEach { it.validate() }
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [TieredBpsConfig].
                 *
                 * The following fields are required:
                 * ```java
                 * .tiers()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [TieredBpsConfig]. */
            class Builder internal constructor() {

                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredBpsConfig: TieredBpsConfig) = apply {
                    tiers = tieredBpsConfig.tiers.map { it.toMutableList() }
                    additionalProperties = tieredBpsConfig.additionalProperties.toMutableMap()
                }

                /**
                 * Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
                 * tiers
                 */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): TieredBpsConfig =
                    TieredBpsConfig(
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toImmutable(),
                    )
            }

            @NoAutoDetect
            class Tier
            @JsonCreator
            private constructor(
                @JsonProperty("bps")
                @ExcludeMissing
                private val bps: JsonField<Double> = JsonMissing.of(),
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                private val minimumAmount: JsonField<String> = JsonMissing.of(),
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                private val maximumAmount: JsonField<String> = JsonMissing.of(),
                @JsonProperty("per_unit_maximum")
                @ExcludeMissing
                private val perUnitMaximum: JsonField<String> = JsonMissing.of(),
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /**
                 * Per-event basis point rate
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun bps(): Double = bps.getRequired("bps")

                /**
                 * Inclusive tier starting value
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

                /**
                 * Exclusive tier ending value
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if
                 *   the server responded with an unexpected value).
                 */
                fun maximumAmount(): Optional<String> =
                    Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                /**
                 * Per unit maximum to charge
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if
                 *   the server responded with an unexpected value).
                 */
                fun perUnitMaximum(): Optional<String> =
                    Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                /**
                 * Returns the raw JSON value of [bps].
                 *
                 * Unlike [bps], this method doesn't throw if the JSON field has an unexpected type.
                 */
                @JsonProperty("bps") @ExcludeMissing fun _bps(): JsonField<Double> = bps

                /**
                 * Returns the raw JSON value of [minimumAmount].
                 *
                 * Unlike [minimumAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("minimum_amount")
                @ExcludeMissing
                fun _minimumAmount(): JsonField<String> = minimumAmount

                /**
                 * Returns the raw JSON value of [maximumAmount].
                 *
                 * Unlike [maximumAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun _maximumAmount(): JsonField<String> = maximumAmount

                /**
                 * Returns the raw JSON value of [perUnitMaximum].
                 *
                 * Unlike [perUnitMaximum], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("per_unit_maximum")
                @ExcludeMissing
                fun _perUnitMaximum(): JsonField<String> = perUnitMaximum

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    bps()
                    minimumAmount()
                    maximumAmount()
                    perUnitMaximum()
                    validated = true
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```java
                     * .bps()
                     * .minimumAmount()
                     * ```
                     */
                    @JvmStatic fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var bps: JsonField<Double>? = null
                    private var minimumAmount: JsonField<String>? = null
                    private var maximumAmount: JsonField<String> = JsonMissing.of()
                    private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tier: Tier) = apply {
                        bps = tier.bps
                        minimumAmount = tier.minimumAmount
                        maximumAmount = tier.maximumAmount
                        perUnitMaximum = tier.perUnitMaximum
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Per-event basis point rate */
                    fun bps(bps: Double) = bps(JsonField.of(bps))

                    /**
                     * Sets [Builder.bps] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.bps] with a well-typed [Double] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                    /** Inclusive tier starting value */
                    fun minimumAmount(minimumAmount: String) =
                        minimumAmount(JsonField.of(minimumAmount))

                    /**
                     * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.minimumAmount] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                        this.minimumAmount = minimumAmount
                    }

                    /** Exclusive tier ending value */
                    fun maximumAmount(maximumAmount: String?) =
                        maximumAmount(JsonField.ofNullable(maximumAmount))

                    /**
                     * Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`.
                     */
                    fun maximumAmount(maximumAmount: Optional<String>) =
                        maximumAmount(maximumAmount.getOrNull())

                    /**
                     * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.maximumAmount] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                        this.maximumAmount = maximumAmount
                    }

                    /** Per unit maximum to charge */
                    fun perUnitMaximum(perUnitMaximum: String?) =
                        perUnitMaximum(JsonField.ofNullable(perUnitMaximum))

                    /**
                     * Alias for calling [Builder.perUnitMaximum] with
                     * `perUnitMaximum.orElse(null)`.
                     */
                    fun perUnitMaximum(perUnitMaximum: Optional<String>) =
                        perUnitMaximum(perUnitMaximum.getOrNull())

                    /**
                     * Sets [Builder.perUnitMaximum] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.perUnitMaximum] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                        this.perUnitMaximum = perUnitMaximum
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Tier =
                        Tier(
                            checkRequired("bps", bps),
                            checkRequired("minimumAmount", minimumAmount),
                            maximumAmount,
                            perUnitMaximum,
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Tier && bps == other.bps && minimumAmount == other.minimumAmount && maximumAmount == other.maximumAmount && perUnitMaximum == other.perUnitMaximum && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(bps, minimumAmount, maximumAmount, perUnitMaximum, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{bps=$bps, minimumAmount=$minimumAmount, maximumAmount=$maximumAmount, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredBpsConfig && tiers == other.tiers && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredBpsPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredBpsConfig == other.tieredBpsConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredBpsConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredBpsPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredBpsConfig=$tieredBpsConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class BpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("bps_config")
        @ExcludeMissing
        private val bpsConfig: JsonField<BpsConfig> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun bpsConfig(): BpsConfig = bpsConfig.getRequired("bps_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [bpsConfig].
         *
         * Unlike [bpsConfig], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("bps_config")
        @ExcludeMissing
        fun _bpsConfig(): JsonField<BpsConfig> = bpsConfig

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): BpsPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bpsConfig().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [BpsPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bpsConfig()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [BpsPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var bpsConfig: JsonField<BpsConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bpsPrice: BpsPrice) = apply {
                id = bpsPrice.id
                billableMetric = bpsPrice.billableMetric
                billingCycleConfiguration = bpsPrice.billingCycleConfiguration
                bpsConfig = bpsPrice.bpsConfig
                cadence = bpsPrice.cadence
                conversionRate = bpsPrice.conversionRate
                createdAt = bpsPrice.createdAt
                creditAllocation = bpsPrice.creditAllocation
                currency = bpsPrice.currency
                discount = bpsPrice.discount
                externalPriceId = bpsPrice.externalPriceId
                fixedPriceQuantity = bpsPrice.fixedPriceQuantity
                invoicingCycleConfiguration = bpsPrice.invoicingCycleConfiguration
                item = bpsPrice.item
                maximum = bpsPrice.maximum
                maximumAmount = bpsPrice.maximumAmount
                metadata = bpsPrice.metadata
                minimum = bpsPrice.minimum
                minimumAmount = bpsPrice.minimumAmount
                modelType = bpsPrice.modelType
                name = bpsPrice.name
                planPhaseOrder = bpsPrice.planPhaseOrder
                priceType = bpsPrice.priceType
                dimensionalPriceConfiguration = bpsPrice.dimensionalPriceConfiguration
                additionalProperties = bpsPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bpsConfig(bpsConfig: BpsConfig) = bpsConfig(JsonField.of(bpsConfig))

            /**
             * Sets [Builder.bpsConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.bpsConfig] with a well-typed [BpsConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun bpsConfig(bpsConfig: JsonField<BpsConfig>) = apply { this.bpsConfig = bpsConfig }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): BpsPrice =
                BpsPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bpsConfig", bpsConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BpsConfig
        @JsonCreator
        private constructor(
            @JsonProperty("bps")
            @ExcludeMissing
            private val bps: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("per_unit_maximum")
            @ExcludeMissing
            private val perUnitMaximum: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * Basis point take rate per event
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun bps(): Double = bps.getRequired("bps")

            /**
             * Optional currency amount maximum to cap spend per event
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
             *   server responded with an unexpected value).
             */
            fun perUnitMaximum(): Optional<String> =
                Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

            /**
             * Returns the raw JSON value of [bps].
             *
             * Unlike [bps], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("bps") @ExcludeMissing fun _bps(): JsonField<Double> = bps

            /**
             * Returns the raw JSON value of [perUnitMaximum].
             *
             * Unlike [perUnitMaximum], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("per_unit_maximum")
            @ExcludeMissing
            fun _perUnitMaximum(): JsonField<String> = perUnitMaximum

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BpsConfig = apply {
                if (validated) {
                    return@apply
                }

                bps()
                perUnitMaximum()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BpsConfig].
                 *
                 * The following fields are required:
                 * ```java
                 * .bps()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BpsConfig]. */
            class Builder internal constructor() {

                private var bps: JsonField<Double>? = null
                private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(bpsConfig: BpsConfig) = apply {
                    bps = bpsConfig.bps
                    perUnitMaximum = bpsConfig.perUnitMaximum
                    additionalProperties = bpsConfig.additionalProperties.toMutableMap()
                }

                /** Basis point take rate per event */
                fun bps(bps: Double) = bps(JsonField.of(bps))

                /**
                 * Sets [Builder.bps] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.bps] with a well-typed [Double] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                /** Optional currency amount maximum to cap spend per event */
                fun perUnitMaximum(perUnitMaximum: String?) =
                    perUnitMaximum(JsonField.ofNullable(perUnitMaximum))

                /**
                 * Alias for calling [Builder.perUnitMaximum] with `perUnitMaximum.orElse(null)`.
                 */
                fun perUnitMaximum(perUnitMaximum: Optional<String>) =
                    perUnitMaximum(perUnitMaximum.getOrNull())

                /**
                 * Sets [Builder.perUnitMaximum] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.perUnitMaximum] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                    this.perUnitMaximum = perUnitMaximum
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BpsConfig =
                    BpsConfig(
                        checkRequired("bps", bps),
                        perUnitMaximum,
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BpsConfig && bps == other.bps && perUnitMaximum == other.perUnitMaximum && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(bps, perUnitMaximum, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BpsConfig{bps=$bps, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BPS = of("bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BPS
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BPS,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BPS -> Value.BPS
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BPS -> Known.BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BpsPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bpsConfig == other.bpsConfig && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bpsConfig, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BpsPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bpsConfig=$bpsConfig, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class BulkBpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("bulk_bps_config")
        @ExcludeMissing
        private val bulkBpsConfig: JsonField<BulkBpsConfig> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun bulkBpsConfig(): BulkBpsConfig = bulkBpsConfig.getRequired("bulk_bps_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [bulkBpsConfig].
         *
         * Unlike [bulkBpsConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("bulk_bps_config")
        @ExcludeMissing
        fun _bulkBpsConfig(): JsonField<BulkBpsConfig> = bulkBpsConfig

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): BulkBpsPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bulkBpsConfig().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [BulkBpsPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bulkBpsConfig()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [BulkBpsPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var bulkBpsConfig: JsonField<BulkBpsConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bulkBpsPrice: BulkBpsPrice) = apply {
                id = bulkBpsPrice.id
                billableMetric = bulkBpsPrice.billableMetric
                billingCycleConfiguration = bulkBpsPrice.billingCycleConfiguration
                bulkBpsConfig = bulkBpsPrice.bulkBpsConfig
                cadence = bulkBpsPrice.cadence
                conversionRate = bulkBpsPrice.conversionRate
                createdAt = bulkBpsPrice.createdAt
                creditAllocation = bulkBpsPrice.creditAllocation
                currency = bulkBpsPrice.currency
                discount = bulkBpsPrice.discount
                externalPriceId = bulkBpsPrice.externalPriceId
                fixedPriceQuantity = bulkBpsPrice.fixedPriceQuantity
                invoicingCycleConfiguration = bulkBpsPrice.invoicingCycleConfiguration
                item = bulkBpsPrice.item
                maximum = bulkBpsPrice.maximum
                maximumAmount = bulkBpsPrice.maximumAmount
                metadata = bulkBpsPrice.metadata
                minimum = bulkBpsPrice.minimum
                minimumAmount = bulkBpsPrice.minimumAmount
                modelType = bulkBpsPrice.modelType
                name = bulkBpsPrice.name
                planPhaseOrder = bulkBpsPrice.planPhaseOrder
                priceType = bulkBpsPrice.priceType
                dimensionalPriceConfiguration = bulkBpsPrice.dimensionalPriceConfiguration
                additionalProperties = bulkBpsPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bulkBpsConfig(bulkBpsConfig: BulkBpsConfig) =
                bulkBpsConfig(JsonField.of(bulkBpsConfig))

            /**
             * Sets [Builder.bulkBpsConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.bulkBpsConfig] with a well-typed [BulkBpsConfig]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun bulkBpsConfig(bulkBpsConfig: JsonField<BulkBpsConfig>) = apply {
                this.bulkBpsConfig = bulkBpsConfig
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): BulkBpsPrice =
                BulkBpsPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bulkBpsConfig", bulkBpsConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BulkBpsConfig
        @JsonCreator
        private constructor(
            @JsonProperty("tiers")
            @ExcludeMissing
            private val tiers: JsonField<List<Tier>> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
             * based on total volume
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BulkBpsConfig = apply {
                if (validated) {
                    return@apply
                }

                tiers().forEach { it.validate() }
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BulkBpsConfig].
                 *
                 * The following fields are required:
                 * ```java
                 * .tiers()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BulkBpsConfig]. */
            class Builder internal constructor() {

                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(bulkBpsConfig: BulkBpsConfig) = apply {
                    tiers = bulkBpsConfig.tiers.map { it.toMutableList() }
                    additionalProperties = bulkBpsConfig.additionalProperties.toMutableMap()
                }

                /**
                 * Tiers for a bulk BPS pricing model where all usage is aggregated to a single tier
                 * based on total volume
                 */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BulkBpsConfig =
                    BulkBpsConfig(
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toImmutable(),
                    )
            }

            @NoAutoDetect
            class Tier
            @JsonCreator
            private constructor(
                @JsonProperty("bps")
                @ExcludeMissing
                private val bps: JsonField<Double> = JsonMissing.of(),
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                private val maximumAmount: JsonField<String> = JsonMissing.of(),
                @JsonProperty("per_unit_maximum")
                @ExcludeMissing
                private val perUnitMaximum: JsonField<String> = JsonMissing.of(),
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /**
                 * Basis points to rate on
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun bps(): Double = bps.getRequired("bps")

                /**
                 * Upper bound for tier
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if
                 *   the server responded with an unexpected value).
                 */
                fun maximumAmount(): Optional<String> =
                    Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

                /**
                 * The maximum amount to charge for any one event
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if
                 *   the server responded with an unexpected value).
                 */
                fun perUnitMaximum(): Optional<String> =
                    Optional.ofNullable(perUnitMaximum.getNullable("per_unit_maximum"))

                /**
                 * Returns the raw JSON value of [bps].
                 *
                 * Unlike [bps], this method doesn't throw if the JSON field has an unexpected type.
                 */
                @JsonProperty("bps") @ExcludeMissing fun _bps(): JsonField<Double> = bps

                /**
                 * Returns the raw JSON value of [maximumAmount].
                 *
                 * Unlike [maximumAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("maximum_amount")
                @ExcludeMissing
                fun _maximumAmount(): JsonField<String> = maximumAmount

                /**
                 * Returns the raw JSON value of [perUnitMaximum].
                 *
                 * Unlike [perUnitMaximum], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("per_unit_maximum")
                @ExcludeMissing
                fun _perUnitMaximum(): JsonField<String> = perUnitMaximum

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    bps()
                    maximumAmount()
                    perUnitMaximum()
                    validated = true
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```java
                     * .bps()
                     * ```
                     */
                    @JvmStatic fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var bps: JsonField<Double>? = null
                    private var maximumAmount: JsonField<String> = JsonMissing.of()
                    private var perUnitMaximum: JsonField<String> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tier: Tier) = apply {
                        bps = tier.bps
                        maximumAmount = tier.maximumAmount
                        perUnitMaximum = tier.perUnitMaximum
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Basis points to rate on */
                    fun bps(bps: Double) = bps(JsonField.of(bps))

                    /**
                     * Sets [Builder.bps] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.bps] with a well-typed [Double] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun bps(bps: JsonField<Double>) = apply { this.bps = bps }

                    /** Upper bound for tier */
                    fun maximumAmount(maximumAmount: String?) =
                        maximumAmount(JsonField.ofNullable(maximumAmount))

                    /**
                     * Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`.
                     */
                    fun maximumAmount(maximumAmount: Optional<String>) =
                        maximumAmount(maximumAmount.getOrNull())

                    /**
                     * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.maximumAmount] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                        this.maximumAmount = maximumAmount
                    }

                    /** The maximum amount to charge for any one event */
                    fun perUnitMaximum(perUnitMaximum: String?) =
                        perUnitMaximum(JsonField.ofNullable(perUnitMaximum))

                    /**
                     * Alias for calling [Builder.perUnitMaximum] with
                     * `perUnitMaximum.orElse(null)`.
                     */
                    fun perUnitMaximum(perUnitMaximum: Optional<String>) =
                        perUnitMaximum(perUnitMaximum.getOrNull())

                    /**
                     * Sets [Builder.perUnitMaximum] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.perUnitMaximum] with a well-typed [String]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun perUnitMaximum(perUnitMaximum: JsonField<String>) = apply {
                        this.perUnitMaximum = perUnitMaximum
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Tier =
                        Tier(
                            checkRequired("bps", bps),
                            maximumAmount,
                            perUnitMaximum,
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Tier && bps == other.bps && maximumAmount == other.maximumAmount && perUnitMaximum == other.perUnitMaximum && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(bps, maximumAmount, perUnitMaximum, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{bps=$bps, maximumAmount=$maximumAmount, perUnitMaximum=$perUnitMaximum, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BulkBpsConfig && tiers == other.tiers && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BulkBpsConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK_BPS = of("bulk_bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BULK_BPS
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BULK_BPS,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BULK_BPS -> Value.BULK_BPS
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BULK_BPS -> Known.BULK_BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BulkBpsPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bulkBpsConfig == other.bulkBpsConfig && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bulkBpsConfig, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BulkBpsPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bulkBpsConfig=$bulkBpsConfig, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class BulkPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("bulk_config")
        @ExcludeMissing
        private val bulkConfig: JsonField<BulkConfig> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun bulkConfig(): BulkConfig = bulkConfig.getRequired("bulk_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [bulkConfig].
         *
         * Unlike [bulkConfig], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("bulk_config")
        @ExcludeMissing
        fun _bulkConfig(): JsonField<BulkConfig> = bulkConfig

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): BulkPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bulkConfig().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [BulkPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bulkConfig()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [BulkPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var bulkConfig: JsonField<BulkConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bulkPrice: BulkPrice) = apply {
                id = bulkPrice.id
                billableMetric = bulkPrice.billableMetric
                billingCycleConfiguration = bulkPrice.billingCycleConfiguration
                bulkConfig = bulkPrice.bulkConfig
                cadence = bulkPrice.cadence
                conversionRate = bulkPrice.conversionRate
                createdAt = bulkPrice.createdAt
                creditAllocation = bulkPrice.creditAllocation
                currency = bulkPrice.currency
                discount = bulkPrice.discount
                externalPriceId = bulkPrice.externalPriceId
                fixedPriceQuantity = bulkPrice.fixedPriceQuantity
                invoicingCycleConfiguration = bulkPrice.invoicingCycleConfiguration
                item = bulkPrice.item
                maximum = bulkPrice.maximum
                maximumAmount = bulkPrice.maximumAmount
                metadata = bulkPrice.metadata
                minimum = bulkPrice.minimum
                minimumAmount = bulkPrice.minimumAmount
                modelType = bulkPrice.modelType
                name = bulkPrice.name
                planPhaseOrder = bulkPrice.planPhaseOrder
                priceType = bulkPrice.priceType
                dimensionalPriceConfiguration = bulkPrice.dimensionalPriceConfiguration
                additionalProperties = bulkPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bulkConfig(bulkConfig: BulkConfig) = bulkConfig(JsonField.of(bulkConfig))

            /**
             * Sets [Builder.bulkConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.bulkConfig] with a well-typed [BulkConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun bulkConfig(bulkConfig: JsonField<BulkConfig>) = apply {
                this.bulkConfig = bulkConfig
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): BulkPrice =
                BulkPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bulkConfig", bulkConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BulkConfig
        @JsonCreator
        private constructor(
            @JsonProperty("tiers")
            @ExcludeMissing
            private val tiers: JsonField<List<Tier>> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * Bulk tiers for rating based on total usage volume
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun tiers(): List<Tier> = tiers.getRequired("tiers")

            /**
             * Returns the raw JSON value of [tiers].
             *
             * Unlike [tiers], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("tiers") @ExcludeMissing fun _tiers(): JsonField<List<Tier>> = tiers

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BulkConfig = apply {
                if (validated) {
                    return@apply
                }

                tiers().forEach { it.validate() }
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BulkConfig].
                 *
                 * The following fields are required:
                 * ```java
                 * .tiers()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BulkConfig]. */
            class Builder internal constructor() {

                private var tiers: JsonField<MutableList<Tier>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(bulkConfig: BulkConfig) = apply {
                    tiers = bulkConfig.tiers.map { it.toMutableList() }
                    additionalProperties = bulkConfig.additionalProperties.toMutableMap()
                }

                /** Bulk tiers for rating based on total usage volume */
                fun tiers(tiers: List<Tier>) = tiers(JsonField.of(tiers))

                /**
                 * Sets [Builder.tiers] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.tiers] with a well-typed `List<Tier>` value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun tiers(tiers: JsonField<List<Tier>>) = apply {
                    this.tiers = tiers.map { it.toMutableList() }
                }

                /**
                 * Adds a single [Tier] to [tiers].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addTier(tier: Tier) = apply {
                    tiers =
                        (tiers ?: JsonField.of(mutableListOf())).also {
                            checkKnown("tiers", it).add(tier)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BulkConfig =
                    BulkConfig(
                        checkRequired("tiers", tiers).map { it.toImmutable() },
                        additionalProperties.toImmutable(),
                    )
            }

            @NoAutoDetect
            class Tier
            @JsonCreator
            private constructor(
                @JsonProperty("unit_amount")
                @ExcludeMissing
                private val unitAmount: JsonField<String> = JsonMissing.of(),
                @JsonProperty("maximum_units")
                @ExcludeMissing
                private val maximumUnits: JsonField<Double> = JsonMissing.of(),
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /**
                 * Amount per unit
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * Upper bound for this tier
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if
                 *   the server responded with an unexpected value).
                 */
                fun maximumUnits(): Optional<Double> =
                    Optional.ofNullable(maximumUnits.getNullable("maximum_units"))

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                /**
                 * Returns the raw JSON value of [maximumUnits].
                 *
                 * Unlike [maximumUnits], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("maximum_units")
                @ExcludeMissing
                fun _maximumUnits(): JsonField<Double> = maximumUnits

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                private var validated: Boolean = false

                fun validate(): Tier = apply {
                    if (validated) {
                        return@apply
                    }

                    unitAmount()
                    maximumUnits()
                    validated = true
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [Tier].
                     *
                     * The following fields are required:
                     * ```java
                     * .unitAmount()
                     * ```
                     */
                    @JvmStatic fun builder() = Builder()
                }

                /** A builder for [Tier]. */
                class Builder internal constructor() {

                    private var unitAmount: JsonField<String>? = null
                    private var maximumUnits: JsonField<Double> = JsonMissing.of()
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(tier: Tier) = apply {
                        unitAmount = tier.unitAmount
                        maximumUnits = tier.maximumUnits
                        additionalProperties = tier.additionalProperties.toMutableMap()
                    }

                    /** Amount per unit */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    /** Upper bound for this tier */
                    fun maximumUnits(maximumUnits: Double?) =
                        maximumUnits(JsonField.ofNullable(maximumUnits))

                    /**
                     * Alias for [Builder.maximumUnits].
                     *
                     * This unboxed primitive overload exists for backwards compatibility.
                     */
                    fun maximumUnits(maximumUnits: Double) = maximumUnits(maximumUnits as Double?)

                    /**
                     * Alias for calling [Builder.maximumUnits] with `maximumUnits.orElse(null)`.
                     */
                    fun maximumUnits(maximumUnits: Optional<Double>) =
                        maximumUnits(maximumUnits.getOrNull())

                    /**
                     * Sets [Builder.maximumUnits] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.maximumUnits] with a well-typed [Double]
                     * value instead. This method is primarily for setting the field to an
                     * undocumented or not yet supported value.
                     */
                    fun maximumUnits(maximumUnits: JsonField<Double>) = apply {
                        this.maximumUnits = maximumUnits
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): Tier =
                        Tier(
                            checkRequired("unitAmount", unitAmount),
                            maximumUnits,
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is Tier && unitAmount == other.unitAmount && maximumUnits == other.maximumUnits && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(unitAmount, maximumUnits, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "Tier{unitAmount=$unitAmount, maximumUnits=$maximumUnits, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BulkConfig && tiers == other.tiers && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(tiers, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BulkConfig{tiers=$tiers, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK = of("bulk")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BULK
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BULK,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BULK -> Value.BULK
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BULK -> Known.BULK
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BulkPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bulkConfig == other.bulkConfig && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bulkConfig, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BulkPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bulkConfig=$bulkConfig, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class ThresholdTotalAmountPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("threshold_total_amount_config")
        @ExcludeMissing
        private val thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun thresholdTotalAmountConfig(): ThresholdTotalAmountConfig =
            thresholdTotalAmountConfig.getRequired("threshold_total_amount_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [thresholdTotalAmountConfig].
         *
         * Unlike [thresholdTotalAmountConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("threshold_total_amount_config")
        @ExcludeMissing
        fun _thresholdTotalAmountConfig(): JsonField<ThresholdTotalAmountConfig> =
            thresholdTotalAmountConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): ThresholdTotalAmountPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            thresholdTotalAmountConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [ThresholdTotalAmountPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .thresholdTotalAmountConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [ThresholdTotalAmountPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(thresholdTotalAmountPrice: ThresholdTotalAmountPrice) = apply {
                id = thresholdTotalAmountPrice.id
                billableMetric = thresholdTotalAmountPrice.billableMetric
                billingCycleConfiguration = thresholdTotalAmountPrice.billingCycleConfiguration
                cadence = thresholdTotalAmountPrice.cadence
                conversionRate = thresholdTotalAmountPrice.conversionRate
                createdAt = thresholdTotalAmountPrice.createdAt
                creditAllocation = thresholdTotalAmountPrice.creditAllocation
                currency = thresholdTotalAmountPrice.currency
                discount = thresholdTotalAmountPrice.discount
                externalPriceId = thresholdTotalAmountPrice.externalPriceId
                fixedPriceQuantity = thresholdTotalAmountPrice.fixedPriceQuantity
                invoicingCycleConfiguration = thresholdTotalAmountPrice.invoicingCycleConfiguration
                item = thresholdTotalAmountPrice.item
                maximum = thresholdTotalAmountPrice.maximum
                maximumAmount = thresholdTotalAmountPrice.maximumAmount
                metadata = thresholdTotalAmountPrice.metadata
                minimum = thresholdTotalAmountPrice.minimum
                minimumAmount = thresholdTotalAmountPrice.minimumAmount
                modelType = thresholdTotalAmountPrice.modelType
                name = thresholdTotalAmountPrice.name
                planPhaseOrder = thresholdTotalAmountPrice.planPhaseOrder
                priceType = thresholdTotalAmountPrice.priceType
                thresholdTotalAmountConfig = thresholdTotalAmountPrice.thresholdTotalAmountConfig
                dimensionalPriceConfiguration =
                    thresholdTotalAmountPrice.dimensionalPriceConfiguration
                additionalProperties = thresholdTotalAmountPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun thresholdTotalAmountConfig(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) =
                thresholdTotalAmountConfig(JsonField.of(thresholdTotalAmountConfig))

            /**
             * Sets [Builder.thresholdTotalAmountConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.thresholdTotalAmountConfig] with a well-typed
             * [ThresholdTotalAmountConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun thresholdTotalAmountConfig(
                thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>
            ) = apply { this.thresholdTotalAmountConfig = thresholdTotalAmountConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): ThresholdTotalAmountPrice =
                ThresholdTotalAmountPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("thresholdTotalAmountConfig", thresholdTotalAmountConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val THRESHOLD_TOTAL_AMOUNT = of("threshold_total_amount")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                THRESHOLD_TOTAL_AMOUNT
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                THRESHOLD_TOTAL_AMOUNT,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    THRESHOLD_TOTAL_AMOUNT -> Value.THRESHOLD_TOTAL_AMOUNT
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    THRESHOLD_TOTAL_AMOUNT -> Known.THRESHOLD_TOTAL_AMOUNT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class ThresholdTotalAmountConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): ThresholdTotalAmountConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [ThresholdTotalAmountConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [ThresholdTotalAmountConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) = apply {
                    additionalProperties =
                        thresholdTotalAmountConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): ThresholdTotalAmountConfig =
                    ThresholdTotalAmountConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ThresholdTotalAmountConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "ThresholdTotalAmountConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is ThresholdTotalAmountPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && thresholdTotalAmountConfig == other.thresholdTotalAmountConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, thresholdTotalAmountConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "ThresholdTotalAmountPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, thresholdTotalAmountConfig=$thresholdTotalAmountConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_package_config")
        @ExcludeMissing
        private val tieredPackageConfig: JsonField<TieredPackageConfig> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredPackageConfig(): TieredPackageConfig =
            tieredPackageConfig.getRequired("tiered_package_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [tieredPackageConfig].
         *
         * Unlike [tieredPackageConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("tiered_package_config")
        @ExcludeMissing
        fun _tieredPackageConfig(): JsonField<TieredPackageConfig> = tieredPackageConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredPackageConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .tieredPackageConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredPackagePrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredPackageConfig: JsonField<TieredPackageConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredPackagePrice: TieredPackagePrice) = apply {
                id = tieredPackagePrice.id
                billableMetric = tieredPackagePrice.billableMetric
                billingCycleConfiguration = tieredPackagePrice.billingCycleConfiguration
                cadence = tieredPackagePrice.cadence
                conversionRate = tieredPackagePrice.conversionRate
                createdAt = tieredPackagePrice.createdAt
                creditAllocation = tieredPackagePrice.creditAllocation
                currency = tieredPackagePrice.currency
                discount = tieredPackagePrice.discount
                externalPriceId = tieredPackagePrice.externalPriceId
                fixedPriceQuantity = tieredPackagePrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredPackagePrice.invoicingCycleConfiguration
                item = tieredPackagePrice.item
                maximum = tieredPackagePrice.maximum
                maximumAmount = tieredPackagePrice.maximumAmount
                metadata = tieredPackagePrice.metadata
                minimum = tieredPackagePrice.minimum
                minimumAmount = tieredPackagePrice.minimumAmount
                modelType = tieredPackagePrice.modelType
                name = tieredPackagePrice.name
                planPhaseOrder = tieredPackagePrice.planPhaseOrder
                priceType = tieredPackagePrice.priceType
                tieredPackageConfig = tieredPackagePrice.tieredPackageConfig
                dimensionalPriceConfiguration = tieredPackagePrice.dimensionalPriceConfiguration
                additionalProperties = tieredPackagePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredPackageConfig(tieredPackageConfig: TieredPackageConfig) =
                tieredPackageConfig(JsonField.of(tieredPackageConfig))

            /**
             * Sets [Builder.tieredPackageConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredPackageConfig] with a well-typed
             * [TieredPackageConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun tieredPackageConfig(tieredPackageConfig: JsonField<TieredPackageConfig>) = apply {
                this.tieredPackageConfig = tieredPackageConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredPackagePrice =
                TieredPackagePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredPackageConfig", tieredPackageConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_PACKAGE = of("tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_PACKAGE -> Value.TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_PACKAGE -> Known.TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class TieredPackageConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): TieredPackageConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [TieredPackageConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [TieredPackageConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredPackageConfig: TieredPackageConfig) = apply {
                    additionalProperties = tieredPackageConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): TieredPackageConfig =
                    TieredPackageConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredPackageConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredPackageConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredPackagePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredPackageConfig == other.tieredPackageConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredPackageConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredPackagePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredPackageConfig=$tieredPackageConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedTieredPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_tiered_config")
        @ExcludeMissing
        private val groupedTieredConfig: JsonField<GroupedTieredConfig> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedTieredConfig(): GroupedTieredConfig =
            groupedTieredConfig.getRequired("grouped_tiered_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedTieredConfig].
         *
         * Unlike [groupedTieredConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("grouped_tiered_config")
        @ExcludeMissing
        fun _groupedTieredConfig(): JsonField<GroupedTieredConfig> = groupedTieredConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedTieredPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedTieredConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [GroupedTieredPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedTieredConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedTieredPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedTieredConfig: JsonField<GroupedTieredConfig>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedTieredPrice: GroupedTieredPrice) = apply {
                id = groupedTieredPrice.id
                billableMetric = groupedTieredPrice.billableMetric
                billingCycleConfiguration = groupedTieredPrice.billingCycleConfiguration
                cadence = groupedTieredPrice.cadence
                conversionRate = groupedTieredPrice.conversionRate
                createdAt = groupedTieredPrice.createdAt
                creditAllocation = groupedTieredPrice.creditAllocation
                currency = groupedTieredPrice.currency
                discount = groupedTieredPrice.discount
                externalPriceId = groupedTieredPrice.externalPriceId
                fixedPriceQuantity = groupedTieredPrice.fixedPriceQuantity
                groupedTieredConfig = groupedTieredPrice.groupedTieredConfig
                invoicingCycleConfiguration = groupedTieredPrice.invoicingCycleConfiguration
                item = groupedTieredPrice.item
                maximum = groupedTieredPrice.maximum
                maximumAmount = groupedTieredPrice.maximumAmount
                metadata = groupedTieredPrice.metadata
                minimum = groupedTieredPrice.minimum
                minimumAmount = groupedTieredPrice.minimumAmount
                modelType = groupedTieredPrice.modelType
                name = groupedTieredPrice.name
                planPhaseOrder = groupedTieredPrice.planPhaseOrder
                priceType = groupedTieredPrice.priceType
                dimensionalPriceConfiguration = groupedTieredPrice.dimensionalPriceConfiguration
                additionalProperties = groupedTieredPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedTieredConfig(groupedTieredConfig: GroupedTieredConfig) =
                groupedTieredConfig(JsonField.of(groupedTieredConfig))

            /**
             * Sets [Builder.groupedTieredConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedTieredConfig] with a well-typed
             * [GroupedTieredConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun groupedTieredConfig(groupedTieredConfig: JsonField<GroupedTieredConfig>) = apply {
                this.groupedTieredConfig = groupedTieredConfig
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedTieredPrice =
                GroupedTieredPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedTieredConfig", groupedTieredConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class GroupedTieredConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): GroupedTieredConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [GroupedTieredConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [GroupedTieredConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(groupedTieredConfig: GroupedTieredConfig) = apply {
                    additionalProperties = groupedTieredConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): GroupedTieredConfig =
                    GroupedTieredConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedTieredConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedTieredConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_TIERED = of("grouped_tiered")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_TIERED
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_TIERED,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_TIERED -> Value.GROUPED_TIERED
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_TIERED -> Known.GROUPED_TIERED
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedTieredPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedTieredConfig == other.groupedTieredConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedTieredConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedTieredPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedTieredConfig=$groupedTieredConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredWithMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_with_minimum_config")
        @ExcludeMissing
        private val tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredWithMinimumConfig(): TieredWithMinimumConfig =
            tieredWithMinimumConfig.getRequired("tiered_with_minimum_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [tieredWithMinimumConfig].
         *
         * Unlike [tieredWithMinimumConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("tiered_with_minimum_config")
        @ExcludeMissing
        fun _tieredWithMinimumConfig(): JsonField<TieredWithMinimumConfig> = tieredWithMinimumConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredWithMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredWithMinimumConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredWithMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .tieredWithMinimumConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredWithMinimumPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredWithMinimumPrice: TieredWithMinimumPrice) = apply {
                id = tieredWithMinimumPrice.id
                billableMetric = tieredWithMinimumPrice.billableMetric
                billingCycleConfiguration = tieredWithMinimumPrice.billingCycleConfiguration
                cadence = tieredWithMinimumPrice.cadence
                conversionRate = tieredWithMinimumPrice.conversionRate
                createdAt = tieredWithMinimumPrice.createdAt
                creditAllocation = tieredWithMinimumPrice.creditAllocation
                currency = tieredWithMinimumPrice.currency
                discount = tieredWithMinimumPrice.discount
                externalPriceId = tieredWithMinimumPrice.externalPriceId
                fixedPriceQuantity = tieredWithMinimumPrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredWithMinimumPrice.invoicingCycleConfiguration
                item = tieredWithMinimumPrice.item
                maximum = tieredWithMinimumPrice.maximum
                maximumAmount = tieredWithMinimumPrice.maximumAmount
                metadata = tieredWithMinimumPrice.metadata
                minimum = tieredWithMinimumPrice.minimum
                minimumAmount = tieredWithMinimumPrice.minimumAmount
                modelType = tieredWithMinimumPrice.modelType
                name = tieredWithMinimumPrice.name
                planPhaseOrder = tieredWithMinimumPrice.planPhaseOrder
                priceType = tieredWithMinimumPrice.priceType
                tieredWithMinimumConfig = tieredWithMinimumPrice.tieredWithMinimumConfig
                dimensionalPriceConfiguration = tieredWithMinimumPrice.dimensionalPriceConfiguration
                additionalProperties = tieredWithMinimumPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredWithMinimumConfig(tieredWithMinimumConfig: TieredWithMinimumConfig) =
                tieredWithMinimumConfig(JsonField.of(tieredWithMinimumConfig))

            /**
             * Sets [Builder.tieredWithMinimumConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredWithMinimumConfig] with a well-typed
             * [TieredWithMinimumConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun tieredWithMinimumConfig(
                tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>
            ) = apply { this.tieredWithMinimumConfig = tieredWithMinimumConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredWithMinimumPrice =
                TieredWithMinimumPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredWithMinimumConfig", tieredWithMinimumConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_WITH_MINIMUM = of("tiered_with_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_WITH_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_WITH_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_WITH_MINIMUM -> Value.TIERED_WITH_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_WITH_MINIMUM -> Known.TIERED_WITH_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class TieredWithMinimumConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): TieredWithMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [TieredWithMinimumConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [TieredWithMinimumConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredWithMinimumConfig: TieredWithMinimumConfig) = apply {
                    additionalProperties =
                        tieredWithMinimumConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): TieredWithMinimumConfig =
                    TieredWithMinimumConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredWithMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredWithMinimumConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredWithMinimumPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredWithMinimumConfig == other.tieredWithMinimumConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredWithMinimumConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredWithMinimumPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredWithMinimumConfig=$tieredWithMinimumConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredPackageWithMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_package_with_minimum_config")
        @ExcludeMissing
        private val tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredPackageWithMinimumConfig(): TieredPackageWithMinimumConfig =
            tieredPackageWithMinimumConfig.getRequired("tiered_package_with_minimum_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [tieredPackageWithMinimumConfig].
         *
         * Unlike [tieredPackageWithMinimumConfig], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("tiered_package_with_minimum_config")
        @ExcludeMissing
        fun _tieredPackageWithMinimumConfig(): JsonField<TieredPackageWithMinimumConfig> =
            tieredPackageWithMinimumConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredPackageWithMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredPackageWithMinimumConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [TieredPackageWithMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .tieredPackageWithMinimumConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredPackageWithMinimumPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig>? =
                null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredPackageWithMinimumPrice: TieredPackageWithMinimumPrice) =
                apply {
                    id = tieredPackageWithMinimumPrice.id
                    billableMetric = tieredPackageWithMinimumPrice.billableMetric
                    billingCycleConfiguration =
                        tieredPackageWithMinimumPrice.billingCycleConfiguration
                    cadence = tieredPackageWithMinimumPrice.cadence
                    conversionRate = tieredPackageWithMinimumPrice.conversionRate
                    createdAt = tieredPackageWithMinimumPrice.createdAt
                    creditAllocation = tieredPackageWithMinimumPrice.creditAllocation
                    currency = tieredPackageWithMinimumPrice.currency
                    discount = tieredPackageWithMinimumPrice.discount
                    externalPriceId = tieredPackageWithMinimumPrice.externalPriceId
                    fixedPriceQuantity = tieredPackageWithMinimumPrice.fixedPriceQuantity
                    invoicingCycleConfiguration =
                        tieredPackageWithMinimumPrice.invoicingCycleConfiguration
                    item = tieredPackageWithMinimumPrice.item
                    maximum = tieredPackageWithMinimumPrice.maximum
                    maximumAmount = tieredPackageWithMinimumPrice.maximumAmount
                    metadata = tieredPackageWithMinimumPrice.metadata
                    minimum = tieredPackageWithMinimumPrice.minimum
                    minimumAmount = tieredPackageWithMinimumPrice.minimumAmount
                    modelType = tieredPackageWithMinimumPrice.modelType
                    name = tieredPackageWithMinimumPrice.name
                    planPhaseOrder = tieredPackageWithMinimumPrice.planPhaseOrder
                    priceType = tieredPackageWithMinimumPrice.priceType
                    tieredPackageWithMinimumConfig =
                        tieredPackageWithMinimumPrice.tieredPackageWithMinimumConfig
                    dimensionalPriceConfiguration =
                        tieredPackageWithMinimumPrice.dimensionalPriceConfiguration
                    additionalProperties =
                        tieredPackageWithMinimumPrice.additionalProperties.toMutableMap()
                }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredPackageWithMinimumConfig(
                tieredPackageWithMinimumConfig: TieredPackageWithMinimumConfig
            ) = tieredPackageWithMinimumConfig(JsonField.of(tieredPackageWithMinimumConfig))

            /**
             * Sets [Builder.tieredPackageWithMinimumConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredPackageWithMinimumConfig] with a well-typed
             * [TieredPackageWithMinimumConfig] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun tieredPackageWithMinimumConfig(
                tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig>
            ) = apply { this.tieredPackageWithMinimumConfig = tieredPackageWithMinimumConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredPackageWithMinimumPrice =
                TieredPackageWithMinimumPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredPackageWithMinimumConfig", tieredPackageWithMinimumConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_PACKAGE_WITH_MINIMUM = of("tiered_package_with_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_PACKAGE_WITH_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_PACKAGE_WITH_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_PACKAGE_WITH_MINIMUM -> Value.TIERED_PACKAGE_WITH_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_PACKAGE_WITH_MINIMUM -> Known.TIERED_PACKAGE_WITH_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class TieredPackageWithMinimumConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): TieredPackageWithMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [TieredPackageWithMinimumConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [TieredPackageWithMinimumConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredPackageWithMinimumConfig: TieredPackageWithMinimumConfig) =
                    apply {
                        additionalProperties =
                            tieredPackageWithMinimumConfig.additionalProperties.toMutableMap()
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): TieredPackageWithMinimumConfig =
                    TieredPackageWithMinimumConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredPackageWithMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredPackageWithMinimumConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredPackageWithMinimumPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredPackageWithMinimumConfig == other.tieredPackageWithMinimumConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredPackageWithMinimumConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredPackageWithMinimumPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredPackageWithMinimumConfig=$tieredPackageWithMinimumConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class PackageWithAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("package_with_allocation_config")
        @ExcludeMissing
        private val packageWithAllocationConfig: JsonField<PackageWithAllocationConfig> =
            JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun packageWithAllocationConfig(): PackageWithAllocationConfig =
            packageWithAllocationConfig.getRequired("package_with_allocation_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [packageWithAllocationConfig].
         *
         * Unlike [packageWithAllocationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("package_with_allocation_config")
        @ExcludeMissing
        fun _packageWithAllocationConfig(): JsonField<PackageWithAllocationConfig> =
            packageWithAllocationConfig

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): PackageWithAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            packageWithAllocationConfig().validate()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [PackageWithAllocationPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .packageWithAllocationConfig()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [PackageWithAllocationPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(packageWithAllocationPrice: PackageWithAllocationPrice) = apply {
                id = packageWithAllocationPrice.id
                billableMetric = packageWithAllocationPrice.billableMetric
                billingCycleConfiguration = packageWithAllocationPrice.billingCycleConfiguration
                cadence = packageWithAllocationPrice.cadence
                conversionRate = packageWithAllocationPrice.conversionRate
                createdAt = packageWithAllocationPrice.createdAt
                creditAllocation = packageWithAllocationPrice.creditAllocation
                currency = packageWithAllocationPrice.currency
                discount = packageWithAllocationPrice.discount
                externalPriceId = packageWithAllocationPrice.externalPriceId
                fixedPriceQuantity = packageWithAllocationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = packageWithAllocationPrice.invoicingCycleConfiguration
                item = packageWithAllocationPrice.item
                maximum = packageWithAllocationPrice.maximum
                maximumAmount = packageWithAllocationPrice.maximumAmount
                metadata = packageWithAllocationPrice.metadata
                minimum = packageWithAllocationPrice.minimum
                minimumAmount = packageWithAllocationPrice.minimumAmount
                modelType = packageWithAllocationPrice.modelType
                name = packageWithAllocationPrice.name
                packageWithAllocationConfig = packageWithAllocationPrice.packageWithAllocationConfig
                planPhaseOrder = packageWithAllocationPrice.planPhaseOrder
                priceType = packageWithAllocationPrice.priceType
                dimensionalPriceConfiguration =
                    packageWithAllocationPrice.dimensionalPriceConfiguration
                additionalProperties =
                    packageWithAllocationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun packageWithAllocationConfig(
                packageWithAllocationConfig: PackageWithAllocationConfig
            ) = packageWithAllocationConfig(JsonField.of(packageWithAllocationConfig))

            /**
             * Sets [Builder.packageWithAllocationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.packageWithAllocationConfig] with a well-typed
             * [PackageWithAllocationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun packageWithAllocationConfig(
                packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>
            ) = apply { this.packageWithAllocationConfig = packageWithAllocationConfig }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): PackageWithAllocationPrice =
                PackageWithAllocationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("packageWithAllocationConfig", packageWithAllocationConfig),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val PACKAGE_WITH_ALLOCATION = of("package_with_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                PACKAGE_WITH_ALLOCATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                PACKAGE_WITH_ALLOCATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    PACKAGE_WITH_ALLOCATION -> Value.PACKAGE_WITH_ALLOCATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    PACKAGE_WITH_ALLOCATION -> Known.PACKAGE_WITH_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class PackageWithAllocationConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): PackageWithAllocationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [PackageWithAllocationConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [PackageWithAllocationConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(packageWithAllocationConfig: PackageWithAllocationConfig) =
                    apply {
                        additionalProperties =
                            packageWithAllocationConfig.additionalProperties.toMutableMap()
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): PackageWithAllocationConfig =
                    PackageWithAllocationConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PackageWithAllocationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "PackageWithAllocationConfig{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is PackageWithAllocationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && packageWithAllocationConfig == other.packageWithAllocationConfig && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, packageWithAllocationConfig, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "PackageWithAllocationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, packageWithAllocationConfig=$packageWithAllocationConfig, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class UnitWithPercentPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("unit_with_percent_config")
        @ExcludeMissing
        private val unitWithPercentConfig: JsonField<UnitWithPercentConfig> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun unitWithPercentConfig(): UnitWithPercentConfig =
            unitWithPercentConfig.getRequired("unit_with_percent_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [unitWithPercentConfig].
         *
         * Unlike [unitWithPercentConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("unit_with_percent_config")
        @ExcludeMissing
        fun _unitWithPercentConfig(): JsonField<UnitWithPercentConfig> = unitWithPercentConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): UnitWithPercentPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            unitWithPercentConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [UnitWithPercentPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .unitWithPercentConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [UnitWithPercentPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var unitWithPercentConfig: JsonField<UnitWithPercentConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(unitWithPercentPrice: UnitWithPercentPrice) = apply {
                id = unitWithPercentPrice.id
                billableMetric = unitWithPercentPrice.billableMetric
                billingCycleConfiguration = unitWithPercentPrice.billingCycleConfiguration
                cadence = unitWithPercentPrice.cadence
                conversionRate = unitWithPercentPrice.conversionRate
                createdAt = unitWithPercentPrice.createdAt
                creditAllocation = unitWithPercentPrice.creditAllocation
                currency = unitWithPercentPrice.currency
                discount = unitWithPercentPrice.discount
                externalPriceId = unitWithPercentPrice.externalPriceId
                fixedPriceQuantity = unitWithPercentPrice.fixedPriceQuantity
                invoicingCycleConfiguration = unitWithPercentPrice.invoicingCycleConfiguration
                item = unitWithPercentPrice.item
                maximum = unitWithPercentPrice.maximum
                maximumAmount = unitWithPercentPrice.maximumAmount
                metadata = unitWithPercentPrice.metadata
                minimum = unitWithPercentPrice.minimum
                minimumAmount = unitWithPercentPrice.minimumAmount
                modelType = unitWithPercentPrice.modelType
                name = unitWithPercentPrice.name
                planPhaseOrder = unitWithPercentPrice.planPhaseOrder
                priceType = unitWithPercentPrice.priceType
                unitWithPercentConfig = unitWithPercentPrice.unitWithPercentConfig
                dimensionalPriceConfiguration = unitWithPercentPrice.dimensionalPriceConfiguration
                additionalProperties = unitWithPercentPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun unitWithPercentConfig(unitWithPercentConfig: UnitWithPercentConfig) =
                unitWithPercentConfig(JsonField.of(unitWithPercentConfig))

            /**
             * Sets [Builder.unitWithPercentConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.unitWithPercentConfig] with a well-typed
             * [UnitWithPercentConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun unitWithPercentConfig(unitWithPercentConfig: JsonField<UnitWithPercentConfig>) =
                apply {
                    this.unitWithPercentConfig = unitWithPercentConfig
                }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): UnitWithPercentPrice =
                UnitWithPercentPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("unitWithPercentConfig", unitWithPercentConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT_WITH_PERCENT = of("unit_with_percent")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                UNIT_WITH_PERCENT
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                UNIT_WITH_PERCENT,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    UNIT_WITH_PERCENT -> Value.UNIT_WITH_PERCENT
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    UNIT_WITH_PERCENT -> Known.UNIT_WITH_PERCENT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class UnitWithPercentConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): UnitWithPercentConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [UnitWithPercentConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [UnitWithPercentConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(unitWithPercentConfig: UnitWithPercentConfig) = apply {
                    additionalProperties = unitWithPercentConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): UnitWithPercentConfig =
                    UnitWithPercentConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is UnitWithPercentConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "UnitWithPercentConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is UnitWithPercentPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && unitWithPercentConfig == other.unitWithPercentConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, unitWithPercentConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "UnitWithPercentPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, unitWithPercentConfig=$unitWithPercentConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class MatrixWithAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("matrix_with_allocation_config")
        @ExcludeMissing
        private val matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig> =
            JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun matrixWithAllocationConfig(): MatrixWithAllocationConfig =
            matrixWithAllocationConfig.getRequired("matrix_with_allocation_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [matrixWithAllocationConfig].
         *
         * Unlike [matrixWithAllocationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("matrix_with_allocation_config")
        @ExcludeMissing
        fun _matrixWithAllocationConfig(): JsonField<MatrixWithAllocationConfig> =
            matrixWithAllocationConfig

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): MatrixWithAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            matrixWithAllocationConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [MatrixWithAllocationPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixWithAllocationConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [MatrixWithAllocationPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(matrixWithAllocationPrice: MatrixWithAllocationPrice) = apply {
                id = matrixWithAllocationPrice.id
                billableMetric = matrixWithAllocationPrice.billableMetric
                billingCycleConfiguration = matrixWithAllocationPrice.billingCycleConfiguration
                cadence = matrixWithAllocationPrice.cadence
                conversionRate = matrixWithAllocationPrice.conversionRate
                createdAt = matrixWithAllocationPrice.createdAt
                creditAllocation = matrixWithAllocationPrice.creditAllocation
                currency = matrixWithAllocationPrice.currency
                discount = matrixWithAllocationPrice.discount
                externalPriceId = matrixWithAllocationPrice.externalPriceId
                fixedPriceQuantity = matrixWithAllocationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = matrixWithAllocationPrice.invoicingCycleConfiguration
                item = matrixWithAllocationPrice.item
                matrixWithAllocationConfig = matrixWithAllocationPrice.matrixWithAllocationConfig
                maximum = matrixWithAllocationPrice.maximum
                maximumAmount = matrixWithAllocationPrice.maximumAmount
                metadata = matrixWithAllocationPrice.metadata
                minimum = matrixWithAllocationPrice.minimum
                minimumAmount = matrixWithAllocationPrice.minimumAmount
                modelType = matrixWithAllocationPrice.modelType
                name = matrixWithAllocationPrice.name
                planPhaseOrder = matrixWithAllocationPrice.planPhaseOrder
                priceType = matrixWithAllocationPrice.priceType
                dimensionalPriceConfiguration =
                    matrixWithAllocationPrice.dimensionalPriceConfiguration
                additionalProperties = matrixWithAllocationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun matrixWithAllocationConfig(matrixWithAllocationConfig: MatrixWithAllocationConfig) =
                matrixWithAllocationConfig(JsonField.of(matrixWithAllocationConfig))

            /**
             * Sets [Builder.matrixWithAllocationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.matrixWithAllocationConfig] with a well-typed
             * [MatrixWithAllocationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun matrixWithAllocationConfig(
                matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig>
            ) = apply { this.matrixWithAllocationConfig = matrixWithAllocationConfig }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): MatrixWithAllocationPrice =
                MatrixWithAllocationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixWithAllocationConfig", matrixWithAllocationConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class MatrixWithAllocationConfig
        @JsonCreator
        private constructor(
            @JsonProperty("allocation")
            @ExcludeMissing
            private val allocation: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("default_unit_amount")
            @ExcludeMissing
            private val defaultUnitAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensions")
            @ExcludeMissing
            private val dimensions: JsonField<List<String?>> = JsonMissing.of(),
            @JsonProperty("matrix_values")
            @ExcludeMissing
            private val matrixValues: JsonField<List<MatrixValue>> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * Allocation to be used to calculate the price
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allocation(): Double = allocation.getRequired("allocation")

            /**
             * Default per unit rate for any usage not bucketed into a specified matrix_value
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun defaultUnitAmount(): String = defaultUnitAmount.getRequired("default_unit_amount")

            /**
             * One or two event property values to evaluate matrix groups by
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensions(): List<String?> = dimensions.getRequired("dimensions")

            /**
             * Matrix values for specified matrix grouping keys
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun matrixValues(): List<MatrixValue> = matrixValues.getRequired("matrix_values")

            /**
             * Returns the raw JSON value of [allocation].
             *
             * Unlike [allocation], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("allocation")
            @ExcludeMissing
            fun _allocation(): JsonField<Double> = allocation

            /**
             * Returns the raw JSON value of [defaultUnitAmount].
             *
             * Unlike [defaultUnitAmount], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("default_unit_amount")
            @ExcludeMissing
            fun _defaultUnitAmount(): JsonField<String> = defaultUnitAmount

            /**
             * Returns the raw JSON value of [dimensions].
             *
             * Unlike [dimensions], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("dimensions")
            @ExcludeMissing
            fun _dimensions(): JsonField<List<String?>> = dimensions

            /**
             * Returns the raw JSON value of [matrixValues].
             *
             * Unlike [matrixValues], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("matrix_values")
            @ExcludeMissing
            fun _matrixValues(): JsonField<List<MatrixValue>> = matrixValues

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): MatrixWithAllocationConfig = apply {
                if (validated) {
                    return@apply
                }

                allocation()
                defaultUnitAmount()
                dimensions()
                matrixValues().forEach { it.validate() }
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [MatrixWithAllocationConfig].
                 *
                 * The following fields are required:
                 * ```java
                 * .allocation()
                 * .defaultUnitAmount()
                 * .dimensions()
                 * .matrixValues()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [MatrixWithAllocationConfig]. */
            class Builder internal constructor() {

                private var allocation: JsonField<Double>? = null
                private var defaultUnitAmount: JsonField<String>? = null
                private var dimensions: JsonField<MutableList<String?>>? = null
                private var matrixValues: JsonField<MutableList<MatrixValue>>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(matrixWithAllocationConfig: MatrixWithAllocationConfig) = apply {
                    allocation = matrixWithAllocationConfig.allocation
                    defaultUnitAmount = matrixWithAllocationConfig.defaultUnitAmount
                    dimensions = matrixWithAllocationConfig.dimensions.map { it.toMutableList() }
                    matrixValues =
                        matrixWithAllocationConfig.matrixValues.map { it.toMutableList() }
                    additionalProperties =
                        matrixWithAllocationConfig.additionalProperties.toMutableMap()
                }

                /** Allocation to be used to calculate the price */
                fun allocation(allocation: Double) = allocation(JsonField.of(allocation))

                /**
                 * Sets [Builder.allocation] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allocation] with a well-typed [Double] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun allocation(allocation: JsonField<Double>) = apply {
                    this.allocation = allocation
                }

                /**
                 * Default per unit rate for any usage not bucketed into a specified matrix_value
                 */
                fun defaultUnitAmount(defaultUnitAmount: String) =
                    defaultUnitAmount(JsonField.of(defaultUnitAmount))

                /**
                 * Sets [Builder.defaultUnitAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.defaultUnitAmount] with a well-typed [String]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun defaultUnitAmount(defaultUnitAmount: JsonField<String>) = apply {
                    this.defaultUnitAmount = defaultUnitAmount
                }

                /** One or two event property values to evaluate matrix groups by */
                fun dimensions(dimensions: List<String?>) = dimensions(JsonField.of(dimensions))

                /**
                 * Sets [Builder.dimensions] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensions] with a well-typed `List<String?>`
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun dimensions(dimensions: JsonField<List<String?>>) = apply {
                    this.dimensions = dimensions.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensions].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimension(dimension: String) = apply {
                    dimensions =
                        (dimensions ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensions", it).add(dimension)
                        }
                }

                /** Matrix values for specified matrix grouping keys */
                fun matrixValues(matrixValues: List<MatrixValue>) =
                    matrixValues(JsonField.of(matrixValues))

                /**
                 * Sets [Builder.matrixValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.matrixValues] with a well-typed
                 * `List<MatrixValue>` value instead. This method is primarily for setting the field
                 * to an undocumented or not yet supported value.
                 */
                fun matrixValues(matrixValues: JsonField<List<MatrixValue>>) = apply {
                    this.matrixValues = matrixValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [MatrixValue] to [matrixValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addMatrixValue(matrixValue: MatrixValue) = apply {
                    matrixValues =
                        (matrixValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("matrixValues", it).add(matrixValue)
                        }
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): MatrixWithAllocationConfig =
                    MatrixWithAllocationConfig(
                        checkRequired("allocation", allocation),
                        checkRequired("defaultUnitAmount", defaultUnitAmount),
                        checkRequired("dimensions", dimensions).map { it.toImmutable() },
                        checkRequired("matrixValues", matrixValues).map { it.toImmutable() },
                        additionalProperties.toImmutable(),
                    )
            }

            @NoAutoDetect
            class MatrixValue
            @JsonCreator
            private constructor(
                @JsonProperty("dimension_values")
                @ExcludeMissing
                private val dimensionValues: JsonField<List<String?>> = JsonMissing.of(),
                @JsonProperty("unit_amount")
                @ExcludeMissing
                private val unitAmount: JsonField<String> = JsonMissing.of(),
                @JsonAnySetter
                private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
            ) {

                /**
                 * One or two matrix keys to filter usage to this Matrix value by. For example,
                 * ["region", "tier"] could be used to filter cloud usage by a cloud region and an
                 * instance tier.
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun dimensionValues(): List<String?> =
                    dimensionValues.getRequired("dimension_values")

                /**
                 * Unit price for the specified dimension_values
                 *
                 * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
                 *   unexpectedly missing or null (e.g. if the server responded with an unexpected
                 *   value).
                 */
                fun unitAmount(): String = unitAmount.getRequired("unit_amount")

                /**
                 * Returns the raw JSON value of [dimensionValues].
                 *
                 * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("dimension_values")
                @ExcludeMissing
                fun _dimensionValues(): JsonField<List<String?>> = dimensionValues

                /**
                 * Returns the raw JSON value of [unitAmount].
                 *
                 * Unlike [unitAmount], this method doesn't throw if the JSON field has an
                 * unexpected type.
                 */
                @JsonProperty("unit_amount")
                @ExcludeMissing
                fun _unitAmount(): JsonField<String> = unitAmount

                @JsonAnyGetter
                @ExcludeMissing
                fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

                private var validated: Boolean = false

                fun validate(): MatrixValue = apply {
                    if (validated) {
                        return@apply
                    }

                    dimensionValues()
                    unitAmount()
                    validated = true
                }

                fun toBuilder() = Builder().from(this)

                companion object {

                    /**
                     * Returns a mutable builder for constructing an instance of [MatrixValue].
                     *
                     * The following fields are required:
                     * ```java
                     * .dimensionValues()
                     * .unitAmount()
                     * ```
                     */
                    @JvmStatic fun builder() = Builder()
                }

                /** A builder for [MatrixValue]. */
                class Builder internal constructor() {

                    private var dimensionValues: JsonField<MutableList<String?>>? = null
                    private var unitAmount: JsonField<String>? = null
                    private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                    @JvmSynthetic
                    internal fun from(matrixValue: MatrixValue) = apply {
                        dimensionValues = matrixValue.dimensionValues.map { it.toMutableList() }
                        unitAmount = matrixValue.unitAmount
                        additionalProperties = matrixValue.additionalProperties.toMutableMap()
                    }

                    /**
                     * One or two matrix keys to filter usage to this Matrix value by. For example,
                     * ["region", "tier"] could be used to filter cloud usage by a cloud region and
                     * an instance tier.
                     */
                    fun dimensionValues(dimensionValues: List<String?>) =
                        dimensionValues(JsonField.of(dimensionValues))

                    /**
                     * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.dimensionValues] with a well-typed
                     * `List<String?>` value instead. This method is primarily for setting the field
                     * to an undocumented or not yet supported value.
                     */
                    fun dimensionValues(dimensionValues: JsonField<List<String?>>) = apply {
                        this.dimensionValues = dimensionValues.map { it.toMutableList() }
                    }

                    /**
                     * Adds a single [String] to [dimensionValues].
                     *
                     * @throws IllegalStateException if the field was previously set to a non-list.
                     */
                    fun addDimensionValue(dimensionValue: String) = apply {
                        dimensionValues =
                            (dimensionValues ?: JsonField.of(mutableListOf())).also {
                                checkKnown("dimensionValues", it).add(dimensionValue)
                            }
                    }

                    /** Unit price for the specified dimension_values */
                    fun unitAmount(unitAmount: String) = unitAmount(JsonField.of(unitAmount))

                    /**
                     * Sets [Builder.unitAmount] to an arbitrary JSON value.
                     *
                     * You should usually call [Builder.unitAmount] with a well-typed [String] value
                     * instead. This method is primarily for setting the field to an undocumented or
                     * not yet supported value.
                     */
                    fun unitAmount(unitAmount: JsonField<String>) = apply {
                        this.unitAmount = unitAmount
                    }

                    fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                        this.additionalProperties.clear()
                        putAllAdditionalProperties(additionalProperties)
                    }

                    fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                        additionalProperties.put(key, value)
                    }

                    fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                        apply {
                            this.additionalProperties.putAll(additionalProperties)
                        }

                    fun removeAdditionalProperty(key: String) = apply {
                        additionalProperties.remove(key)
                    }

                    fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                        keys.forEach(::removeAdditionalProperty)
                    }

                    fun build(): MatrixValue =
                        MatrixValue(
                            checkRequired("dimensionValues", dimensionValues).map {
                                it.toImmutable()
                            },
                            checkRequired("unitAmount", unitAmount),
                            additionalProperties.toImmutable(),
                        )
                }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is MatrixValue && dimensionValues == other.dimensionValues && unitAmount == other.unitAmount && additionalProperties == other.additionalProperties /* spotless:on */
                }

                /* spotless:off */
                private val hashCode: Int by lazy { Objects.hash(dimensionValues, unitAmount, additionalProperties) }
                /* spotless:on */

                override fun hashCode(): Int = hashCode

                override fun toString() =
                    "MatrixValue{dimensionValues=$dimensionValues, unitAmount=$unitAmount, additionalProperties=$additionalProperties}"
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is MatrixWithAllocationConfig && allocation == other.allocation && defaultUnitAmount == other.defaultUnitAmount && dimensions == other.dimensions && matrixValues == other.matrixValues && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allocation, defaultUnitAmount, dimensions, matrixValues, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "MatrixWithAllocationConfig{allocation=$allocation, defaultUnitAmount=$defaultUnitAmount, dimensions=$dimensions, matrixValues=$matrixValues, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX_WITH_ALLOCATION = of("matrix_with_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MATRIX_WITH_ALLOCATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MATRIX_WITH_ALLOCATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MATRIX_WITH_ALLOCATION -> Value.MATRIX_WITH_ALLOCATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MATRIX_WITH_ALLOCATION -> Known.MATRIX_WITH_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MatrixWithAllocationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && matrixWithAllocationConfig == other.matrixWithAllocationConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, matrixWithAllocationConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MatrixWithAllocationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixWithAllocationConfig=$matrixWithAllocationConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_with_proration_config")
        @ExcludeMissing
        private val tieredWithProrationConfig: JsonField<TieredWithProrationConfig> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredWithProrationConfig(): TieredWithProrationConfig =
            tieredWithProrationConfig.getRequired("tiered_with_proration_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [tieredWithProrationConfig].
         *
         * Unlike [tieredWithProrationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("tiered_with_proration_config")
        @ExcludeMissing
        fun _tieredWithProrationConfig(): JsonField<TieredWithProrationConfig> =
            tieredWithProrationConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredWithProrationConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredWithProrationPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .tieredWithProrationConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredWithProrationPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredWithProrationConfig: JsonField<TieredWithProrationConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredWithProrationPrice: TieredWithProrationPrice) = apply {
                id = tieredWithProrationPrice.id
                billableMetric = tieredWithProrationPrice.billableMetric
                billingCycleConfiguration = tieredWithProrationPrice.billingCycleConfiguration
                cadence = tieredWithProrationPrice.cadence
                conversionRate = tieredWithProrationPrice.conversionRate
                createdAt = tieredWithProrationPrice.createdAt
                creditAllocation = tieredWithProrationPrice.creditAllocation
                currency = tieredWithProrationPrice.currency
                discount = tieredWithProrationPrice.discount
                externalPriceId = tieredWithProrationPrice.externalPriceId
                fixedPriceQuantity = tieredWithProrationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredWithProrationPrice.invoicingCycleConfiguration
                item = tieredWithProrationPrice.item
                maximum = tieredWithProrationPrice.maximum
                maximumAmount = tieredWithProrationPrice.maximumAmount
                metadata = tieredWithProrationPrice.metadata
                minimum = tieredWithProrationPrice.minimum
                minimumAmount = tieredWithProrationPrice.minimumAmount
                modelType = tieredWithProrationPrice.modelType
                name = tieredWithProrationPrice.name
                planPhaseOrder = tieredWithProrationPrice.planPhaseOrder
                priceType = tieredWithProrationPrice.priceType
                tieredWithProrationConfig = tieredWithProrationPrice.tieredWithProrationConfig
                dimensionalPriceConfiguration =
                    tieredWithProrationPrice.dimensionalPriceConfiguration
                additionalProperties = tieredWithProrationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredWithProrationConfig(tieredWithProrationConfig: TieredWithProrationConfig) =
                tieredWithProrationConfig(JsonField.of(tieredWithProrationConfig))

            /**
             * Sets [Builder.tieredWithProrationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredWithProrationConfig] with a well-typed
             * [TieredWithProrationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun tieredWithProrationConfig(
                tieredWithProrationConfig: JsonField<TieredWithProrationConfig>
            ) = apply { this.tieredWithProrationConfig = tieredWithProrationConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredWithProrationPrice =
                TieredWithProrationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredWithProrationConfig", tieredWithProrationConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_WITH_PRORATION = of("tiered_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_WITH_PRORATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_WITH_PRORATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_WITH_PRORATION -> Value.TIERED_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_WITH_PRORATION -> Known.TIERED_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class TieredWithProrationConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): TieredWithProrationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [TieredWithProrationConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [TieredWithProrationConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredWithProrationConfig: TieredWithProrationConfig) = apply {
                    additionalProperties =
                        tieredWithProrationConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): TieredWithProrationConfig =
                    TieredWithProrationConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredWithProrationConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredWithProrationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredWithProrationConfig == other.tieredWithProrationConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredWithProrationConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredWithProrationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredWithProrationConfig=$tieredWithProrationConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class UnitWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("unit_with_proration_config")
        @ExcludeMissing
        private val unitWithProrationConfig: JsonField<UnitWithProrationConfig> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun unitWithProrationConfig(): UnitWithProrationConfig =
            unitWithProrationConfig.getRequired("unit_with_proration_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [unitWithProrationConfig].
         *
         * Unlike [unitWithProrationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("unit_with_proration_config")
        @ExcludeMissing
        fun _unitWithProrationConfig(): JsonField<UnitWithProrationConfig> = unitWithProrationConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): UnitWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            unitWithProrationConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [UnitWithProrationPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .unitWithProrationConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [UnitWithProrationPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var unitWithProrationConfig: JsonField<UnitWithProrationConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(unitWithProrationPrice: UnitWithProrationPrice) = apply {
                id = unitWithProrationPrice.id
                billableMetric = unitWithProrationPrice.billableMetric
                billingCycleConfiguration = unitWithProrationPrice.billingCycleConfiguration
                cadence = unitWithProrationPrice.cadence
                conversionRate = unitWithProrationPrice.conversionRate
                createdAt = unitWithProrationPrice.createdAt
                creditAllocation = unitWithProrationPrice.creditAllocation
                currency = unitWithProrationPrice.currency
                discount = unitWithProrationPrice.discount
                externalPriceId = unitWithProrationPrice.externalPriceId
                fixedPriceQuantity = unitWithProrationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = unitWithProrationPrice.invoicingCycleConfiguration
                item = unitWithProrationPrice.item
                maximum = unitWithProrationPrice.maximum
                maximumAmount = unitWithProrationPrice.maximumAmount
                metadata = unitWithProrationPrice.metadata
                minimum = unitWithProrationPrice.minimum
                minimumAmount = unitWithProrationPrice.minimumAmount
                modelType = unitWithProrationPrice.modelType
                name = unitWithProrationPrice.name
                planPhaseOrder = unitWithProrationPrice.planPhaseOrder
                priceType = unitWithProrationPrice.priceType
                unitWithProrationConfig = unitWithProrationPrice.unitWithProrationConfig
                dimensionalPriceConfiguration = unitWithProrationPrice.dimensionalPriceConfiguration
                additionalProperties = unitWithProrationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun unitWithProrationConfig(unitWithProrationConfig: UnitWithProrationConfig) =
                unitWithProrationConfig(JsonField.of(unitWithProrationConfig))

            /**
             * Sets [Builder.unitWithProrationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.unitWithProrationConfig] with a well-typed
             * [UnitWithProrationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun unitWithProrationConfig(
                unitWithProrationConfig: JsonField<UnitWithProrationConfig>
            ) = apply { this.unitWithProrationConfig = unitWithProrationConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): UnitWithProrationPrice =
                UnitWithProrationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("unitWithProrationConfig", unitWithProrationConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT_WITH_PRORATION = of("unit_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                UNIT_WITH_PRORATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                UNIT_WITH_PRORATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    UNIT_WITH_PRORATION -> Value.UNIT_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    UNIT_WITH_PRORATION -> Known.UNIT_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class UnitWithProrationConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): UnitWithProrationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [UnitWithProrationConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [UnitWithProrationConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(unitWithProrationConfig: UnitWithProrationConfig) = apply {
                    additionalProperties =
                        unitWithProrationConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): UnitWithProrationConfig =
                    UnitWithProrationConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is UnitWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "UnitWithProrationConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is UnitWithProrationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && unitWithProrationConfig == other.unitWithProrationConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, unitWithProrationConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "UnitWithProrationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, unitWithProrationConfig=$unitWithProrationConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_allocation_config")
        @ExcludeMissing
        private val groupedAllocationConfig: JsonField<GroupedAllocationConfig> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedAllocationConfig(): GroupedAllocationConfig =
            groupedAllocationConfig.getRequired("grouped_allocation_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedAllocationConfig].
         *
         * Unlike [groupedAllocationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("grouped_allocation_config")
        @ExcludeMissing
        fun _groupedAllocationConfig(): JsonField<GroupedAllocationConfig> = groupedAllocationConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedAllocationConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [GroupedAllocationPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedAllocationConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedAllocationPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedAllocationConfig: JsonField<GroupedAllocationConfig>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedAllocationPrice: GroupedAllocationPrice) = apply {
                id = groupedAllocationPrice.id
                billableMetric = groupedAllocationPrice.billableMetric
                billingCycleConfiguration = groupedAllocationPrice.billingCycleConfiguration
                cadence = groupedAllocationPrice.cadence
                conversionRate = groupedAllocationPrice.conversionRate
                createdAt = groupedAllocationPrice.createdAt
                creditAllocation = groupedAllocationPrice.creditAllocation
                currency = groupedAllocationPrice.currency
                discount = groupedAllocationPrice.discount
                externalPriceId = groupedAllocationPrice.externalPriceId
                fixedPriceQuantity = groupedAllocationPrice.fixedPriceQuantity
                groupedAllocationConfig = groupedAllocationPrice.groupedAllocationConfig
                invoicingCycleConfiguration = groupedAllocationPrice.invoicingCycleConfiguration
                item = groupedAllocationPrice.item
                maximum = groupedAllocationPrice.maximum
                maximumAmount = groupedAllocationPrice.maximumAmount
                metadata = groupedAllocationPrice.metadata
                minimum = groupedAllocationPrice.minimum
                minimumAmount = groupedAllocationPrice.minimumAmount
                modelType = groupedAllocationPrice.modelType
                name = groupedAllocationPrice.name
                planPhaseOrder = groupedAllocationPrice.planPhaseOrder
                priceType = groupedAllocationPrice.priceType
                dimensionalPriceConfiguration = groupedAllocationPrice.dimensionalPriceConfiguration
                additionalProperties = groupedAllocationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedAllocationConfig(groupedAllocationConfig: GroupedAllocationConfig) =
                groupedAllocationConfig(JsonField.of(groupedAllocationConfig))

            /**
             * Sets [Builder.groupedAllocationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedAllocationConfig] with a well-typed
             * [GroupedAllocationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun groupedAllocationConfig(
                groupedAllocationConfig: JsonField<GroupedAllocationConfig>
            ) = apply { this.groupedAllocationConfig = groupedAllocationConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedAllocationPrice =
                GroupedAllocationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedAllocationConfig", groupedAllocationConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class GroupedAllocationConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): GroupedAllocationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedAllocationConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [GroupedAllocationConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(groupedAllocationConfig: GroupedAllocationConfig) = apply {
                    additionalProperties =
                        groupedAllocationConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): GroupedAllocationConfig =
                    GroupedAllocationConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedAllocationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedAllocationConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_ALLOCATION = of("grouped_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_ALLOCATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_ALLOCATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_ALLOCATION -> Value.GROUPED_ALLOCATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_ALLOCATION -> Known.GROUPED_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedAllocationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedAllocationConfig == other.groupedAllocationConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedAllocationConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedAllocationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedAllocationConfig=$groupedAllocationConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedWithProratedMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_with_prorated_minimum_config")
        @ExcludeMissing
        private val groupedWithProratedMinimumConfig: JsonField<GroupedWithProratedMinimumConfig> =
            JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedWithProratedMinimumConfig(): GroupedWithProratedMinimumConfig =
            groupedWithProratedMinimumConfig.getRequired("grouped_with_prorated_minimum_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedWithProratedMinimumConfig].
         *
         * Unlike [groupedWithProratedMinimumConfig], this method doesn't throw if the JSON field
         * has an unexpected type.
         */
        @JsonProperty("grouped_with_prorated_minimum_config")
        @ExcludeMissing
        fun _groupedWithProratedMinimumConfig(): JsonField<GroupedWithProratedMinimumConfig> =
            groupedWithProratedMinimumConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedWithProratedMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedWithProratedMinimumConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [GroupedWithProratedMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithProratedMinimumConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedWithProratedMinimumPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedWithProratedMinimumConfig:
                JsonField<GroupedWithProratedMinimumConfig>? =
                null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedWithProratedMinimumPrice: GroupedWithProratedMinimumPrice) =
                apply {
                    id = groupedWithProratedMinimumPrice.id
                    billableMetric = groupedWithProratedMinimumPrice.billableMetric
                    billingCycleConfiguration =
                        groupedWithProratedMinimumPrice.billingCycleConfiguration
                    cadence = groupedWithProratedMinimumPrice.cadence
                    conversionRate = groupedWithProratedMinimumPrice.conversionRate
                    createdAt = groupedWithProratedMinimumPrice.createdAt
                    creditAllocation = groupedWithProratedMinimumPrice.creditAllocation
                    currency = groupedWithProratedMinimumPrice.currency
                    discount = groupedWithProratedMinimumPrice.discount
                    externalPriceId = groupedWithProratedMinimumPrice.externalPriceId
                    fixedPriceQuantity = groupedWithProratedMinimumPrice.fixedPriceQuantity
                    groupedWithProratedMinimumConfig =
                        groupedWithProratedMinimumPrice.groupedWithProratedMinimumConfig
                    invoicingCycleConfiguration =
                        groupedWithProratedMinimumPrice.invoicingCycleConfiguration
                    item = groupedWithProratedMinimumPrice.item
                    maximum = groupedWithProratedMinimumPrice.maximum
                    maximumAmount = groupedWithProratedMinimumPrice.maximumAmount
                    metadata = groupedWithProratedMinimumPrice.metadata
                    minimum = groupedWithProratedMinimumPrice.minimum
                    minimumAmount = groupedWithProratedMinimumPrice.minimumAmount
                    modelType = groupedWithProratedMinimumPrice.modelType
                    name = groupedWithProratedMinimumPrice.name
                    planPhaseOrder = groupedWithProratedMinimumPrice.planPhaseOrder
                    priceType = groupedWithProratedMinimumPrice.priceType
                    dimensionalPriceConfiguration =
                        groupedWithProratedMinimumPrice.dimensionalPriceConfiguration
                    additionalProperties =
                        groupedWithProratedMinimumPrice.additionalProperties.toMutableMap()
                }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
            ) = groupedWithProratedMinimumConfig(JsonField.of(groupedWithProratedMinimumConfig))

            /**
             * Sets [Builder.groupedWithProratedMinimumConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedWithProratedMinimumConfig] with a well-typed
             * [GroupedWithProratedMinimumConfig] value instead. This method is primarily for
             * setting the field to an undocumented or not yet supported value.
             */
            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: JsonField<GroupedWithProratedMinimumConfig>
            ) = apply { this.groupedWithProratedMinimumConfig = groupedWithProratedMinimumConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedWithProratedMinimumPrice =
                GroupedWithProratedMinimumPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired(
                        "groupedWithProratedMinimumConfig",
                        groupedWithProratedMinimumConfig,
                    ),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class GroupedWithProratedMinimumConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): GroupedWithProratedMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedWithProratedMinimumConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [GroupedWithProratedMinimumConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                ) = apply {
                    additionalProperties =
                        groupedWithProratedMinimumConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): GroupedWithProratedMinimumConfig =
                    GroupedWithProratedMinimumConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedWithProratedMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedWithProratedMinimumConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_WITH_PRORATED_MINIMUM = of("grouped_with_prorated_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_WITH_PRORATED_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_WITH_PRORATED_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_WITH_PRORATED_MINIMUM -> Value.GROUPED_WITH_PRORATED_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_WITH_PRORATED_MINIMUM -> Known.GROUPED_WITH_PRORATED_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedWithProratedMinimumPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedWithProratedMinimumConfig == other.groupedWithProratedMinimumConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedWithProratedMinimumConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedWithProratedMinimumPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedWithProratedMinimumConfig=$groupedWithProratedMinimumConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedWithMeteredMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_with_metered_minimum_config")
        @ExcludeMissing
        private val groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig> =
            JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedWithMeteredMinimumConfig(): GroupedWithMeteredMinimumConfig =
            groupedWithMeteredMinimumConfig.getRequired("grouped_with_metered_minimum_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedWithMeteredMinimumConfig].
         *
         * Unlike [groupedWithMeteredMinimumConfig], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("grouped_with_metered_minimum_config")
        @ExcludeMissing
        fun _groupedWithMeteredMinimumConfig(): JsonField<GroupedWithMeteredMinimumConfig> =
            groupedWithMeteredMinimumConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedWithMeteredMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedWithMeteredMinimumConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [GroupedWithMeteredMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithMeteredMinimumConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedWithMeteredMinimumPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedWithMeteredMinimumConfig:
                JsonField<GroupedWithMeteredMinimumConfig>? =
                null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedWithMeteredMinimumPrice: GroupedWithMeteredMinimumPrice) =
                apply {
                    id = groupedWithMeteredMinimumPrice.id
                    billableMetric = groupedWithMeteredMinimumPrice.billableMetric
                    billingCycleConfiguration =
                        groupedWithMeteredMinimumPrice.billingCycleConfiguration
                    cadence = groupedWithMeteredMinimumPrice.cadence
                    conversionRate = groupedWithMeteredMinimumPrice.conversionRate
                    createdAt = groupedWithMeteredMinimumPrice.createdAt
                    creditAllocation = groupedWithMeteredMinimumPrice.creditAllocation
                    currency = groupedWithMeteredMinimumPrice.currency
                    discount = groupedWithMeteredMinimumPrice.discount
                    externalPriceId = groupedWithMeteredMinimumPrice.externalPriceId
                    fixedPriceQuantity = groupedWithMeteredMinimumPrice.fixedPriceQuantity
                    groupedWithMeteredMinimumConfig =
                        groupedWithMeteredMinimumPrice.groupedWithMeteredMinimumConfig
                    invoicingCycleConfiguration =
                        groupedWithMeteredMinimumPrice.invoicingCycleConfiguration
                    item = groupedWithMeteredMinimumPrice.item
                    maximum = groupedWithMeteredMinimumPrice.maximum
                    maximumAmount = groupedWithMeteredMinimumPrice.maximumAmount
                    metadata = groupedWithMeteredMinimumPrice.metadata
                    minimum = groupedWithMeteredMinimumPrice.minimum
                    minimumAmount = groupedWithMeteredMinimumPrice.minimumAmount
                    modelType = groupedWithMeteredMinimumPrice.modelType
                    name = groupedWithMeteredMinimumPrice.name
                    planPhaseOrder = groupedWithMeteredMinimumPrice.planPhaseOrder
                    priceType = groupedWithMeteredMinimumPrice.priceType
                    dimensionalPriceConfiguration =
                        groupedWithMeteredMinimumPrice.dimensionalPriceConfiguration
                    additionalProperties =
                        groupedWithMeteredMinimumPrice.additionalProperties.toMutableMap()
                }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
            ) = groupedWithMeteredMinimumConfig(JsonField.of(groupedWithMeteredMinimumConfig))

            /**
             * Sets [Builder.groupedWithMeteredMinimumConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedWithMeteredMinimumConfig] with a well-typed
             * [GroupedWithMeteredMinimumConfig] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig>
            ) = apply { this.groupedWithMeteredMinimumConfig = groupedWithMeteredMinimumConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedWithMeteredMinimumPrice =
                GroupedWithMeteredMinimumPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired(
                        "groupedWithMeteredMinimumConfig",
                        groupedWithMeteredMinimumConfig,
                    ),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class GroupedWithMeteredMinimumConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): GroupedWithMeteredMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedWithMeteredMinimumConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [GroupedWithMeteredMinimumConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
                ) = apply {
                    additionalProperties =
                        groupedWithMeteredMinimumConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): GroupedWithMeteredMinimumConfig =
                    GroupedWithMeteredMinimumConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedWithMeteredMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedWithMeteredMinimumConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_WITH_METERED_MINIMUM = of("grouped_with_metered_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_WITH_METERED_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_WITH_METERED_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_WITH_METERED_MINIMUM -> Value.GROUPED_WITH_METERED_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_WITH_METERED_MINIMUM -> Known.GROUPED_WITH_METERED_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedWithMeteredMinimumPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedWithMeteredMinimumConfig == other.groupedWithMeteredMinimumConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedWithMeteredMinimumConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedWithMeteredMinimumPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedWithMeteredMinimumConfig=$groupedWithMeteredMinimumConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class MatrixWithDisplayNamePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("matrix_with_display_name_config")
        @ExcludeMissing
        private val matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig> =
            JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun matrixWithDisplayNameConfig(): MatrixWithDisplayNameConfig =
            matrixWithDisplayNameConfig.getRequired("matrix_with_display_name_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [matrixWithDisplayNameConfig].
         *
         * Unlike [matrixWithDisplayNameConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("matrix_with_display_name_config")
        @ExcludeMissing
        fun _matrixWithDisplayNameConfig(): JsonField<MatrixWithDisplayNameConfig> =
            matrixWithDisplayNameConfig

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): MatrixWithDisplayNamePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            matrixWithDisplayNameConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [MatrixWithDisplayNamePrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixWithDisplayNameConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [MatrixWithDisplayNamePrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(matrixWithDisplayNamePrice: MatrixWithDisplayNamePrice) = apply {
                id = matrixWithDisplayNamePrice.id
                billableMetric = matrixWithDisplayNamePrice.billableMetric
                billingCycleConfiguration = matrixWithDisplayNamePrice.billingCycleConfiguration
                cadence = matrixWithDisplayNamePrice.cadence
                conversionRate = matrixWithDisplayNamePrice.conversionRate
                createdAt = matrixWithDisplayNamePrice.createdAt
                creditAllocation = matrixWithDisplayNamePrice.creditAllocation
                currency = matrixWithDisplayNamePrice.currency
                discount = matrixWithDisplayNamePrice.discount
                externalPriceId = matrixWithDisplayNamePrice.externalPriceId
                fixedPriceQuantity = matrixWithDisplayNamePrice.fixedPriceQuantity
                invoicingCycleConfiguration = matrixWithDisplayNamePrice.invoicingCycleConfiguration
                item = matrixWithDisplayNamePrice.item
                matrixWithDisplayNameConfig = matrixWithDisplayNamePrice.matrixWithDisplayNameConfig
                maximum = matrixWithDisplayNamePrice.maximum
                maximumAmount = matrixWithDisplayNamePrice.maximumAmount
                metadata = matrixWithDisplayNamePrice.metadata
                minimum = matrixWithDisplayNamePrice.minimum
                minimumAmount = matrixWithDisplayNamePrice.minimumAmount
                modelType = matrixWithDisplayNamePrice.modelType
                name = matrixWithDisplayNamePrice.name
                planPhaseOrder = matrixWithDisplayNamePrice.planPhaseOrder
                priceType = matrixWithDisplayNamePrice.priceType
                dimensionalPriceConfiguration =
                    matrixWithDisplayNamePrice.dimensionalPriceConfiguration
                additionalProperties =
                    matrixWithDisplayNamePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig
            ) = matrixWithDisplayNameConfig(JsonField.of(matrixWithDisplayNameConfig))

            /**
             * Sets [Builder.matrixWithDisplayNameConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.matrixWithDisplayNameConfig] with a well-typed
             * [MatrixWithDisplayNameConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig>
            ) = apply { this.matrixWithDisplayNameConfig = matrixWithDisplayNameConfig }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): MatrixWithDisplayNamePrice =
                MatrixWithDisplayNamePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixWithDisplayNameConfig", matrixWithDisplayNameConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class MatrixWithDisplayNameConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): MatrixWithDisplayNameConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [MatrixWithDisplayNameConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [MatrixWithDisplayNameConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig) =
                    apply {
                        additionalProperties =
                            matrixWithDisplayNameConfig.additionalProperties.toMutableMap()
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): MatrixWithDisplayNameConfig =
                    MatrixWithDisplayNameConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is MatrixWithDisplayNameConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "MatrixWithDisplayNameConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX_WITH_DISPLAY_NAME = of("matrix_with_display_name")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MATRIX_WITH_DISPLAY_NAME
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MATRIX_WITH_DISPLAY_NAME,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MATRIX_WITH_DISPLAY_NAME -> Value.MATRIX_WITH_DISPLAY_NAME
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MATRIX_WITH_DISPLAY_NAME -> Known.MATRIX_WITH_DISPLAY_NAME
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MatrixWithDisplayNamePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && matrixWithDisplayNameConfig == other.matrixWithDisplayNameConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, matrixWithDisplayNameConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MatrixWithDisplayNamePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixWithDisplayNameConfig=$matrixWithDisplayNameConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class BulkWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("bulk_with_proration_config")
        @ExcludeMissing
        private val bulkWithProrationConfig: JsonField<BulkWithProrationConfig> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun bulkWithProrationConfig(): BulkWithProrationConfig =
            bulkWithProrationConfig.getRequired("bulk_with_proration_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [bulkWithProrationConfig].
         *
         * Unlike [bulkWithProrationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("bulk_with_proration_config")
        @ExcludeMissing
        fun _bulkWithProrationConfig(): JsonField<BulkWithProrationConfig> = bulkWithProrationConfig

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): BulkWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bulkWithProrationConfig().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [BulkWithProrationPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bulkWithProrationConfig()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [BulkWithProrationPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var bulkWithProrationConfig: JsonField<BulkWithProrationConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bulkWithProrationPrice: BulkWithProrationPrice) = apply {
                id = bulkWithProrationPrice.id
                billableMetric = bulkWithProrationPrice.billableMetric
                billingCycleConfiguration = bulkWithProrationPrice.billingCycleConfiguration
                bulkWithProrationConfig = bulkWithProrationPrice.bulkWithProrationConfig
                cadence = bulkWithProrationPrice.cadence
                conversionRate = bulkWithProrationPrice.conversionRate
                createdAt = bulkWithProrationPrice.createdAt
                creditAllocation = bulkWithProrationPrice.creditAllocation
                currency = bulkWithProrationPrice.currency
                discount = bulkWithProrationPrice.discount
                externalPriceId = bulkWithProrationPrice.externalPriceId
                fixedPriceQuantity = bulkWithProrationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = bulkWithProrationPrice.invoicingCycleConfiguration
                item = bulkWithProrationPrice.item
                maximum = bulkWithProrationPrice.maximum
                maximumAmount = bulkWithProrationPrice.maximumAmount
                metadata = bulkWithProrationPrice.metadata
                minimum = bulkWithProrationPrice.minimum
                minimumAmount = bulkWithProrationPrice.minimumAmount
                modelType = bulkWithProrationPrice.modelType
                name = bulkWithProrationPrice.name
                planPhaseOrder = bulkWithProrationPrice.planPhaseOrder
                priceType = bulkWithProrationPrice.priceType
                dimensionalPriceConfiguration = bulkWithProrationPrice.dimensionalPriceConfiguration
                additionalProperties = bulkWithProrationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bulkWithProrationConfig(bulkWithProrationConfig: BulkWithProrationConfig) =
                bulkWithProrationConfig(JsonField.of(bulkWithProrationConfig))

            /**
             * Sets [Builder.bulkWithProrationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.bulkWithProrationConfig] with a well-typed
             * [BulkWithProrationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun bulkWithProrationConfig(
                bulkWithProrationConfig: JsonField<BulkWithProrationConfig>
            ) = apply { this.bulkWithProrationConfig = bulkWithProrationConfig }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): BulkWithProrationPrice =
                BulkWithProrationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bulkWithProrationConfig", bulkWithProrationConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BulkWithProrationConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BulkWithProrationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BulkWithProrationConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BulkWithProrationConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(bulkWithProrationConfig: BulkWithProrationConfig) = apply {
                    additionalProperties =
                        bulkWithProrationConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BulkWithProrationConfig =
                    BulkWithProrationConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BulkWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BulkWithProrationConfig{additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK_WITH_PRORATION = of("bulk_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BULK_WITH_PRORATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BULK_WITH_PRORATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BULK_WITH_PRORATION -> Value.BULK_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BULK_WITH_PRORATION -> Known.BULK_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BulkWithProrationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bulkWithProrationConfig == other.bulkWithProrationConfig && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bulkWithProrationConfig, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BulkWithProrationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bulkWithProrationConfig=$bulkWithProrationConfig, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedTieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_tiered_package_config")
        @ExcludeMissing
        private val groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig> =
            JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedTieredPackageConfig(): GroupedTieredPackageConfig =
            groupedTieredPackageConfig.getRequired("grouped_tiered_package_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedTieredPackageConfig].
         *
         * Unlike [groupedTieredPackageConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("grouped_tiered_package_config")
        @ExcludeMissing
        fun _groupedTieredPackageConfig(): JsonField<GroupedTieredPackageConfig> =
            groupedTieredPackageConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedTieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedTieredPackageConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [GroupedTieredPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedTieredPackageConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedTieredPackagePrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedTieredPackagePrice: GroupedTieredPackagePrice) = apply {
                id = groupedTieredPackagePrice.id
                billableMetric = groupedTieredPackagePrice.billableMetric
                billingCycleConfiguration = groupedTieredPackagePrice.billingCycleConfiguration
                cadence = groupedTieredPackagePrice.cadence
                conversionRate = groupedTieredPackagePrice.conversionRate
                createdAt = groupedTieredPackagePrice.createdAt
                creditAllocation = groupedTieredPackagePrice.creditAllocation
                currency = groupedTieredPackagePrice.currency
                discount = groupedTieredPackagePrice.discount
                externalPriceId = groupedTieredPackagePrice.externalPriceId
                fixedPriceQuantity = groupedTieredPackagePrice.fixedPriceQuantity
                groupedTieredPackageConfig = groupedTieredPackagePrice.groupedTieredPackageConfig
                invoicingCycleConfiguration = groupedTieredPackagePrice.invoicingCycleConfiguration
                item = groupedTieredPackagePrice.item
                maximum = groupedTieredPackagePrice.maximum
                maximumAmount = groupedTieredPackagePrice.maximumAmount
                metadata = groupedTieredPackagePrice.metadata
                minimum = groupedTieredPackagePrice.minimum
                minimumAmount = groupedTieredPackagePrice.minimumAmount
                modelType = groupedTieredPackagePrice.modelType
                name = groupedTieredPackagePrice.name
                planPhaseOrder = groupedTieredPackagePrice.planPhaseOrder
                priceType = groupedTieredPackagePrice.priceType
                dimensionalPriceConfiguration =
                    groupedTieredPackagePrice.dimensionalPriceConfiguration
                additionalProperties = groupedTieredPackagePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedTieredPackageConfig(groupedTieredPackageConfig: GroupedTieredPackageConfig) =
                groupedTieredPackageConfig(JsonField.of(groupedTieredPackageConfig))

            /**
             * Sets [Builder.groupedTieredPackageConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedTieredPackageConfig] with a well-typed
             * [GroupedTieredPackageConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun groupedTieredPackageConfig(
                groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig>
            ) = apply { this.groupedTieredPackageConfig = groupedTieredPackageConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedTieredPackagePrice =
                GroupedTieredPackagePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedTieredPackageConfig", groupedTieredPackageConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class GroupedTieredPackageConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): GroupedTieredPackageConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedTieredPackageConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [GroupedTieredPackageConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(groupedTieredPackageConfig: GroupedTieredPackageConfig) = apply {
                    additionalProperties =
                        groupedTieredPackageConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): GroupedTieredPackageConfig =
                    GroupedTieredPackageConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedTieredPackageConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedTieredPackageConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_TIERED_PACKAGE = of("grouped_tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_TIERED_PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_TIERED_PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_TIERED_PACKAGE -> Value.GROUPED_TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_TIERED_PACKAGE -> Known.GROUPED_TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedTieredPackagePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedTieredPackageConfig == other.groupedTieredPackageConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedTieredPackageConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedTieredPackagePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedTieredPackageConfig=$groupedTieredPackageConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class MaxGroupTieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("max_group_tiered_package_config")
        @ExcludeMissing
        private val maxGroupTieredPackageConfig: JsonField<MaxGroupTieredPackageConfig> =
            JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun maxGroupTieredPackageConfig(): MaxGroupTieredPackageConfig =
            maxGroupTieredPackageConfig.getRequired("max_group_tiered_package_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maxGroupTieredPackageConfig].
         *
         * Unlike [maxGroupTieredPackageConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("max_group_tiered_package_config")
        @ExcludeMissing
        fun _maxGroupTieredPackageConfig(): JsonField<MaxGroupTieredPackageConfig> =
            maxGroupTieredPackageConfig

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): MaxGroupTieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maxGroupTieredPackageConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [MaxGroupTieredPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maxGroupTieredPackageConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [MaxGroupTieredPackagePrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maxGroupTieredPackageConfig: JsonField<MaxGroupTieredPackageConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(maxGroupTieredPackagePrice: MaxGroupTieredPackagePrice) = apply {
                id = maxGroupTieredPackagePrice.id
                billableMetric = maxGroupTieredPackagePrice.billableMetric
                billingCycleConfiguration = maxGroupTieredPackagePrice.billingCycleConfiguration
                cadence = maxGroupTieredPackagePrice.cadence
                conversionRate = maxGroupTieredPackagePrice.conversionRate
                createdAt = maxGroupTieredPackagePrice.createdAt
                creditAllocation = maxGroupTieredPackagePrice.creditAllocation
                currency = maxGroupTieredPackagePrice.currency
                discount = maxGroupTieredPackagePrice.discount
                externalPriceId = maxGroupTieredPackagePrice.externalPriceId
                fixedPriceQuantity = maxGroupTieredPackagePrice.fixedPriceQuantity
                invoicingCycleConfiguration = maxGroupTieredPackagePrice.invoicingCycleConfiguration
                item = maxGroupTieredPackagePrice.item
                maxGroupTieredPackageConfig = maxGroupTieredPackagePrice.maxGroupTieredPackageConfig
                maximum = maxGroupTieredPackagePrice.maximum
                maximumAmount = maxGroupTieredPackagePrice.maximumAmount
                metadata = maxGroupTieredPackagePrice.metadata
                minimum = maxGroupTieredPackagePrice.minimum
                minimumAmount = maxGroupTieredPackagePrice.minimumAmount
                modelType = maxGroupTieredPackagePrice.modelType
                name = maxGroupTieredPackagePrice.name
                planPhaseOrder = maxGroupTieredPackagePrice.planPhaseOrder
                priceType = maxGroupTieredPackagePrice.priceType
                dimensionalPriceConfiguration =
                    maxGroupTieredPackagePrice.dimensionalPriceConfiguration
                additionalProperties =
                    maxGroupTieredPackagePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maxGroupTieredPackageConfig(
                maxGroupTieredPackageConfig: MaxGroupTieredPackageConfig
            ) = maxGroupTieredPackageConfig(JsonField.of(maxGroupTieredPackageConfig))

            /**
             * Sets [Builder.maxGroupTieredPackageConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maxGroupTieredPackageConfig] with a well-typed
             * [MaxGroupTieredPackageConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun maxGroupTieredPackageConfig(
                maxGroupTieredPackageConfig: JsonField<MaxGroupTieredPackageConfig>
            ) = apply { this.maxGroupTieredPackageConfig = maxGroupTieredPackageConfig }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): MaxGroupTieredPackagePrice =
                MaxGroupTieredPackagePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maxGroupTieredPackageConfig", maxGroupTieredPackageConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class MaxGroupTieredPackageConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): MaxGroupTieredPackageConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [MaxGroupTieredPackageConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [MaxGroupTieredPackageConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maxGroupTieredPackageConfig: MaxGroupTieredPackageConfig) =
                    apply {
                        additionalProperties =
                            maxGroupTieredPackageConfig.additionalProperties.toMutableMap()
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): MaxGroupTieredPackageConfig =
                    MaxGroupTieredPackageConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is MaxGroupTieredPackageConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "MaxGroupTieredPackageConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MAX_GROUP_TIERED_PACKAGE = of("max_group_tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MAX_GROUP_TIERED_PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MAX_GROUP_TIERED_PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MAX_GROUP_TIERED_PACKAGE -> Value.MAX_GROUP_TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MAX_GROUP_TIERED_PACKAGE -> Known.MAX_GROUP_TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MaxGroupTieredPackagePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maxGroupTieredPackageConfig == other.maxGroupTieredPackageConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maxGroupTieredPackageConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MaxGroupTieredPackagePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maxGroupTieredPackageConfig=$maxGroupTieredPackageConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class ScalableMatrixWithUnitPricingPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("scalable_matrix_with_unit_pricing_config")
        @ExcludeMissing
        private val scalableMatrixWithUnitPricingConfig:
            JsonField<ScalableMatrixWithUnitPricingConfig> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun scalableMatrixWithUnitPricingConfig(): ScalableMatrixWithUnitPricingConfig =
            scalableMatrixWithUnitPricingConfig.getRequired(
                "scalable_matrix_with_unit_pricing_config"
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [scalableMatrixWithUnitPricingConfig].
         *
         * Unlike [scalableMatrixWithUnitPricingConfig], this method doesn't throw if the JSON field
         * has an unexpected type.
         */
        @JsonProperty("scalable_matrix_with_unit_pricing_config")
        @ExcludeMissing
        fun _scalableMatrixWithUnitPricingConfig(): JsonField<ScalableMatrixWithUnitPricingConfig> =
            scalableMatrixWithUnitPricingConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): ScalableMatrixWithUnitPricingPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            scalableMatrixWithUnitPricingConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [ScalableMatrixWithUnitPricingPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .scalableMatrixWithUnitPricingConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [ScalableMatrixWithUnitPricingPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var scalableMatrixWithUnitPricingConfig:
                JsonField<ScalableMatrixWithUnitPricingConfig>? =
                null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                scalableMatrixWithUnitPricingPrice: ScalableMatrixWithUnitPricingPrice
            ) = apply {
                id = scalableMatrixWithUnitPricingPrice.id
                billableMetric = scalableMatrixWithUnitPricingPrice.billableMetric
                billingCycleConfiguration =
                    scalableMatrixWithUnitPricingPrice.billingCycleConfiguration
                cadence = scalableMatrixWithUnitPricingPrice.cadence
                conversionRate = scalableMatrixWithUnitPricingPrice.conversionRate
                createdAt = scalableMatrixWithUnitPricingPrice.createdAt
                creditAllocation = scalableMatrixWithUnitPricingPrice.creditAllocation
                currency = scalableMatrixWithUnitPricingPrice.currency
                discount = scalableMatrixWithUnitPricingPrice.discount
                externalPriceId = scalableMatrixWithUnitPricingPrice.externalPriceId
                fixedPriceQuantity = scalableMatrixWithUnitPricingPrice.fixedPriceQuantity
                invoicingCycleConfiguration =
                    scalableMatrixWithUnitPricingPrice.invoicingCycleConfiguration
                item = scalableMatrixWithUnitPricingPrice.item
                maximum = scalableMatrixWithUnitPricingPrice.maximum
                maximumAmount = scalableMatrixWithUnitPricingPrice.maximumAmount
                metadata = scalableMatrixWithUnitPricingPrice.metadata
                minimum = scalableMatrixWithUnitPricingPrice.minimum
                minimumAmount = scalableMatrixWithUnitPricingPrice.minimumAmount
                modelType = scalableMatrixWithUnitPricingPrice.modelType
                name = scalableMatrixWithUnitPricingPrice.name
                planPhaseOrder = scalableMatrixWithUnitPricingPrice.planPhaseOrder
                priceType = scalableMatrixWithUnitPricingPrice.priceType
                scalableMatrixWithUnitPricingConfig =
                    scalableMatrixWithUnitPricingPrice.scalableMatrixWithUnitPricingConfig
                dimensionalPriceConfiguration =
                    scalableMatrixWithUnitPricingPrice.dimensionalPriceConfiguration
                additionalProperties =
                    scalableMatrixWithUnitPricingPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun scalableMatrixWithUnitPricingConfig(
                scalableMatrixWithUnitPricingConfig: ScalableMatrixWithUnitPricingConfig
            ) =
                scalableMatrixWithUnitPricingConfig(
                    JsonField.of(scalableMatrixWithUnitPricingConfig)
                )

            /**
             * Sets [Builder.scalableMatrixWithUnitPricingConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.scalableMatrixWithUnitPricingConfig] with a
             * well-typed [ScalableMatrixWithUnitPricingConfig] value instead. This method is
             * primarily for setting the field to an undocumented or not yet supported value.
             */
            fun scalableMatrixWithUnitPricingConfig(
                scalableMatrixWithUnitPricingConfig: JsonField<ScalableMatrixWithUnitPricingConfig>
            ) = apply {
                this.scalableMatrixWithUnitPricingConfig = scalableMatrixWithUnitPricingConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): ScalableMatrixWithUnitPricingPrice =
                ScalableMatrixWithUnitPricingPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired(
                        "scalableMatrixWithUnitPricingConfig",
                        scalableMatrixWithUnitPricingConfig,
                    ),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField
                val SCALABLE_MATRIX_WITH_UNIT_PRICING = of("scalable_matrix_with_unit_pricing")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                SCALABLE_MATRIX_WITH_UNIT_PRICING
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                SCALABLE_MATRIX_WITH_UNIT_PRICING,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    SCALABLE_MATRIX_WITH_UNIT_PRICING -> Value.SCALABLE_MATRIX_WITH_UNIT_PRICING
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    SCALABLE_MATRIX_WITH_UNIT_PRICING -> Known.SCALABLE_MATRIX_WITH_UNIT_PRICING
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class ScalableMatrixWithUnitPricingConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): ScalableMatrixWithUnitPricingConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [ScalableMatrixWithUnitPricingConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [ScalableMatrixWithUnitPricingConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    scalableMatrixWithUnitPricingConfig: ScalableMatrixWithUnitPricingConfig
                ) = apply {
                    additionalProperties =
                        scalableMatrixWithUnitPricingConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): ScalableMatrixWithUnitPricingConfig =
                    ScalableMatrixWithUnitPricingConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ScalableMatrixWithUnitPricingConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "ScalableMatrixWithUnitPricingConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is ScalableMatrixWithUnitPricingPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && scalableMatrixWithUnitPricingConfig == other.scalableMatrixWithUnitPricingConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, scalableMatrixWithUnitPricingConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "ScalableMatrixWithUnitPricingPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, scalableMatrixWithUnitPricingConfig=$scalableMatrixWithUnitPricingConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class ScalableMatrixWithTieredPricingPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("scalable_matrix_with_tiered_pricing_config")
        @ExcludeMissing
        private val scalableMatrixWithTieredPricingConfig:
            JsonField<ScalableMatrixWithTieredPricingConfig> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun scalableMatrixWithTieredPricingConfig(): ScalableMatrixWithTieredPricingConfig =
            scalableMatrixWithTieredPricingConfig.getRequired(
                "scalable_matrix_with_tiered_pricing_config"
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [scalableMatrixWithTieredPricingConfig].
         *
         * Unlike [scalableMatrixWithTieredPricingConfig], this method doesn't throw if the JSON
         * field has an unexpected type.
         */
        @JsonProperty("scalable_matrix_with_tiered_pricing_config")
        @ExcludeMissing
        fun _scalableMatrixWithTieredPricingConfig():
            JsonField<ScalableMatrixWithTieredPricingConfig> = scalableMatrixWithTieredPricingConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): ScalableMatrixWithTieredPricingPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            scalableMatrixWithTieredPricingConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [ScalableMatrixWithTieredPricingPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .scalableMatrixWithTieredPricingConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [ScalableMatrixWithTieredPricingPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var scalableMatrixWithTieredPricingConfig:
                JsonField<ScalableMatrixWithTieredPricingConfig>? =
                null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                scalableMatrixWithTieredPricingPrice: ScalableMatrixWithTieredPricingPrice
            ) = apply {
                id = scalableMatrixWithTieredPricingPrice.id
                billableMetric = scalableMatrixWithTieredPricingPrice.billableMetric
                billingCycleConfiguration =
                    scalableMatrixWithTieredPricingPrice.billingCycleConfiguration
                cadence = scalableMatrixWithTieredPricingPrice.cadence
                conversionRate = scalableMatrixWithTieredPricingPrice.conversionRate
                createdAt = scalableMatrixWithTieredPricingPrice.createdAt
                creditAllocation = scalableMatrixWithTieredPricingPrice.creditAllocation
                currency = scalableMatrixWithTieredPricingPrice.currency
                discount = scalableMatrixWithTieredPricingPrice.discount
                externalPriceId = scalableMatrixWithTieredPricingPrice.externalPriceId
                fixedPriceQuantity = scalableMatrixWithTieredPricingPrice.fixedPriceQuantity
                invoicingCycleConfiguration =
                    scalableMatrixWithTieredPricingPrice.invoicingCycleConfiguration
                item = scalableMatrixWithTieredPricingPrice.item
                maximum = scalableMatrixWithTieredPricingPrice.maximum
                maximumAmount = scalableMatrixWithTieredPricingPrice.maximumAmount
                metadata = scalableMatrixWithTieredPricingPrice.metadata
                minimum = scalableMatrixWithTieredPricingPrice.minimum
                minimumAmount = scalableMatrixWithTieredPricingPrice.minimumAmount
                modelType = scalableMatrixWithTieredPricingPrice.modelType
                name = scalableMatrixWithTieredPricingPrice.name
                planPhaseOrder = scalableMatrixWithTieredPricingPrice.planPhaseOrder
                priceType = scalableMatrixWithTieredPricingPrice.priceType
                scalableMatrixWithTieredPricingConfig =
                    scalableMatrixWithTieredPricingPrice.scalableMatrixWithTieredPricingConfig
                dimensionalPriceConfiguration =
                    scalableMatrixWithTieredPricingPrice.dimensionalPriceConfiguration
                additionalProperties =
                    scalableMatrixWithTieredPricingPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun scalableMatrixWithTieredPricingConfig(
                scalableMatrixWithTieredPricingConfig: ScalableMatrixWithTieredPricingConfig
            ) =
                scalableMatrixWithTieredPricingConfig(
                    JsonField.of(scalableMatrixWithTieredPricingConfig)
                )

            /**
             * Sets [Builder.scalableMatrixWithTieredPricingConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.scalableMatrixWithTieredPricingConfig] with a
             * well-typed [ScalableMatrixWithTieredPricingConfig] value instead. This method is
             * primarily for setting the field to an undocumented or not yet supported value.
             */
            fun scalableMatrixWithTieredPricingConfig(
                scalableMatrixWithTieredPricingConfig:
                    JsonField<ScalableMatrixWithTieredPricingConfig>
            ) = apply {
                this.scalableMatrixWithTieredPricingConfig = scalableMatrixWithTieredPricingConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): ScalableMatrixWithTieredPricingPrice =
                ScalableMatrixWithTieredPricingPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired(
                        "scalableMatrixWithTieredPricingConfig",
                        scalableMatrixWithTieredPricingConfig,
                    ),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField
                val SCALABLE_MATRIX_WITH_TIERED_PRICING = of("scalable_matrix_with_tiered_pricing")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                SCALABLE_MATRIX_WITH_TIERED_PRICING
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                SCALABLE_MATRIX_WITH_TIERED_PRICING,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    SCALABLE_MATRIX_WITH_TIERED_PRICING -> Value.SCALABLE_MATRIX_WITH_TIERED_PRICING
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    SCALABLE_MATRIX_WITH_TIERED_PRICING -> Known.SCALABLE_MATRIX_WITH_TIERED_PRICING
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class ScalableMatrixWithTieredPricingConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): ScalableMatrixWithTieredPricingConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [ScalableMatrixWithTieredPricingConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [ScalableMatrixWithTieredPricingConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    scalableMatrixWithTieredPricingConfig: ScalableMatrixWithTieredPricingConfig
                ) = apply {
                    additionalProperties =
                        scalableMatrixWithTieredPricingConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): ScalableMatrixWithTieredPricingConfig =
                    ScalableMatrixWithTieredPricingConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ScalableMatrixWithTieredPricingConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "ScalableMatrixWithTieredPricingConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is ScalableMatrixWithTieredPricingPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && scalableMatrixWithTieredPricingConfig == other.scalableMatrixWithTieredPricingConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, scalableMatrixWithTieredPricingConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "ScalableMatrixWithTieredPricingPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, scalableMatrixWithTieredPricingConfig=$scalableMatrixWithTieredPricingConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class CumulativeGroupedBulkPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetric> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<CreditAllocation> = JsonMissing.of(),
        @JsonProperty("cumulative_grouped_bulk_config")
        @ExcludeMissing
        private val cumulativeGroupedBulkConfig: JsonField<CumulativeGroupedBulkConfig> =
            JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration> =
            JsonMissing.of(),
        @JsonProperty("item") @ExcludeMissing private val item: JsonField<Item> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<Maximum> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<Minimum> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetric> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<CreditAllocation> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cumulativeGroupedBulkConfig(): CumulativeGroupedBulkConfig =
            cumulativeGroupedBulkConfig.getRequired("cumulative_grouped_bulk_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<InvoicingCycleConfiguration> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): Item = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximum(): Optional<Maximum> = Optional.ofNullable(maximum.getNullable("maximum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimum(): Optional<Minimum> = Optional.ofNullable(minimum.getNullable("minimum"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun modelType(): ModelType = modelType.getRequired("model_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetric> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<CreditAllocation> = creditAllocation

        /**
         * Returns the raw JSON value of [cumulativeGroupedBulkConfig].
         *
         * Unlike [cumulativeGroupedBulkConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("cumulative_grouped_bulk_config")
        @ExcludeMissing
        fun _cumulativeGroupedBulkConfig(): JsonField<CumulativeGroupedBulkConfig> =
            cumulativeGroupedBulkConfig

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<InvoicingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<Item> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [modelType].
         *
         * Unlike [modelType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): CumulativeGroupedBulkPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            cumulativeGroupedBulkConfig().validate()
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [CumulativeGroupedBulkPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .cumulativeGroupedBulkConfig()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [CumulativeGroupedBulkPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetric>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<CreditAllocation>? = null
            private var cumulativeGroupedBulkConfig: JsonField<CumulativeGroupedBulkConfig>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>? = null
            private var item: JsonField<Item>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(cumulativeGroupedBulkPrice: CumulativeGroupedBulkPrice) = apply {
                id = cumulativeGroupedBulkPrice.id
                billableMetric = cumulativeGroupedBulkPrice.billableMetric
                billingCycleConfiguration = cumulativeGroupedBulkPrice.billingCycleConfiguration
                cadence = cumulativeGroupedBulkPrice.cadence
                conversionRate = cumulativeGroupedBulkPrice.conversionRate
                createdAt = cumulativeGroupedBulkPrice.createdAt
                creditAllocation = cumulativeGroupedBulkPrice.creditAllocation
                cumulativeGroupedBulkConfig = cumulativeGroupedBulkPrice.cumulativeGroupedBulkConfig
                currency = cumulativeGroupedBulkPrice.currency
                discount = cumulativeGroupedBulkPrice.discount
                externalPriceId = cumulativeGroupedBulkPrice.externalPriceId
                fixedPriceQuantity = cumulativeGroupedBulkPrice.fixedPriceQuantity
                invoicingCycleConfiguration = cumulativeGroupedBulkPrice.invoicingCycleConfiguration
                item = cumulativeGroupedBulkPrice.item
                maximum = cumulativeGroupedBulkPrice.maximum
                maximumAmount = cumulativeGroupedBulkPrice.maximumAmount
                metadata = cumulativeGroupedBulkPrice.metadata
                minimum = cumulativeGroupedBulkPrice.minimum
                minimumAmount = cumulativeGroupedBulkPrice.minimumAmount
                modelType = cumulativeGroupedBulkPrice.modelType
                name = cumulativeGroupedBulkPrice.name
                planPhaseOrder = cumulativeGroupedBulkPrice.planPhaseOrder
                priceType = cumulativeGroupedBulkPrice.priceType
                dimensionalPriceConfiguration =
                    cumulativeGroupedBulkPrice.dimensionalPriceConfiguration
                additionalProperties =
                    cumulativeGroupedBulkPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetric?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetric>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed [BillableMetric]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetric>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: CreditAllocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<CreditAllocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed
             * [CreditAllocation] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<CreditAllocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun cumulativeGroupedBulkConfig(
                cumulativeGroupedBulkConfig: CumulativeGroupedBulkConfig
            ) = cumulativeGroupedBulkConfig(JsonField.of(cumulativeGroupedBulkConfig))

            /**
             * Sets [Builder.cumulativeGroupedBulkConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cumulativeGroupedBulkConfig] with a well-typed
             * [CumulativeGroupedBulkConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun cumulativeGroupedBulkConfig(
                cumulativeGroupedBulkConfig: JsonField<CumulativeGroupedBulkConfig>
            ) = apply { this.cumulativeGroupedBulkConfig = cumulativeGroupedBulkConfig }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * TrialDiscount.builder()
             *     .discountType(TrialDiscount.DiscountType.TRIAL)
             *     .appliesToPriceIds(appliesToPriceIds)
             *     .build()
             * ```
             */
            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: InvoicingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<InvoicingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [InvoicingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<InvoicingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: Item) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [Item] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun item(item: JsonField<Item>) = apply { this.item = item }

            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            /**
             * Sets [Builder.modelType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.modelType] with a well-typed [ModelType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): CumulativeGroupedBulkPrice =
                CumulativeGroupedBulkPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("cumulativeGroupedBulkConfig", cumulativeGroupedBulkConfig),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        @NoAutoDetect
        class BillableMetric
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillableMetric = apply {
                if (validated) {
                    return@apply
                }

                id()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [BillableMetric].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillableMetric]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billableMetric: BillableMetric) = apply {
                    id = billableMetric.id
                    additionalProperties = billableMetric.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillableMetric =
                    BillableMetric(checkRequired("id", id), additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillableMetric && id == other.id && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillableMetric{id=$id, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class BillingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): BillingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BillingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BillingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(billingCycleConfiguration: BillingCycleConfiguration) = apply {
                    duration = billingCycleConfiguration.duration
                    durationUnit = billingCycleConfiguration.durationUnit
                    additionalProperties =
                        billingCycleConfiguration.additionalProperties.toMutableMap()
                }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): BillingCycleConfiguration =
                    BillingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BillingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BillingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class CreditAllocation
        @JsonCreator
        private constructor(
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            private val allowsRollover: JsonField<Boolean> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            private val currency: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun allowsRollover(): Boolean = allowsRollover.getRequired("allows_rollover")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun currency(): String = currency.getRequired("currency")

            /**
             * Returns the raw JSON value of [allowsRollover].
             *
             * Unlike [allowsRollover], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("allows_rollover")
            @ExcludeMissing
            fun _allowsRollover(): JsonField<Boolean> = allowsRollover

            /**
             * Returns the raw JSON value of [currency].
             *
             * Unlike [currency], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CreditAllocation = apply {
                if (validated) {
                    return@apply
                }

                allowsRollover()
                currency()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [CreditAllocation].
                 *
                 * The following fields are required:
                 * ```java
                 * .allowsRollover()
                 * .currency()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CreditAllocation]. */
            class Builder internal constructor() {

                private var allowsRollover: JsonField<Boolean>? = null
                private var currency: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(creditAllocation: CreditAllocation) = apply {
                    allowsRollover = creditAllocation.allowsRollover
                    currency = creditAllocation.currency
                    additionalProperties = creditAllocation.additionalProperties.toMutableMap()
                }

                fun allowsRollover(allowsRollover: Boolean) =
                    allowsRollover(JsonField.of(allowsRollover))

                /**
                 * Sets [Builder.allowsRollover] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.allowsRollover] with a well-typed [Boolean]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun allowsRollover(allowsRollover: JsonField<Boolean>) = apply {
                    this.allowsRollover = allowsRollover
                }

                fun currency(currency: String) = currency(JsonField.of(currency))

                /**
                 * Sets [Builder.currency] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.currency] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun currency(currency: JsonField<String>) = apply { this.currency = currency }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CreditAllocation =
                    CreditAllocation(
                        checkRequired("allowsRollover", allowsRollover),
                        checkRequired("currency", currency),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CreditAllocation && allowsRollover == other.allowsRollover && currency == other.currency && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(allowsRollover, currency, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CreditAllocation{allowsRollover=$allowsRollover, currency=$currency, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class CumulativeGroupedBulkConfig
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): CumulativeGroupedBulkConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [CumulativeGroupedBulkConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CumulativeGroupedBulkConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(cumulativeGroupedBulkConfig: CumulativeGroupedBulkConfig) =
                    apply {
                        additionalProperties =
                            cumulativeGroupedBulkConfig.additionalProperties.toMutableMap()
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): CumulativeGroupedBulkConfig =
                    CumulativeGroupedBulkConfig(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CumulativeGroupedBulkConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CumulativeGroupedBulkConfig{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class InvoicingCycleConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("duration")
            @ExcludeMissing
            private val duration: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("duration_unit")
            @ExcludeMissing
            private val durationUnit: JsonField<DurationUnit> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun duration(): Long = duration.getRequired("duration")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun durationUnit(): DurationUnit = durationUnit.getRequired("duration_unit")

            /**
             * Returns the raw JSON value of [duration].
             *
             * Unlike [duration], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration") @ExcludeMissing fun _duration(): JsonField<Long> = duration

            /**
             * Returns the raw JSON value of [durationUnit].
             *
             * Unlike [durationUnit], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("duration_unit")
            @ExcludeMissing
            fun _durationUnit(): JsonField<DurationUnit> = durationUnit

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): InvoicingCycleConfiguration = apply {
                if (validated) {
                    return@apply
                }

                duration()
                durationUnit()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [InvoicingCycleConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .duration()
                 * .durationUnit()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [InvoicingCycleConfiguration]. */
            class Builder internal constructor() {

                private var duration: JsonField<Long>? = null
                private var durationUnit: JsonField<DurationUnit>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(invoicingCycleConfiguration: InvoicingCycleConfiguration) =
                    apply {
                        duration = invoicingCycleConfiguration.duration
                        durationUnit = invoicingCycleConfiguration.durationUnit
                        additionalProperties =
                            invoicingCycleConfiguration.additionalProperties.toMutableMap()
                    }

                fun duration(duration: Long) = duration(JsonField.of(duration))

                /**
                 * Sets [Builder.duration] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.duration] with a well-typed [Long] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun duration(duration: JsonField<Long>) = apply { this.duration = duration }

                fun durationUnit(durationUnit: DurationUnit) =
                    durationUnit(JsonField.of(durationUnit))

                /**
                 * Sets [Builder.durationUnit] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.durationUnit] with a well-typed [DurationUnit]
                 * value instead. This method is primarily for setting the field to an undocumented
                 * or not yet supported value.
                 */
                fun durationUnit(durationUnit: JsonField<DurationUnit>) = apply {
                    this.durationUnit = durationUnit
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): InvoicingCycleConfiguration =
                    InvoicingCycleConfiguration(
                        checkRequired("duration", duration),
                        checkRequired("durationUnit", durationUnit),
                        additionalProperties.toImmutable(),
                    )
            }

            class DurationUnit
            @JsonCreator
            private constructor(private val value: JsonField<String>) : Enum {

                /**
                 * Returns this class instance's raw value.
                 *
                 * This is usually only useful if this instance was deserialized from data that
                 * doesn't match any known member, and you want to know that value. For example, if
                 * the SDK is on an older version than the API, then the API may respond with new
                 * members that the SDK is unaware of.
                 */
                @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

                companion object {

                    @JvmField val DAY = of("day")

                    @JvmField val MONTH = of("month")

                    @JvmStatic fun of(value: String) = DurationUnit(JsonField.of(value))
                }

                /** An enum containing [DurationUnit]'s known values. */
                enum class Known {
                    DAY,
                    MONTH,
                }

                /**
                 * An enum containing [DurationUnit]'s known values, as well as an [_UNKNOWN]
                 * member.
                 *
                 * An instance of [DurationUnit] can contain an unknown value in a couple of cases:
                 * - It was deserialized from data that doesn't match any known member. For example,
                 *   if the SDK is on an older version than the API, then the API may respond with
                 *   new members that the SDK is unaware of.
                 * - It was constructed with an arbitrary value using the [of] method.
                 */
                enum class Value {
                    DAY,
                    MONTH,
                    /**
                     * An enum member indicating that [DurationUnit] was instantiated with an
                     * unknown value.
                     */
                    _UNKNOWN,
                }

                /**
                 * Returns an enum member corresponding to this class instance's value, or
                 * [Value._UNKNOWN] if the class was instantiated with an unknown value.
                 *
                 * Use the [known] method instead if you're certain the value is always known or if
                 * you want to throw for the unknown case.
                 */
                fun value(): Value =
                    when (this) {
                        DAY -> Value.DAY
                        MONTH -> Value.MONTH
                        else -> Value._UNKNOWN
                    }

                /**
                 * Returns an enum member corresponding to this class instance's value.
                 *
                 * Use the [value] method instead if you're uncertain the value is always known and
                 * don't want to throw for the unknown case.
                 *
                 * @throws OrbInvalidDataException if this class instance's value is a not a known
                 *   member.
                 */
                fun known(): Known =
                    when (this) {
                        DAY -> Known.DAY
                        MONTH -> Known.MONTH
                        else -> throw OrbInvalidDataException("Unknown DurationUnit: $value")
                    }

                /**
                 * Returns this class instance's primitive wire representation.
                 *
                 * This differs from the [toString] method because that method is primarily for
                 * debugging and generally doesn't throw.
                 *
                 * @throws OrbInvalidDataException if this class instance's value does not have the
                 *   expected primitive type.
                 */
                fun asString(): String =
                    _value().asString().orElseThrow {
                        OrbInvalidDataException("Value is not a String")
                    }

                override fun equals(other: Any?): Boolean {
                    if (this === other) {
                        return true
                    }

                    return /* spotless:off */ other is DurationUnit && value == other.value /* spotless:on */
                }

                override fun hashCode() = value.hashCode()

                override fun toString() = value.toString()
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is InvoicingCycleConfiguration && duration == other.duration && durationUnit == other.durationUnit && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(duration, durationUnit, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "InvoicingCycleConfiguration{duration=$duration, durationUnit=$durationUnit, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Item
        @JsonCreator
        private constructor(
            @JsonProperty("id")
            @ExcludeMissing
            private val id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("name")
            @ExcludeMissing
            private val name: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun id(): String = id.getRequired("id")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun name(): String = name.getRequired("name")

            /**
             * Returns the raw JSON value of [id].
             *
             * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

            /**
             * Returns the raw JSON value of [name].
             *
             * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
             */
            @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Item = apply {
                if (validated) {
                    return@apply
                }

                id()
                name()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Item].
                 *
                 * The following fields are required:
                 * ```java
                 * .id()
                 * .name()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Item]. */
            class Builder internal constructor() {

                private var id: JsonField<String>? = null
                private var name: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(item: Item) = apply {
                    id = item.id
                    name = item.name
                    additionalProperties = item.additionalProperties.toMutableMap()
                }

                fun id(id: String) = id(JsonField.of(id))

                /**
                 * Sets [Builder.id] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.id] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun id(id: JsonField<String>) = apply { this.id = id }

                fun name(name: String) = name(JsonField.of(name))

                /**
                 * Sets [Builder.name] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.name] with a well-typed [String] value instead.
                 * This method is primarily for setting the field to an undocumented or not yet
                 * supported value.
                 */
                fun name(name: JsonField<String>) = apply { this.name = name }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Item =
                    Item(
                        checkRequired("id", id),
                        checkRequired("name", name),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Item && id == other.id && name == other.name && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(id, name, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Item{id=$id, name=$name, additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Maximum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            private val maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this maximum amount applies to. For plan/plan phase maximums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Maximum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun maximumAmount(): String = maximumAmount.getRequired("maximum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [maximumAmount].
             *
             * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            fun _maximumAmount(): JsonField<String> = maximumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Maximum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                maximumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Maximum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .maximumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Maximum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var maximumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maximum: Maximum) = apply {
                    appliesToPriceIds = maximum.appliesToPriceIds.map { it.toMutableList() }
                    maximumAmount = maximum.maximumAmount
                    additionalProperties = maximum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this maximum amount applies to. For plan/plan phase
                 * maximums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Maximum amount applied */
                fun maximumAmount(maximumAmount: String) =
                    maximumAmount(JsonField.of(maximumAmount))

                /**
                 * Sets [Builder.maximumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.maximumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                    this.maximumAmount = maximumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Maximum =
                    Maximum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("maximumAmount", maximumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Maximum && appliesToPriceIds == other.appliesToPriceIds && maximumAmount == other.maximumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, maximumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Maximum{appliesToPriceIds=$appliesToPriceIds, maximumAmount=$maximumAmount, additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        @NoAutoDetect
        class Minimum
        @JsonCreator
        private constructor(
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            private val appliesToPriceIds: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            private val minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * List of price_ids that this minimum amount applies to. For plan/plan phase minimums,
             * this can be a subset of prices.
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun appliesToPriceIds(): List<String> =
                appliesToPriceIds.getRequired("applies_to_price_ids")

            /**
             * Minimum amount applied
             *
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun minimumAmount(): String = minimumAmount.getRequired("minimum_amount")

            /**
             * Returns the raw JSON value of [appliesToPriceIds].
             *
             * Unlike [appliesToPriceIds], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("applies_to_price_ids")
            @ExcludeMissing
            fun _appliesToPriceIds(): JsonField<List<String>> = appliesToPriceIds

            /**
             * Returns the raw JSON value of [minimumAmount].
             *
             * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
             * type.
             */
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            fun _minimumAmount(): JsonField<String> = minimumAmount

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Minimum = apply {
                if (validated) {
                    return@apply
                }

                appliesToPriceIds()
                minimumAmount()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [Minimum].
                 *
                 * The following fields are required:
                 * ```java
                 * .appliesToPriceIds()
                 * .minimumAmount()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Minimum]. */
            class Builder internal constructor() {

                private var appliesToPriceIds: JsonField<MutableList<String>>? = null
                private var minimumAmount: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(minimum: Minimum) = apply {
                    appliesToPriceIds = minimum.appliesToPriceIds.map { it.toMutableList() }
                    minimumAmount = minimum.minimumAmount
                    additionalProperties = minimum.additionalProperties.toMutableMap()
                }

                /**
                 * List of price_ids that this minimum amount applies to. For plan/plan phase
                 * minimums, this can be a subset of prices.
                 */
                fun appliesToPriceIds(appliesToPriceIds: List<String>) =
                    appliesToPriceIds(JsonField.of(appliesToPriceIds))

                /**
                 * Sets [Builder.appliesToPriceIds] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.appliesToPriceIds] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun appliesToPriceIds(appliesToPriceIds: JsonField<List<String>>) = apply {
                    this.appliesToPriceIds = appliesToPriceIds.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [appliesToPriceIds].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addAppliesToPriceId(appliesToPriceId: String) = apply {
                    appliesToPriceIds =
                        (appliesToPriceIds ?: JsonField.of(mutableListOf())).also {
                            checkKnown("appliesToPriceIds", it).add(appliesToPriceId)
                        }
                }

                /** Minimum amount applied */
                fun minimumAmount(minimumAmount: String) =
                    minimumAmount(JsonField.of(minimumAmount))

                /**
                 * Sets [Builder.minimumAmount] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.minimumAmount] with a well-typed [String] value
                 * instead. This method is primarily for setting the field to an undocumented or not
                 * yet supported value.
                 */
                fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                    this.minimumAmount = minimumAmount
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Minimum =
                    Minimum(
                        checkRequired("appliesToPriceIds", appliesToPriceIds).map {
                            it.toImmutable()
                        },
                        checkRequired("minimumAmount", minimumAmount),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Minimum && appliesToPriceIds == other.appliesToPriceIds && minimumAmount == other.minimumAmount && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(appliesToPriceIds, minimumAmount, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "Minimum{appliesToPriceIds=$appliesToPriceIds, minimumAmount=$minimumAmount, additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val CUMULATIVE_GROUPED_BULK = of("cumulative_grouped_bulk")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                CUMULATIVE_GROUPED_BULK
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                CUMULATIVE_GROUPED_BULK,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    CUMULATIVE_GROUPED_BULK -> Value.CUMULATIVE_GROUPED_BULK
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    CUMULATIVE_GROUPED_BULK -> Known.CUMULATIVE_GROUPED_BULK
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @NoAutoDetect
        class DimensionalPriceConfiguration
        @JsonCreator
        private constructor(
            @JsonProperty("dimension_values")
            @ExcludeMissing
            private val dimensionValues: JsonField<List<String>> = JsonMissing.of(),
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            private val dimensionalPriceGroupId: JsonField<String> = JsonMissing.of(),
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
        ) {

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionValues(): List<String> = dimensionValues.getRequired("dimension_values")

            /**
             * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
             *   unexpectedly missing or null (e.g. if the server responded with an unexpected
             *   value).
             */
            fun dimensionalPriceGroupId(): String =
                dimensionalPriceGroupId.getRequired("dimensional_price_group_id")

            /**
             * Returns the raw JSON value of [dimensionValues].
             *
             * Unlike [dimensionValues], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimension_values")
            @ExcludeMissing
            fun _dimensionValues(): JsonField<List<String>> = dimensionValues

            /**
             * Returns the raw JSON value of [dimensionalPriceGroupId].
             *
             * Unlike [dimensionalPriceGroupId], this method doesn't throw if the JSON field has an
             * unexpected type.
             */
            @JsonProperty("dimensional_price_group_id")
            @ExcludeMissing
            fun _dimensionalPriceGroupId(): JsonField<String> = dimensionalPriceGroupId

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): DimensionalPriceConfiguration = apply {
                if (validated) {
                    return@apply
                }

                dimensionValues()
                dimensionalPriceGroupId()
                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [DimensionalPriceConfiguration].
                 *
                 * The following fields are required:
                 * ```java
                 * .dimensionValues()
                 * .dimensionalPriceGroupId()
                 * ```
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [DimensionalPriceConfiguration]. */
            class Builder internal constructor() {

                private var dimensionValues: JsonField<MutableList<String>>? = null
                private var dimensionalPriceGroupId: JsonField<String>? = null
                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(dimensionalPriceConfiguration: DimensionalPriceConfiguration) =
                    apply {
                        dimensionValues =
                            dimensionalPriceConfiguration.dimensionValues.map { it.toMutableList() }
                        dimensionalPriceGroupId =
                            dimensionalPriceConfiguration.dimensionalPriceGroupId
                        additionalProperties =
                            dimensionalPriceConfiguration.additionalProperties.toMutableMap()
                    }

                fun dimensionValues(dimensionValues: List<String>) =
                    dimensionValues(JsonField.of(dimensionValues))

                /**
                 * Sets [Builder.dimensionValues] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionValues] with a well-typed
                 * `List<String>` value instead. This method is primarily for setting the field to
                 * an undocumented or not yet supported value.
                 */
                fun dimensionValues(dimensionValues: JsonField<List<String>>) = apply {
                    this.dimensionValues = dimensionValues.map { it.toMutableList() }
                }

                /**
                 * Adds a single [String] to [dimensionValues].
                 *
                 * @throws IllegalStateException if the field was previously set to a non-list.
                 */
                fun addDimensionValue(dimensionValue: String) = apply {
                    dimensionValues =
                        (dimensionValues ?: JsonField.of(mutableListOf())).also {
                            checkKnown("dimensionValues", it).add(dimensionValue)
                        }
                }

                fun dimensionalPriceGroupId(dimensionalPriceGroupId: String) =
                    dimensionalPriceGroupId(JsonField.of(dimensionalPriceGroupId))

                /**
                 * Sets [Builder.dimensionalPriceGroupId] to an arbitrary JSON value.
                 *
                 * You should usually call [Builder.dimensionalPriceGroupId] with a well-typed
                 * [String] value instead. This method is primarily for setting the field to an
                 * undocumented or not yet supported value.
                 */
                fun dimensionalPriceGroupId(dimensionalPriceGroupId: JsonField<String>) = apply {
                    this.dimensionalPriceGroupId = dimensionalPriceGroupId
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): DimensionalPriceConfiguration =
                    DimensionalPriceConfiguration(
                        checkRequired("dimensionValues", dimensionValues).map { it.toImmutable() },
                        checkRequired("dimensionalPriceGroupId", dimensionalPriceGroupId),
                        additionalProperties.toImmutable(),
                    )
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is DimensionalPriceConfiguration && dimensionValues == other.dimensionValues && dimensionalPriceGroupId == other.dimensionalPriceGroupId && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(dimensionValues, dimensionalPriceGroupId, additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "DimensionalPriceConfiguration{dimensionValues=$dimensionValues, dimensionalPriceGroupId=$dimensionalPriceGroupId, additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is CumulativeGroupedBulkPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && cumulativeGroupedBulkConfig == other.cumulativeGroupedBulkConfig && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, cumulativeGroupedBulkConfig, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "CumulativeGroupedBulkPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, cumulativeGroupedBulkConfig=$cumulativeGroupedBulkConfig, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }
}
