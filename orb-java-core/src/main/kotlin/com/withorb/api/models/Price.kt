// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.withorb.api.core.BaseDeserializer
import com.withorb.api.core.BaseSerializer
import com.withorb.api.core.Enum
import com.withorb.api.core.ExcludeMissing
import com.withorb.api.core.JsonField
import com.withorb.api.core.JsonMissing
import com.withorb.api.core.JsonValue
import com.withorb.api.core.checkRequired
import com.withorb.api.core.getOrThrow
import com.withorb.api.core.toImmutable
import com.withorb.api.errors.OrbInvalidDataException
import java.time.OffsetDateTime
import java.util.Collections
import java.util.Objects
import java.util.Optional
import kotlin.jvm.optionals.getOrNull

/**
 * The Price resource represents a price that can be billed on a subscription, resulting in a charge
 * on an invoice in the form of an invoice line item. Prices take a quantity and determine an amount
 * to bill.
 *
 * Orb supports a few different pricing models out of the box. Each of these models is serialized
 * differently in a given Price object. The model_type field determines the key for the
 * configuration object that is present.
 *
 * For more on the types of prices, see
 * [the core concepts documentation](/core-concepts#plan-and-price)
 */
@JsonDeserialize(using = Price.Deserializer::class)
@JsonSerialize(using = Price.Serializer::class)
class Price
private constructor(
    private val unit: Unit? = null,
    private val package_: Package? = null,
    private val matrix: Matrix? = null,
    private val tiered: Tiered? = null,
    private val tieredBps: TieredBps? = null,
    private val bps: Bps? = null,
    private val bulkBps: BulkBps? = null,
    private val bulk: Bulk? = null,
    private val thresholdTotalAmount: ThresholdTotalAmount? = null,
    private val tieredPackage: TieredPackage? = null,
    private val groupedTiered: GroupedTiered? = null,
    private val tieredWithMinimum: TieredWithMinimum? = null,
    private val tieredPackageWithMinimum: TieredPackageWithMinimum? = null,
    private val packageWithAllocation: PackageWithAllocation? = null,
    private val unitWithPercent: UnitWithPercent? = null,
    private val matrixWithAllocation: MatrixWithAllocation? = null,
    private val tieredWithProration: TieredWithProration? = null,
    private val unitWithProration: UnitWithProration? = null,
    private val groupedAllocation: GroupedAllocation? = null,
    private val groupedWithProratedMinimum: GroupedWithProratedMinimum? = null,
    private val groupedWithMeteredMinimum: GroupedWithMeteredMinimum? = null,
    private val matrixWithDisplayName: MatrixWithDisplayName? = null,
    private val bulkWithProration: BulkWithProration? = null,
    private val groupedTieredPackage: GroupedTieredPackage? = null,
    private val maxGroupTieredPackage: MaxGroupTieredPackage? = null,
    private val scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricing? = null,
    private val scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricing? = null,
    private val cumulativeGroupedBulk: CumulativeGroupedBulk? = null,
    private val groupedWithMinMaxThresholds: GroupedWithMinMaxThresholds? = null,
    private val _json: JsonValue? = null,
) {

    fun unit(): Optional<Unit> = Optional.ofNullable(unit)

    fun package_(): Optional<Package> = Optional.ofNullable(package_)

    fun matrix(): Optional<Matrix> = Optional.ofNullable(matrix)

    fun tiered(): Optional<Tiered> = Optional.ofNullable(tiered)

    fun tieredBps(): Optional<TieredBps> = Optional.ofNullable(tieredBps)

    fun bps(): Optional<Bps> = Optional.ofNullable(bps)

    fun bulkBps(): Optional<BulkBps> = Optional.ofNullable(bulkBps)

    fun bulk(): Optional<Bulk> = Optional.ofNullable(bulk)

    fun thresholdTotalAmount(): Optional<ThresholdTotalAmount> =
        Optional.ofNullable(thresholdTotalAmount)

    fun tieredPackage(): Optional<TieredPackage> = Optional.ofNullable(tieredPackage)

    fun groupedTiered(): Optional<GroupedTiered> = Optional.ofNullable(groupedTiered)

    fun tieredWithMinimum(): Optional<TieredWithMinimum> = Optional.ofNullable(tieredWithMinimum)

    fun tieredPackageWithMinimum(): Optional<TieredPackageWithMinimum> =
        Optional.ofNullable(tieredPackageWithMinimum)

    fun packageWithAllocation(): Optional<PackageWithAllocation> =
        Optional.ofNullable(packageWithAllocation)

    fun unitWithPercent(): Optional<UnitWithPercent> = Optional.ofNullable(unitWithPercent)

    fun matrixWithAllocation(): Optional<MatrixWithAllocation> =
        Optional.ofNullable(matrixWithAllocation)

    fun tieredWithProration(): Optional<TieredWithProration> =
        Optional.ofNullable(tieredWithProration)

    fun unitWithProration(): Optional<UnitWithProration> = Optional.ofNullable(unitWithProration)

    fun groupedAllocation(): Optional<GroupedAllocation> = Optional.ofNullable(groupedAllocation)

    fun groupedWithProratedMinimum(): Optional<GroupedWithProratedMinimum> =
        Optional.ofNullable(groupedWithProratedMinimum)

    fun groupedWithMeteredMinimum(): Optional<GroupedWithMeteredMinimum> =
        Optional.ofNullable(groupedWithMeteredMinimum)

    fun matrixWithDisplayName(): Optional<MatrixWithDisplayName> =
        Optional.ofNullable(matrixWithDisplayName)

    fun bulkWithProration(): Optional<BulkWithProration> = Optional.ofNullable(bulkWithProration)

    fun groupedTieredPackage(): Optional<GroupedTieredPackage> =
        Optional.ofNullable(groupedTieredPackage)

    fun maxGroupTieredPackage(): Optional<MaxGroupTieredPackage> =
        Optional.ofNullable(maxGroupTieredPackage)

    fun scalableMatrixWithUnitPricing(): Optional<ScalableMatrixWithUnitPricing> =
        Optional.ofNullable(scalableMatrixWithUnitPricing)

    fun scalableMatrixWithTieredPricing(): Optional<ScalableMatrixWithTieredPricing> =
        Optional.ofNullable(scalableMatrixWithTieredPricing)

    fun cumulativeGroupedBulk(): Optional<CumulativeGroupedBulk> =
        Optional.ofNullable(cumulativeGroupedBulk)

    fun groupedWithMinMaxThresholds(): Optional<GroupedWithMinMaxThresholds> =
        Optional.ofNullable(groupedWithMinMaxThresholds)

    fun isUnit(): Boolean = unit != null

    fun isPackage(): Boolean = package_ != null

    fun isMatrix(): Boolean = matrix != null

    fun isTiered(): Boolean = tiered != null

    fun isTieredBps(): Boolean = tieredBps != null

    fun isBps(): Boolean = bps != null

    fun isBulkBps(): Boolean = bulkBps != null

    fun isBulk(): Boolean = bulk != null

    fun isThresholdTotalAmount(): Boolean = thresholdTotalAmount != null

    fun isTieredPackage(): Boolean = tieredPackage != null

    fun isGroupedTiered(): Boolean = groupedTiered != null

    fun isTieredWithMinimum(): Boolean = tieredWithMinimum != null

    fun isTieredPackageWithMinimum(): Boolean = tieredPackageWithMinimum != null

    fun isPackageWithAllocation(): Boolean = packageWithAllocation != null

    fun isUnitWithPercent(): Boolean = unitWithPercent != null

    fun isMatrixWithAllocation(): Boolean = matrixWithAllocation != null

    fun isTieredWithProration(): Boolean = tieredWithProration != null

    fun isUnitWithProration(): Boolean = unitWithProration != null

    fun isGroupedAllocation(): Boolean = groupedAllocation != null

    fun isGroupedWithProratedMinimum(): Boolean = groupedWithProratedMinimum != null

    fun isGroupedWithMeteredMinimum(): Boolean = groupedWithMeteredMinimum != null

    fun isMatrixWithDisplayName(): Boolean = matrixWithDisplayName != null

    fun isBulkWithProration(): Boolean = bulkWithProration != null

    fun isGroupedTieredPackage(): Boolean = groupedTieredPackage != null

    fun isMaxGroupTieredPackage(): Boolean = maxGroupTieredPackage != null

    fun isScalableMatrixWithUnitPricing(): Boolean = scalableMatrixWithUnitPricing != null

    fun isScalableMatrixWithTieredPricing(): Boolean = scalableMatrixWithTieredPricing != null

    fun isCumulativeGroupedBulk(): Boolean = cumulativeGroupedBulk != null

    fun isGroupedWithMinMaxThresholds(): Boolean = groupedWithMinMaxThresholds != null

    fun asUnit(): Unit = unit.getOrThrow("unit")

    fun asPackage(): Package = package_.getOrThrow("package_")

    fun asMatrix(): Matrix = matrix.getOrThrow("matrix")

    fun asTiered(): Tiered = tiered.getOrThrow("tiered")

    fun asTieredBps(): TieredBps = tieredBps.getOrThrow("tieredBps")

    fun asBps(): Bps = bps.getOrThrow("bps")

    fun asBulkBps(): BulkBps = bulkBps.getOrThrow("bulkBps")

    fun asBulk(): Bulk = bulk.getOrThrow("bulk")

    fun asThresholdTotalAmount(): ThresholdTotalAmount =
        thresholdTotalAmount.getOrThrow("thresholdTotalAmount")

    fun asTieredPackage(): TieredPackage = tieredPackage.getOrThrow("tieredPackage")

    fun asGroupedTiered(): GroupedTiered = groupedTiered.getOrThrow("groupedTiered")

    fun asTieredWithMinimum(): TieredWithMinimum = tieredWithMinimum.getOrThrow("tieredWithMinimum")

    fun asTieredPackageWithMinimum(): TieredPackageWithMinimum =
        tieredPackageWithMinimum.getOrThrow("tieredPackageWithMinimum")

    fun asPackageWithAllocation(): PackageWithAllocation =
        packageWithAllocation.getOrThrow("packageWithAllocation")

    fun asUnitWithPercent(): UnitWithPercent = unitWithPercent.getOrThrow("unitWithPercent")

    fun asMatrixWithAllocation(): MatrixWithAllocation =
        matrixWithAllocation.getOrThrow("matrixWithAllocation")

    fun asTieredWithProration(): TieredWithProration =
        tieredWithProration.getOrThrow("tieredWithProration")

    fun asUnitWithProration(): UnitWithProration = unitWithProration.getOrThrow("unitWithProration")

    fun asGroupedAllocation(): GroupedAllocation = groupedAllocation.getOrThrow("groupedAllocation")

    fun asGroupedWithProratedMinimum(): GroupedWithProratedMinimum =
        groupedWithProratedMinimum.getOrThrow("groupedWithProratedMinimum")

    fun asGroupedWithMeteredMinimum(): GroupedWithMeteredMinimum =
        groupedWithMeteredMinimum.getOrThrow("groupedWithMeteredMinimum")

    fun asMatrixWithDisplayName(): MatrixWithDisplayName =
        matrixWithDisplayName.getOrThrow("matrixWithDisplayName")

    fun asBulkWithProration(): BulkWithProration = bulkWithProration.getOrThrow("bulkWithProration")

    fun asGroupedTieredPackage(): GroupedTieredPackage =
        groupedTieredPackage.getOrThrow("groupedTieredPackage")

    fun asMaxGroupTieredPackage(): MaxGroupTieredPackage =
        maxGroupTieredPackage.getOrThrow("maxGroupTieredPackage")

    fun asScalableMatrixWithUnitPricing(): ScalableMatrixWithUnitPricing =
        scalableMatrixWithUnitPricing.getOrThrow("scalableMatrixWithUnitPricing")

    fun asScalableMatrixWithTieredPricing(): ScalableMatrixWithTieredPricing =
        scalableMatrixWithTieredPricing.getOrThrow("scalableMatrixWithTieredPricing")

    fun asCumulativeGroupedBulk(): CumulativeGroupedBulk =
        cumulativeGroupedBulk.getOrThrow("cumulativeGroupedBulk")

    fun asGroupedWithMinMaxThresholds(): GroupedWithMinMaxThresholds =
        groupedWithMinMaxThresholds.getOrThrow("groupedWithMinMaxThresholds")

    fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

    fun <T> accept(visitor: Visitor<T>): T =
        when {
            unit != null -> visitor.visitUnit(unit)
            package_ != null -> visitor.visitPackage(package_)
            matrix != null -> visitor.visitMatrix(matrix)
            tiered != null -> visitor.visitTiered(tiered)
            tieredBps != null -> visitor.visitTieredBps(tieredBps)
            bps != null -> visitor.visitBps(bps)
            bulkBps != null -> visitor.visitBulkBps(bulkBps)
            bulk != null -> visitor.visitBulk(bulk)
            thresholdTotalAmount != null -> visitor.visitThresholdTotalAmount(thresholdTotalAmount)
            tieredPackage != null -> visitor.visitTieredPackage(tieredPackage)
            groupedTiered != null -> visitor.visitGroupedTiered(groupedTiered)
            tieredWithMinimum != null -> visitor.visitTieredWithMinimum(tieredWithMinimum)
            tieredPackageWithMinimum != null ->
                visitor.visitTieredPackageWithMinimum(tieredPackageWithMinimum)
            packageWithAllocation != null ->
                visitor.visitPackageWithAllocation(packageWithAllocation)
            unitWithPercent != null -> visitor.visitUnitWithPercent(unitWithPercent)
            matrixWithAllocation != null -> visitor.visitMatrixWithAllocation(matrixWithAllocation)
            tieredWithProration != null -> visitor.visitTieredWithProration(tieredWithProration)
            unitWithProration != null -> visitor.visitUnitWithProration(unitWithProration)
            groupedAllocation != null -> visitor.visitGroupedAllocation(groupedAllocation)
            groupedWithProratedMinimum != null ->
                visitor.visitGroupedWithProratedMinimum(groupedWithProratedMinimum)
            groupedWithMeteredMinimum != null ->
                visitor.visitGroupedWithMeteredMinimum(groupedWithMeteredMinimum)
            matrixWithDisplayName != null ->
                visitor.visitMatrixWithDisplayName(matrixWithDisplayName)
            bulkWithProration != null -> visitor.visitBulkWithProration(bulkWithProration)
            groupedTieredPackage != null -> visitor.visitGroupedTieredPackage(groupedTieredPackage)
            maxGroupTieredPackage != null ->
                visitor.visitMaxGroupTieredPackage(maxGroupTieredPackage)
            scalableMatrixWithUnitPricing != null ->
                visitor.visitScalableMatrixWithUnitPricing(scalableMatrixWithUnitPricing)
            scalableMatrixWithTieredPricing != null ->
                visitor.visitScalableMatrixWithTieredPricing(scalableMatrixWithTieredPricing)
            cumulativeGroupedBulk != null ->
                visitor.visitCumulativeGroupedBulk(cumulativeGroupedBulk)
            groupedWithMinMaxThresholds != null ->
                visitor.visitGroupedWithMinMaxThresholds(groupedWithMinMaxThresholds)
            else -> visitor.unknown(_json)
        }

    private var validated: Boolean = false

    fun validate(): Price = apply {
        if (validated) {
            return@apply
        }

        accept(
            object : Visitor<Unit> {
                override fun visitUnit(unit: Unit) {
                    unit.validate()
                }

                override fun visitPackage(package_: Package) {
                    package_.validate()
                }

                override fun visitMatrix(matrix: Matrix) {
                    matrix.validate()
                }

                override fun visitTiered(tiered: Tiered) {
                    tiered.validate()
                }

                override fun visitTieredBps(tieredBps: TieredBps) {
                    tieredBps.validate()
                }

                override fun visitBps(bps: Bps) {
                    bps.validate()
                }

                override fun visitBulkBps(bulkBps: BulkBps) {
                    bulkBps.validate()
                }

                override fun visitBulk(bulk: Bulk) {
                    bulk.validate()
                }

                override fun visitThresholdTotalAmount(thresholdTotalAmount: ThresholdTotalAmount) {
                    thresholdTotalAmount.validate()
                }

                override fun visitTieredPackage(tieredPackage: TieredPackage) {
                    tieredPackage.validate()
                }

                override fun visitGroupedTiered(groupedTiered: GroupedTiered) {
                    groupedTiered.validate()
                }

                override fun visitTieredWithMinimum(tieredWithMinimum: TieredWithMinimum) {
                    tieredWithMinimum.validate()
                }

                override fun visitTieredPackageWithMinimum(
                    tieredPackageWithMinimum: TieredPackageWithMinimum
                ) {
                    tieredPackageWithMinimum.validate()
                }

                override fun visitPackageWithAllocation(
                    packageWithAllocation: PackageWithAllocation
                ) {
                    packageWithAllocation.validate()
                }

                override fun visitUnitWithPercent(unitWithPercent: UnitWithPercent) {
                    unitWithPercent.validate()
                }

                override fun visitMatrixWithAllocation(matrixWithAllocation: MatrixWithAllocation) {
                    matrixWithAllocation.validate()
                }

                override fun visitTieredWithProration(tieredWithProration: TieredWithProration) {
                    tieredWithProration.validate()
                }

                override fun visitUnitWithProration(unitWithProration: UnitWithProration) {
                    unitWithProration.validate()
                }

                override fun visitGroupedAllocation(groupedAllocation: GroupedAllocation) {
                    groupedAllocation.validate()
                }

                override fun visitGroupedWithProratedMinimum(
                    groupedWithProratedMinimum: GroupedWithProratedMinimum
                ) {
                    groupedWithProratedMinimum.validate()
                }

                override fun visitGroupedWithMeteredMinimum(
                    groupedWithMeteredMinimum: GroupedWithMeteredMinimum
                ) {
                    groupedWithMeteredMinimum.validate()
                }

                override fun visitMatrixWithDisplayName(
                    matrixWithDisplayName: MatrixWithDisplayName
                ) {
                    matrixWithDisplayName.validate()
                }

                override fun visitBulkWithProration(bulkWithProration: BulkWithProration) {
                    bulkWithProration.validate()
                }

                override fun visitGroupedTieredPackage(groupedTieredPackage: GroupedTieredPackage) {
                    groupedTieredPackage.validate()
                }

                override fun visitMaxGroupTieredPackage(
                    maxGroupTieredPackage: MaxGroupTieredPackage
                ) {
                    maxGroupTieredPackage.validate()
                }

                override fun visitScalableMatrixWithUnitPricing(
                    scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricing
                ) {
                    scalableMatrixWithUnitPricing.validate()
                }

                override fun visitScalableMatrixWithTieredPricing(
                    scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricing
                ) {
                    scalableMatrixWithTieredPricing.validate()
                }

                override fun visitCumulativeGroupedBulk(
                    cumulativeGroupedBulk: CumulativeGroupedBulk
                ) {
                    cumulativeGroupedBulk.validate()
                }

                override fun visitGroupedWithMinMaxThresholds(
                    groupedWithMinMaxThresholds: GroupedWithMinMaxThresholds
                ) {
                    groupedWithMinMaxThresholds.validate()
                }
            }
        )
        validated = true
    }

    fun isValid(): Boolean =
        try {
            validate()
            true
        } catch (e: OrbInvalidDataException) {
            false
        }

    /**
     * Returns a score indicating how many valid values are contained in this object recursively.
     *
     * Used for best match union deserialization.
     */
    @JvmSynthetic
    internal fun validity(): Int =
        accept(
            object : Visitor<Int> {
                override fun visitUnit(unit: Unit) = unit.validity()

                override fun visitPackage(package_: Package) = package_.validity()

                override fun visitMatrix(matrix: Matrix) = matrix.validity()

                override fun visitTiered(tiered: Tiered) = tiered.validity()

                override fun visitTieredBps(tieredBps: TieredBps) = tieredBps.validity()

                override fun visitBps(bps: Bps) = bps.validity()

                override fun visitBulkBps(bulkBps: BulkBps) = bulkBps.validity()

                override fun visitBulk(bulk: Bulk) = bulk.validity()

                override fun visitThresholdTotalAmount(thresholdTotalAmount: ThresholdTotalAmount) =
                    thresholdTotalAmount.validity()

                override fun visitTieredPackage(tieredPackage: TieredPackage) =
                    tieredPackage.validity()

                override fun visitGroupedTiered(groupedTiered: GroupedTiered) =
                    groupedTiered.validity()

                override fun visitTieredWithMinimum(tieredWithMinimum: TieredWithMinimum) =
                    tieredWithMinimum.validity()

                override fun visitTieredPackageWithMinimum(
                    tieredPackageWithMinimum: TieredPackageWithMinimum
                ) = tieredPackageWithMinimum.validity()

                override fun visitPackageWithAllocation(
                    packageWithAllocation: PackageWithAllocation
                ) = packageWithAllocation.validity()

                override fun visitUnitWithPercent(unitWithPercent: UnitWithPercent) =
                    unitWithPercent.validity()

                override fun visitMatrixWithAllocation(matrixWithAllocation: MatrixWithAllocation) =
                    matrixWithAllocation.validity()

                override fun visitTieredWithProration(tieredWithProration: TieredWithProration) =
                    tieredWithProration.validity()

                override fun visitUnitWithProration(unitWithProration: UnitWithProration) =
                    unitWithProration.validity()

                override fun visitGroupedAllocation(groupedAllocation: GroupedAllocation) =
                    groupedAllocation.validity()

                override fun visitGroupedWithProratedMinimum(
                    groupedWithProratedMinimum: GroupedWithProratedMinimum
                ) = groupedWithProratedMinimum.validity()

                override fun visitGroupedWithMeteredMinimum(
                    groupedWithMeteredMinimum: GroupedWithMeteredMinimum
                ) = groupedWithMeteredMinimum.validity()

                override fun visitMatrixWithDisplayName(
                    matrixWithDisplayName: MatrixWithDisplayName
                ) = matrixWithDisplayName.validity()

                override fun visitBulkWithProration(bulkWithProration: BulkWithProration) =
                    bulkWithProration.validity()

                override fun visitGroupedTieredPackage(groupedTieredPackage: GroupedTieredPackage) =
                    groupedTieredPackage.validity()

                override fun visitMaxGroupTieredPackage(
                    maxGroupTieredPackage: MaxGroupTieredPackage
                ) = maxGroupTieredPackage.validity()

                override fun visitScalableMatrixWithUnitPricing(
                    scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricing
                ) = scalableMatrixWithUnitPricing.validity()

                override fun visitScalableMatrixWithTieredPricing(
                    scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricing
                ) = scalableMatrixWithTieredPricing.validity()

                override fun visitCumulativeGroupedBulk(
                    cumulativeGroupedBulk: CumulativeGroupedBulk
                ) = cumulativeGroupedBulk.validity()

                override fun visitGroupedWithMinMaxThresholds(
                    groupedWithMinMaxThresholds: GroupedWithMinMaxThresholds
                ) = groupedWithMinMaxThresholds.validity()

                override fun unknown(json: JsonValue?) = 0
            }
        )

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return /* spotless:off */ other is Price && unit == other.unit && package_ == other.package_ && matrix == other.matrix && tiered == other.tiered && tieredBps == other.tieredBps && bps == other.bps && bulkBps == other.bulkBps && bulk == other.bulk && thresholdTotalAmount == other.thresholdTotalAmount && tieredPackage == other.tieredPackage && groupedTiered == other.groupedTiered && tieredWithMinimum == other.tieredWithMinimum && tieredPackageWithMinimum == other.tieredPackageWithMinimum && packageWithAllocation == other.packageWithAllocation && unitWithPercent == other.unitWithPercent && matrixWithAllocation == other.matrixWithAllocation && tieredWithProration == other.tieredWithProration && unitWithProration == other.unitWithProration && groupedAllocation == other.groupedAllocation && groupedWithProratedMinimum == other.groupedWithProratedMinimum && groupedWithMeteredMinimum == other.groupedWithMeteredMinimum && matrixWithDisplayName == other.matrixWithDisplayName && bulkWithProration == other.bulkWithProration && groupedTieredPackage == other.groupedTieredPackage && maxGroupTieredPackage == other.maxGroupTieredPackage && scalableMatrixWithUnitPricing == other.scalableMatrixWithUnitPricing && scalableMatrixWithTieredPricing == other.scalableMatrixWithTieredPricing && cumulativeGroupedBulk == other.cumulativeGroupedBulk && groupedWithMinMaxThresholds == other.groupedWithMinMaxThresholds /* spotless:on */
    }

    override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, package_, matrix, tiered, tieredBps, bps, bulkBps, bulk, thresholdTotalAmount, tieredPackage, groupedTiered, tieredWithMinimum, tieredPackageWithMinimum, packageWithAllocation, unitWithPercent, matrixWithAllocation, tieredWithProration, unitWithProration, groupedAllocation, groupedWithProratedMinimum, groupedWithMeteredMinimum, matrixWithDisplayName, bulkWithProration, groupedTieredPackage, maxGroupTieredPackage, scalableMatrixWithUnitPricing, scalableMatrixWithTieredPricing, cumulativeGroupedBulk, groupedWithMinMaxThresholds) /* spotless:on */

    override fun toString(): String =
        when {
            unit != null -> "Price{unit=$unit}"
            package_ != null -> "Price{package_=$package_}"
            matrix != null -> "Price{matrix=$matrix}"
            tiered != null -> "Price{tiered=$tiered}"
            tieredBps != null -> "Price{tieredBps=$tieredBps}"
            bps != null -> "Price{bps=$bps}"
            bulkBps != null -> "Price{bulkBps=$bulkBps}"
            bulk != null -> "Price{bulk=$bulk}"
            thresholdTotalAmount != null -> "Price{thresholdTotalAmount=$thresholdTotalAmount}"
            tieredPackage != null -> "Price{tieredPackage=$tieredPackage}"
            groupedTiered != null -> "Price{groupedTiered=$groupedTiered}"
            tieredWithMinimum != null -> "Price{tieredWithMinimum=$tieredWithMinimum}"
            tieredPackageWithMinimum != null ->
                "Price{tieredPackageWithMinimum=$tieredPackageWithMinimum}"
            packageWithAllocation != null -> "Price{packageWithAllocation=$packageWithAllocation}"
            unitWithPercent != null -> "Price{unitWithPercent=$unitWithPercent}"
            matrixWithAllocation != null -> "Price{matrixWithAllocation=$matrixWithAllocation}"
            tieredWithProration != null -> "Price{tieredWithProration=$tieredWithProration}"
            unitWithProration != null -> "Price{unitWithProration=$unitWithProration}"
            groupedAllocation != null -> "Price{groupedAllocation=$groupedAllocation}"
            groupedWithProratedMinimum != null ->
                "Price{groupedWithProratedMinimum=$groupedWithProratedMinimum}"
            groupedWithMeteredMinimum != null ->
                "Price{groupedWithMeteredMinimum=$groupedWithMeteredMinimum}"
            matrixWithDisplayName != null -> "Price{matrixWithDisplayName=$matrixWithDisplayName}"
            bulkWithProration != null -> "Price{bulkWithProration=$bulkWithProration}"
            groupedTieredPackage != null -> "Price{groupedTieredPackage=$groupedTieredPackage}"
            maxGroupTieredPackage != null -> "Price{maxGroupTieredPackage=$maxGroupTieredPackage}"
            scalableMatrixWithUnitPricing != null ->
                "Price{scalableMatrixWithUnitPricing=$scalableMatrixWithUnitPricing}"
            scalableMatrixWithTieredPricing != null ->
                "Price{scalableMatrixWithTieredPricing=$scalableMatrixWithTieredPricing}"
            cumulativeGroupedBulk != null -> "Price{cumulativeGroupedBulk=$cumulativeGroupedBulk}"
            groupedWithMinMaxThresholds != null ->
                "Price{groupedWithMinMaxThresholds=$groupedWithMinMaxThresholds}"
            _json != null -> "Price{_unknown=$_json}"
            else -> throw IllegalStateException("Invalid Price")
        }

    companion object {

        @JvmStatic fun ofUnit(unit: Unit) = Price(unit = unit)

        @JvmStatic fun ofPackage(package_: Package) = Price(package_ = package_)

        @JvmStatic fun ofMatrix(matrix: Matrix) = Price(matrix = matrix)

        @JvmStatic fun ofTiered(tiered: Tiered) = Price(tiered = tiered)

        @JvmStatic fun ofTieredBps(tieredBps: TieredBps) = Price(tieredBps = tieredBps)

        @JvmStatic fun ofBps(bps: Bps) = Price(bps = bps)

        @JvmStatic fun ofBulkBps(bulkBps: BulkBps) = Price(bulkBps = bulkBps)

        @JvmStatic fun ofBulk(bulk: Bulk) = Price(bulk = bulk)

        @JvmStatic
        fun ofThresholdTotalAmount(thresholdTotalAmount: ThresholdTotalAmount) =
            Price(thresholdTotalAmount = thresholdTotalAmount)

        @JvmStatic
        fun ofTieredPackage(tieredPackage: TieredPackage) = Price(tieredPackage = tieredPackage)

        @JvmStatic
        fun ofGroupedTiered(groupedTiered: GroupedTiered) = Price(groupedTiered = groupedTiered)

        @JvmStatic
        fun ofTieredWithMinimum(tieredWithMinimum: TieredWithMinimum) =
            Price(tieredWithMinimum = tieredWithMinimum)

        @JvmStatic
        fun ofTieredPackageWithMinimum(tieredPackageWithMinimum: TieredPackageWithMinimum) =
            Price(tieredPackageWithMinimum = tieredPackageWithMinimum)

        @JvmStatic
        fun ofPackageWithAllocation(packageWithAllocation: PackageWithAllocation) =
            Price(packageWithAllocation = packageWithAllocation)

        @JvmStatic
        fun ofUnitWithPercent(unitWithPercent: UnitWithPercent) =
            Price(unitWithPercent = unitWithPercent)

        @JvmStatic
        fun ofMatrixWithAllocation(matrixWithAllocation: MatrixWithAllocation) =
            Price(matrixWithAllocation = matrixWithAllocation)

        @JvmStatic
        fun ofTieredWithProration(tieredWithProration: TieredWithProration) =
            Price(tieredWithProration = tieredWithProration)

        @JvmStatic
        fun ofUnitWithProration(unitWithProration: UnitWithProration) =
            Price(unitWithProration = unitWithProration)

        @JvmStatic
        fun ofGroupedAllocation(groupedAllocation: GroupedAllocation) =
            Price(groupedAllocation = groupedAllocation)

        @JvmStatic
        fun ofGroupedWithProratedMinimum(groupedWithProratedMinimum: GroupedWithProratedMinimum) =
            Price(groupedWithProratedMinimum = groupedWithProratedMinimum)

        @JvmStatic
        fun ofGroupedWithMeteredMinimum(groupedWithMeteredMinimum: GroupedWithMeteredMinimum) =
            Price(groupedWithMeteredMinimum = groupedWithMeteredMinimum)

        @JvmStatic
        fun ofMatrixWithDisplayName(matrixWithDisplayName: MatrixWithDisplayName) =
            Price(matrixWithDisplayName = matrixWithDisplayName)

        @JvmStatic
        fun ofBulkWithProration(bulkWithProration: BulkWithProration) =
            Price(bulkWithProration = bulkWithProration)

        @JvmStatic
        fun ofGroupedTieredPackage(groupedTieredPackage: GroupedTieredPackage) =
            Price(groupedTieredPackage = groupedTieredPackage)

        @JvmStatic
        fun ofMaxGroupTieredPackage(maxGroupTieredPackage: MaxGroupTieredPackage) =
            Price(maxGroupTieredPackage = maxGroupTieredPackage)

        @JvmStatic
        fun ofScalableMatrixWithUnitPricing(
            scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricing
        ) = Price(scalableMatrixWithUnitPricing = scalableMatrixWithUnitPricing)

        @JvmStatic
        fun ofScalableMatrixWithTieredPricing(
            scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricing
        ) = Price(scalableMatrixWithTieredPricing = scalableMatrixWithTieredPricing)

        @JvmStatic
        fun ofCumulativeGroupedBulk(cumulativeGroupedBulk: CumulativeGroupedBulk) =
            Price(cumulativeGroupedBulk = cumulativeGroupedBulk)

        @JvmStatic
        fun ofGroupedWithMinMaxThresholds(
            groupedWithMinMaxThresholds: GroupedWithMinMaxThresholds
        ) = Price(groupedWithMinMaxThresholds = groupedWithMinMaxThresholds)
    }

    /** An interface that defines how to map each variant of [Price] to a value of type [T]. */
    interface Visitor<out T> {

        fun visitUnit(unit: Unit): T

        fun visitPackage(package_: Package): T

        fun visitMatrix(matrix: Matrix): T

        fun visitTiered(tiered: Tiered): T

        fun visitTieredBps(tieredBps: TieredBps): T

        fun visitBps(bps: Bps): T

        fun visitBulkBps(bulkBps: BulkBps): T

        fun visitBulk(bulk: Bulk): T

        fun visitThresholdTotalAmount(thresholdTotalAmount: ThresholdTotalAmount): T

        fun visitTieredPackage(tieredPackage: TieredPackage): T

        fun visitGroupedTiered(groupedTiered: GroupedTiered): T

        fun visitTieredWithMinimum(tieredWithMinimum: TieredWithMinimum): T

        fun visitTieredPackageWithMinimum(tieredPackageWithMinimum: TieredPackageWithMinimum): T

        fun visitPackageWithAllocation(packageWithAllocation: PackageWithAllocation): T

        fun visitUnitWithPercent(unitWithPercent: UnitWithPercent): T

        fun visitMatrixWithAllocation(matrixWithAllocation: MatrixWithAllocation): T

        fun visitTieredWithProration(tieredWithProration: TieredWithProration): T

        fun visitUnitWithProration(unitWithProration: UnitWithProration): T

        fun visitGroupedAllocation(groupedAllocation: GroupedAllocation): T

        fun visitGroupedWithProratedMinimum(
            groupedWithProratedMinimum: GroupedWithProratedMinimum
        ): T

        fun visitGroupedWithMeteredMinimum(groupedWithMeteredMinimum: GroupedWithMeteredMinimum): T

        fun visitMatrixWithDisplayName(matrixWithDisplayName: MatrixWithDisplayName): T

        fun visitBulkWithProration(bulkWithProration: BulkWithProration): T

        fun visitGroupedTieredPackage(groupedTieredPackage: GroupedTieredPackage): T

        fun visitMaxGroupTieredPackage(maxGroupTieredPackage: MaxGroupTieredPackage): T

        fun visitScalableMatrixWithUnitPricing(
            scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricing
        ): T

        fun visitScalableMatrixWithTieredPricing(
            scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricing
        ): T

        fun visitCumulativeGroupedBulk(cumulativeGroupedBulk: CumulativeGroupedBulk): T

        fun visitGroupedWithMinMaxThresholds(
            groupedWithMinMaxThresholds: GroupedWithMinMaxThresholds
        ): T

        /**
         * Maps an unknown variant of [Price] to a value of type [T].
         *
         * An instance of [Price] can contain an unknown variant if it was deserialized from data
         * that doesn't match any known variant. For example, if the SDK is on an older version than
         * the API, then the API may respond with new variants that the SDK is unaware of.
         *
         * @throws OrbInvalidDataException in the default implementation.
         */
        fun unknown(json: JsonValue?): T {
            throw OrbInvalidDataException("Unknown Price: $json")
        }
    }

    internal class Deserializer : BaseDeserializer<Price>(Price::class) {

        override fun ObjectCodec.deserialize(node: JsonNode): Price {
            val json = JsonValue.fromJsonNode(node)
            val modelType = json.asObject().getOrNull()?.get("model_type")?.asString()?.getOrNull()

            when (modelType) {
                "unit" -> {
                    return tryDeserialize(node, jacksonTypeRef<Unit>())?.let {
                        Price(unit = it, _json = json)
                    } ?: Price(_json = json)
                }
                "package" -> {
                    return tryDeserialize(node, jacksonTypeRef<Package>())?.let {
                        Price(package_ = it, _json = json)
                    } ?: Price(_json = json)
                }
                "matrix" -> {
                    return tryDeserialize(node, jacksonTypeRef<Matrix>())?.let {
                        Price(matrix = it, _json = json)
                    } ?: Price(_json = json)
                }
                "tiered" -> {
                    return tryDeserialize(node, jacksonTypeRef<Tiered>())?.let {
                        Price(tiered = it, _json = json)
                    } ?: Price(_json = json)
                }
                "tiered_bps" -> {
                    return tryDeserialize(node, jacksonTypeRef<TieredBps>())?.let {
                        Price(tieredBps = it, _json = json)
                    } ?: Price(_json = json)
                }
                "bps" -> {
                    return tryDeserialize(node, jacksonTypeRef<Bps>())?.let {
                        Price(bps = it, _json = json)
                    } ?: Price(_json = json)
                }
                "bulk_bps" -> {
                    return tryDeserialize(node, jacksonTypeRef<BulkBps>())?.let {
                        Price(bulkBps = it, _json = json)
                    } ?: Price(_json = json)
                }
                "bulk" -> {
                    return tryDeserialize(node, jacksonTypeRef<Bulk>())?.let {
                        Price(bulk = it, _json = json)
                    } ?: Price(_json = json)
                }
                "threshold_total_amount" -> {
                    return tryDeserialize(node, jacksonTypeRef<ThresholdTotalAmount>())?.let {
                        Price(thresholdTotalAmount = it, _json = json)
                    } ?: Price(_json = json)
                }
                "tiered_package" -> {
                    return tryDeserialize(node, jacksonTypeRef<TieredPackage>())?.let {
                        Price(tieredPackage = it, _json = json)
                    } ?: Price(_json = json)
                }
                "grouped_tiered" -> {
                    return tryDeserialize(node, jacksonTypeRef<GroupedTiered>())?.let {
                        Price(groupedTiered = it, _json = json)
                    } ?: Price(_json = json)
                }
                "tiered_with_minimum" -> {
                    return tryDeserialize(node, jacksonTypeRef<TieredWithMinimum>())?.let {
                        Price(tieredWithMinimum = it, _json = json)
                    } ?: Price(_json = json)
                }
                "tiered_package_with_minimum" -> {
                    return tryDeserialize(node, jacksonTypeRef<TieredPackageWithMinimum>())?.let {
                        Price(tieredPackageWithMinimum = it, _json = json)
                    } ?: Price(_json = json)
                }
                "package_with_allocation" -> {
                    return tryDeserialize(node, jacksonTypeRef<PackageWithAllocation>())?.let {
                        Price(packageWithAllocation = it, _json = json)
                    } ?: Price(_json = json)
                }
                "unit_with_percent" -> {
                    return tryDeserialize(node, jacksonTypeRef<UnitWithPercent>())?.let {
                        Price(unitWithPercent = it, _json = json)
                    } ?: Price(_json = json)
                }
                "matrix_with_allocation" -> {
                    return tryDeserialize(node, jacksonTypeRef<MatrixWithAllocation>())?.let {
                        Price(matrixWithAllocation = it, _json = json)
                    } ?: Price(_json = json)
                }
                "tiered_with_proration" -> {
                    return tryDeserialize(node, jacksonTypeRef<TieredWithProration>())?.let {
                        Price(tieredWithProration = it, _json = json)
                    } ?: Price(_json = json)
                }
                "unit_with_proration" -> {
                    return tryDeserialize(node, jacksonTypeRef<UnitWithProration>())?.let {
                        Price(unitWithProration = it, _json = json)
                    } ?: Price(_json = json)
                }
                "grouped_allocation" -> {
                    return tryDeserialize(node, jacksonTypeRef<GroupedAllocation>())?.let {
                        Price(groupedAllocation = it, _json = json)
                    } ?: Price(_json = json)
                }
                "grouped_with_prorated_minimum" -> {
                    return tryDeserialize(node, jacksonTypeRef<GroupedWithProratedMinimum>())?.let {
                        Price(groupedWithProratedMinimum = it, _json = json)
                    } ?: Price(_json = json)
                }
                "grouped_with_metered_minimum" -> {
                    return tryDeserialize(node, jacksonTypeRef<GroupedWithMeteredMinimum>())?.let {
                        Price(groupedWithMeteredMinimum = it, _json = json)
                    } ?: Price(_json = json)
                }
                "matrix_with_display_name" -> {
                    return tryDeserialize(node, jacksonTypeRef<MatrixWithDisplayName>())?.let {
                        Price(matrixWithDisplayName = it, _json = json)
                    } ?: Price(_json = json)
                }
                "bulk_with_proration" -> {
                    return tryDeserialize(node, jacksonTypeRef<BulkWithProration>())?.let {
                        Price(bulkWithProration = it, _json = json)
                    } ?: Price(_json = json)
                }
                "grouped_tiered_package" -> {
                    return tryDeserialize(node, jacksonTypeRef<GroupedTieredPackage>())?.let {
                        Price(groupedTieredPackage = it, _json = json)
                    } ?: Price(_json = json)
                }
                "max_group_tiered_package" -> {
                    return tryDeserialize(node, jacksonTypeRef<MaxGroupTieredPackage>())?.let {
                        Price(maxGroupTieredPackage = it, _json = json)
                    } ?: Price(_json = json)
                }
                "scalable_matrix_with_unit_pricing" -> {
                    return tryDeserialize(node, jacksonTypeRef<ScalableMatrixWithUnitPricing>())
                        ?.let { Price(scalableMatrixWithUnitPricing = it, _json = json) }
                        ?: Price(_json = json)
                }
                "scalable_matrix_with_tiered_pricing" -> {
                    return tryDeserialize(node, jacksonTypeRef<ScalableMatrixWithTieredPricing>())
                        ?.let { Price(scalableMatrixWithTieredPricing = it, _json = json) }
                        ?: Price(_json = json)
                }
                "cumulative_grouped_bulk" -> {
                    return tryDeserialize(node, jacksonTypeRef<CumulativeGroupedBulk>())?.let {
                        Price(cumulativeGroupedBulk = it, _json = json)
                    } ?: Price(_json = json)
                }
                "grouped_with_min_max_thresholds" -> {
                    return tryDeserialize(node, jacksonTypeRef<GroupedWithMinMaxThresholds>())
                        ?.let { Price(groupedWithMinMaxThresholds = it, _json = json) }
                        ?: Price(_json = json)
                }
            }

            return Price(_json = json)
        }
    }

    internal class Serializer : BaseSerializer<Price>(Price::class) {

        override fun serialize(
            value: Price,
            generator: JsonGenerator,
            provider: SerializerProvider,
        ) {
            when {
                value.unit != null -> generator.writeObject(value.unit)
                value.package_ != null -> generator.writeObject(value.package_)
                value.matrix != null -> generator.writeObject(value.matrix)
                value.tiered != null -> generator.writeObject(value.tiered)
                value.tieredBps != null -> generator.writeObject(value.tieredBps)
                value.bps != null -> generator.writeObject(value.bps)
                value.bulkBps != null -> generator.writeObject(value.bulkBps)
                value.bulk != null -> generator.writeObject(value.bulk)
                value.thresholdTotalAmount != null ->
                    generator.writeObject(value.thresholdTotalAmount)
                value.tieredPackage != null -> generator.writeObject(value.tieredPackage)
                value.groupedTiered != null -> generator.writeObject(value.groupedTiered)
                value.tieredWithMinimum != null -> generator.writeObject(value.tieredWithMinimum)
                value.tieredPackageWithMinimum != null ->
                    generator.writeObject(value.tieredPackageWithMinimum)
                value.packageWithAllocation != null ->
                    generator.writeObject(value.packageWithAllocation)
                value.unitWithPercent != null -> generator.writeObject(value.unitWithPercent)
                value.matrixWithAllocation != null ->
                    generator.writeObject(value.matrixWithAllocation)
                value.tieredWithProration != null ->
                    generator.writeObject(value.tieredWithProration)
                value.unitWithProration != null -> generator.writeObject(value.unitWithProration)
                value.groupedAllocation != null -> generator.writeObject(value.groupedAllocation)
                value.groupedWithProratedMinimum != null ->
                    generator.writeObject(value.groupedWithProratedMinimum)
                value.groupedWithMeteredMinimum != null ->
                    generator.writeObject(value.groupedWithMeteredMinimum)
                value.matrixWithDisplayName != null ->
                    generator.writeObject(value.matrixWithDisplayName)
                value.bulkWithProration != null -> generator.writeObject(value.bulkWithProration)
                value.groupedTieredPackage != null ->
                    generator.writeObject(value.groupedTieredPackage)
                value.maxGroupTieredPackage != null ->
                    generator.writeObject(value.maxGroupTieredPackage)
                value.scalableMatrixWithUnitPricing != null ->
                    generator.writeObject(value.scalableMatrixWithUnitPricing)
                value.scalableMatrixWithTieredPricing != null ->
                    generator.writeObject(value.scalableMatrixWithTieredPricing)
                value.cumulativeGroupedBulk != null ->
                    generator.writeObject(value.cumulativeGroupedBulk)
                value.groupedWithMinMaxThresholds != null ->
                    generator.writeObject(value.groupedWithMinMaxThresholds)
                value._json != null -> generator.writeObject(value._json)
                else -> throw IllegalStateException("Invalid Price")
            }
        }
    }

    class Unit
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val unitConfig: JsonField<UnitConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("unit_config")
            @ExcludeMissing
            unitConfig: JsonField<UnitConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            unitConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("unit")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun unitConfig(): UnitConfig = unitConfig.getRequired("unit_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [unitConfig].
         *
         * Unlike [unitConfig], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("unit_config")
        @ExcludeMissing
        fun _unitConfig(): JsonField<UnitConfig> = unitConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Unit].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .unitConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [Unit]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("unit")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var unitConfig: JsonField<UnitConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(unit: Unit) = apply {
                id = unit.id
                billableMetric = unit.billableMetric
                billingCycleConfiguration = unit.billingCycleConfiguration
                cadence = unit.cadence
                conversionRate = unit.conversionRate
                conversionRateConfig = unit.conversionRateConfig
                createdAt = unit.createdAt
                creditAllocation = unit.creditAllocation
                currency = unit.currency
                discount = unit.discount
                externalPriceId = unit.externalPriceId
                fixedPriceQuantity = unit.fixedPriceQuantity
                invoicingCycleConfiguration = unit.invoicingCycleConfiguration
                item = unit.item
                maximum = unit.maximum
                maximumAmount = unit.maximumAmount
                metadata = unit.metadata
                minimum = unit.minimum
                minimumAmount = unit.minimumAmount
                modelType = unit.modelType
                name = unit.name
                planPhaseOrder = unit.planPhaseOrder
                priceType = unit.priceType
                replacesPriceId = unit.replacesPriceId
                unitConfig = unit.unitConfig
                dimensionalPriceConfiguration = unit.dimensionalPriceConfiguration
                additionalProperties = unit.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("unit")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun unitConfig(unitConfig: UnitConfig) = unitConfig(JsonField.of(unitConfig))

            /**
             * Sets [Builder.unitConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.unitConfig] with a well-typed [UnitConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun unitConfig(unitConfig: JsonField<UnitConfig>) = apply {
                this.unitConfig = unitConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Unit].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .unitConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Unit =
                Unit(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("unitConfig", unitConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Unit = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("unit")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            unitConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("unit")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (unitConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Unit && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && unitConfig == other.unitConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, unitConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Unit{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, unitConfig=$unitConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class Package
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val packageConfig: JsonField<PackageConfig>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("package_config")
            @ExcludeMissing
            packageConfig: JsonField<PackageConfig> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            packageConfig,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("package")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun packageConfig(): PackageConfig = packageConfig.getRequired("package_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [packageConfig].
         *
         * Unlike [packageConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("package_config")
        @ExcludeMissing
        fun _packageConfig(): JsonField<PackageConfig> = packageConfig

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Package].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .packageConfig()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [Package]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("package")
            private var name: JsonField<String>? = null
            private var packageConfig: JsonField<PackageConfig>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(package_: Package) = apply {
                id = package_.id
                billableMetric = package_.billableMetric
                billingCycleConfiguration = package_.billingCycleConfiguration
                cadence = package_.cadence
                conversionRate = package_.conversionRate
                conversionRateConfig = package_.conversionRateConfig
                createdAt = package_.createdAt
                creditAllocation = package_.creditAllocation
                currency = package_.currency
                discount = package_.discount
                externalPriceId = package_.externalPriceId
                fixedPriceQuantity = package_.fixedPriceQuantity
                invoicingCycleConfiguration = package_.invoicingCycleConfiguration
                item = package_.item
                maximum = package_.maximum
                maximumAmount = package_.maximumAmount
                metadata = package_.metadata
                minimum = package_.minimum
                minimumAmount = package_.minimumAmount
                modelType = package_.modelType
                name = package_.name
                packageConfig = package_.packageConfig
                planPhaseOrder = package_.planPhaseOrder
                priceType = package_.priceType
                replacesPriceId = package_.replacesPriceId
                dimensionalPriceConfiguration = package_.dimensionalPriceConfiguration
                additionalProperties = package_.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("package")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun packageConfig(packageConfig: PackageConfig) =
                packageConfig(JsonField.of(packageConfig))

            /**
             * Sets [Builder.packageConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.packageConfig] with a well-typed [PackageConfig]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun packageConfig(packageConfig: JsonField<PackageConfig>) = apply {
                this.packageConfig = packageConfig
            }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Package].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .packageConfig()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Package =
                Package(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("packageConfig", packageConfig),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Package = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("package")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            packageConfig().validate()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("package")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (packageConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Package && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && packageConfig == other.packageConfig && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, packageConfig, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Package{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, packageConfig=$packageConfig, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class Matrix
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val matrixConfig: JsonField<MatrixConfig>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("matrix_config")
            @ExcludeMissing
            matrixConfig: JsonField<MatrixConfig> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            matrixConfig,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun matrixConfig(): MatrixConfig = matrixConfig.getRequired("matrix_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("matrix")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [matrixConfig].
         *
         * Unlike [matrixConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("matrix_config")
        @ExcludeMissing
        fun _matrixConfig(): JsonField<MatrixConfig> = matrixConfig

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Matrix].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [Matrix]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var matrixConfig: JsonField<MatrixConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("matrix")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(matrix: Matrix) = apply {
                id = matrix.id
                billableMetric = matrix.billableMetric
                billingCycleConfiguration = matrix.billingCycleConfiguration
                cadence = matrix.cadence
                conversionRate = matrix.conversionRate
                conversionRateConfig = matrix.conversionRateConfig
                createdAt = matrix.createdAt
                creditAllocation = matrix.creditAllocation
                currency = matrix.currency
                discount = matrix.discount
                externalPriceId = matrix.externalPriceId
                fixedPriceQuantity = matrix.fixedPriceQuantity
                invoicingCycleConfiguration = matrix.invoicingCycleConfiguration
                item = matrix.item
                matrixConfig = matrix.matrixConfig
                maximum = matrix.maximum
                maximumAmount = matrix.maximumAmount
                metadata = matrix.metadata
                minimum = matrix.minimum
                minimumAmount = matrix.minimumAmount
                modelType = matrix.modelType
                name = matrix.name
                planPhaseOrder = matrix.planPhaseOrder
                priceType = matrix.priceType
                replacesPriceId = matrix.replacesPriceId
                dimensionalPriceConfiguration = matrix.dimensionalPriceConfiguration
                additionalProperties = matrix.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            fun matrixConfig(matrixConfig: MatrixConfig) = matrixConfig(JsonField.of(matrixConfig))

            /**
             * Sets [Builder.matrixConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.matrixConfig] with a well-typed [MatrixConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun matrixConfig(matrixConfig: JsonField<MatrixConfig>) = apply {
                this.matrixConfig = matrixConfig
            }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("matrix")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Matrix].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Matrix =
                Matrix(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixConfig", matrixConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Matrix = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            matrixConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("matrix")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (matrixConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("matrix")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Matrix && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && matrixConfig == other.matrixConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, matrixConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Matrix{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixConfig=$matrixConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class Tiered
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val tieredConfig: JsonField<TieredConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("tiered_config")
            @ExcludeMissing
            tieredConfig: JsonField<TieredConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            tieredConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("tiered")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredConfig(): TieredConfig = tieredConfig.getRequired("tiered_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [tieredConfig].
         *
         * Unlike [tieredConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("tiered_config")
        @ExcludeMissing
        fun _tieredConfig(): JsonField<TieredConfig> = tieredConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Tiered].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [Tiered]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("tiered")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var tieredConfig: JsonField<TieredConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tiered: Tiered) = apply {
                id = tiered.id
                billableMetric = tiered.billableMetric
                billingCycleConfiguration = tiered.billingCycleConfiguration
                cadence = tiered.cadence
                conversionRate = tiered.conversionRate
                conversionRateConfig = tiered.conversionRateConfig
                createdAt = tiered.createdAt
                creditAllocation = tiered.creditAllocation
                currency = tiered.currency
                discount = tiered.discount
                externalPriceId = tiered.externalPriceId
                fixedPriceQuantity = tiered.fixedPriceQuantity
                invoicingCycleConfiguration = tiered.invoicingCycleConfiguration
                item = tiered.item
                maximum = tiered.maximum
                maximumAmount = tiered.maximumAmount
                metadata = tiered.metadata
                minimum = tiered.minimum
                minimumAmount = tiered.minimumAmount
                modelType = tiered.modelType
                name = tiered.name
                planPhaseOrder = tiered.planPhaseOrder
                priceType = tiered.priceType
                replacesPriceId = tiered.replacesPriceId
                tieredConfig = tiered.tieredConfig
                dimensionalPriceConfiguration = tiered.dimensionalPriceConfiguration
                additionalProperties = tiered.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("tiered")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun tieredConfig(tieredConfig: TieredConfig) = tieredConfig(JsonField.of(tieredConfig))

            /**
             * Sets [Builder.tieredConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredConfig] with a well-typed [TieredConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun tieredConfig(tieredConfig: JsonField<TieredConfig>) = apply {
                this.tieredConfig = tieredConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Tiered].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Tiered =
                Tiered(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("tieredConfig", tieredConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Tiered = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("tiered")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            tieredConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("tiered")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (tieredConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Tiered && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && tieredConfig == other.tieredConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, tieredConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Tiered{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, tieredConfig=$tieredConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class TieredBps
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val tieredBpsConfig: JsonField<TieredBpsConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("tiered_bps_config")
            @ExcludeMissing
            tieredBpsConfig: JsonField<TieredBpsConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            tieredBpsConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("tiered_bps")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredBpsConfig(): TieredBpsConfig = tieredBpsConfig.getRequired("tiered_bps_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [tieredBpsConfig].
         *
         * Unlike [tieredBpsConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("tiered_bps_config")
        @ExcludeMissing
        fun _tieredBpsConfig(): JsonField<TieredBpsConfig> = tieredBpsConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredBps].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredBpsConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredBps]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("tiered_bps")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var tieredBpsConfig: JsonField<TieredBpsConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredBps: TieredBps) = apply {
                id = tieredBps.id
                billableMetric = tieredBps.billableMetric
                billingCycleConfiguration = tieredBps.billingCycleConfiguration
                cadence = tieredBps.cadence
                conversionRate = tieredBps.conversionRate
                conversionRateConfig = tieredBps.conversionRateConfig
                createdAt = tieredBps.createdAt
                creditAllocation = tieredBps.creditAllocation
                currency = tieredBps.currency
                discount = tieredBps.discount
                externalPriceId = tieredBps.externalPriceId
                fixedPriceQuantity = tieredBps.fixedPriceQuantity
                invoicingCycleConfiguration = tieredBps.invoicingCycleConfiguration
                item = tieredBps.item
                maximum = tieredBps.maximum
                maximumAmount = tieredBps.maximumAmount
                metadata = tieredBps.metadata
                minimum = tieredBps.minimum
                minimumAmount = tieredBps.minimumAmount
                modelType = tieredBps.modelType
                name = tieredBps.name
                planPhaseOrder = tieredBps.planPhaseOrder
                priceType = tieredBps.priceType
                replacesPriceId = tieredBps.replacesPriceId
                tieredBpsConfig = tieredBps.tieredBpsConfig
                dimensionalPriceConfiguration = tieredBps.dimensionalPriceConfiguration
                additionalProperties = tieredBps.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("tiered_bps")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun tieredBpsConfig(tieredBpsConfig: TieredBpsConfig) =
                tieredBpsConfig(JsonField.of(tieredBpsConfig))

            /**
             * Sets [Builder.tieredBpsConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredBpsConfig] with a well-typed [TieredBpsConfig]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun tieredBpsConfig(tieredBpsConfig: JsonField<TieredBpsConfig>) = apply {
                this.tieredBpsConfig = tieredBpsConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [TieredBps].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredBpsConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): TieredBps =
                TieredBps(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("tieredBpsConfig", tieredBpsConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): TieredBps = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("tiered_bps")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            tieredBpsConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("tiered_bps")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (tieredBpsConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredBps && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && tieredBpsConfig == other.tieredBpsConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, tieredBpsConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredBps{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, tieredBpsConfig=$tieredBpsConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class Bps
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val bpsConfig: JsonField<BpsConfig>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("bps_config")
            @ExcludeMissing
            bpsConfig: JsonField<BpsConfig> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            bpsConfig,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun bpsConfig(): BpsConfig = bpsConfig.getRequired("bps_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("bps")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [bpsConfig].
         *
         * Unlike [bpsConfig], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("bps_config")
        @ExcludeMissing
        fun _bpsConfig(): JsonField<BpsConfig> = bpsConfig

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Bps].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bpsConfig()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [Bps]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var bpsConfig: JsonField<BpsConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("bps")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bps: Bps) = apply {
                id = bps.id
                billableMetric = bps.billableMetric
                billingCycleConfiguration = bps.billingCycleConfiguration
                bpsConfig = bps.bpsConfig
                cadence = bps.cadence
                conversionRate = bps.conversionRate
                conversionRateConfig = bps.conversionRateConfig
                createdAt = bps.createdAt
                creditAllocation = bps.creditAllocation
                currency = bps.currency
                discount = bps.discount
                externalPriceId = bps.externalPriceId
                fixedPriceQuantity = bps.fixedPriceQuantity
                invoicingCycleConfiguration = bps.invoicingCycleConfiguration
                item = bps.item
                maximum = bps.maximum
                maximumAmount = bps.maximumAmount
                metadata = bps.metadata
                minimum = bps.minimum
                minimumAmount = bps.minimumAmount
                modelType = bps.modelType
                name = bps.name
                planPhaseOrder = bps.planPhaseOrder
                priceType = bps.priceType
                replacesPriceId = bps.replacesPriceId
                dimensionalPriceConfiguration = bps.dimensionalPriceConfiguration
                additionalProperties = bps.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bpsConfig(bpsConfig: BpsConfig) = bpsConfig(JsonField.of(bpsConfig))

            /**
             * Sets [Builder.bpsConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.bpsConfig] with a well-typed [BpsConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun bpsConfig(bpsConfig: JsonField<BpsConfig>) = apply { this.bpsConfig = bpsConfig }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("bps")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Bps].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bpsConfig()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Bps =
                Bps(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bpsConfig", bpsConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Bps = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bpsConfig().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("bps")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (bpsConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("bps")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Bps && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bpsConfig == other.bpsConfig && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bpsConfig, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Bps{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bpsConfig=$bpsConfig, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class BulkBps
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val bulkBpsConfig: JsonField<BulkBpsConfig>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("bulk_bps_config")
            @ExcludeMissing
            bulkBpsConfig: JsonField<BulkBpsConfig> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            bulkBpsConfig,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun bulkBpsConfig(): BulkBpsConfig = bulkBpsConfig.getRequired("bulk_bps_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("bulk_bps")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [bulkBpsConfig].
         *
         * Unlike [bulkBpsConfig], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("bulk_bps_config")
        @ExcludeMissing
        fun _bulkBpsConfig(): JsonField<BulkBpsConfig> = bulkBpsConfig

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [BulkBps].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bulkBpsConfig()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [BulkBps]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var bulkBpsConfig: JsonField<BulkBpsConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("bulk_bps")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bulkBps: BulkBps) = apply {
                id = bulkBps.id
                billableMetric = bulkBps.billableMetric
                billingCycleConfiguration = bulkBps.billingCycleConfiguration
                bulkBpsConfig = bulkBps.bulkBpsConfig
                cadence = bulkBps.cadence
                conversionRate = bulkBps.conversionRate
                conversionRateConfig = bulkBps.conversionRateConfig
                createdAt = bulkBps.createdAt
                creditAllocation = bulkBps.creditAllocation
                currency = bulkBps.currency
                discount = bulkBps.discount
                externalPriceId = bulkBps.externalPriceId
                fixedPriceQuantity = bulkBps.fixedPriceQuantity
                invoicingCycleConfiguration = bulkBps.invoicingCycleConfiguration
                item = bulkBps.item
                maximum = bulkBps.maximum
                maximumAmount = bulkBps.maximumAmount
                metadata = bulkBps.metadata
                minimum = bulkBps.minimum
                minimumAmount = bulkBps.minimumAmount
                modelType = bulkBps.modelType
                name = bulkBps.name
                planPhaseOrder = bulkBps.planPhaseOrder
                priceType = bulkBps.priceType
                replacesPriceId = bulkBps.replacesPriceId
                dimensionalPriceConfiguration = bulkBps.dimensionalPriceConfiguration
                additionalProperties = bulkBps.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bulkBpsConfig(bulkBpsConfig: BulkBpsConfig) =
                bulkBpsConfig(JsonField.of(bulkBpsConfig))

            /**
             * Sets [Builder.bulkBpsConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.bulkBpsConfig] with a well-typed [BulkBpsConfig]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun bulkBpsConfig(bulkBpsConfig: JsonField<BulkBpsConfig>) = apply {
                this.bulkBpsConfig = bulkBpsConfig
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("bulk_bps")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [BulkBps].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bulkBpsConfig()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): BulkBps =
                BulkBps(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bulkBpsConfig", bulkBpsConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): BulkBps = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bulkBpsConfig().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("bulk_bps")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (bulkBpsConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("bulk_bps")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BulkBps && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bulkBpsConfig == other.bulkBpsConfig && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bulkBpsConfig, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BulkBps{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bulkBpsConfig=$bulkBpsConfig, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class Bulk
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val bulkConfig: JsonField<BulkConfig>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("bulk_config")
            @ExcludeMissing
            bulkConfig: JsonField<BulkConfig> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            bulkConfig,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun bulkConfig(): BulkConfig = bulkConfig.getRequired("bulk_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("bulk")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [bulkConfig].
         *
         * Unlike [bulkConfig], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("bulk_config")
        @ExcludeMissing
        fun _bulkConfig(): JsonField<BulkConfig> = bulkConfig

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Bulk].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bulkConfig()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [Bulk]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var bulkConfig: JsonField<BulkConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("bulk")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bulk: Bulk) = apply {
                id = bulk.id
                billableMetric = bulk.billableMetric
                billingCycleConfiguration = bulk.billingCycleConfiguration
                bulkConfig = bulk.bulkConfig
                cadence = bulk.cadence
                conversionRate = bulk.conversionRate
                conversionRateConfig = bulk.conversionRateConfig
                createdAt = bulk.createdAt
                creditAllocation = bulk.creditAllocation
                currency = bulk.currency
                discount = bulk.discount
                externalPriceId = bulk.externalPriceId
                fixedPriceQuantity = bulk.fixedPriceQuantity
                invoicingCycleConfiguration = bulk.invoicingCycleConfiguration
                item = bulk.item
                maximum = bulk.maximum
                maximumAmount = bulk.maximumAmount
                metadata = bulk.metadata
                minimum = bulk.minimum
                minimumAmount = bulk.minimumAmount
                modelType = bulk.modelType
                name = bulk.name
                planPhaseOrder = bulk.planPhaseOrder
                priceType = bulk.priceType
                replacesPriceId = bulk.replacesPriceId
                dimensionalPriceConfiguration = bulk.dimensionalPriceConfiguration
                additionalProperties = bulk.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bulkConfig(bulkConfig: BulkConfig) = bulkConfig(JsonField.of(bulkConfig))

            /**
             * Sets [Builder.bulkConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.bulkConfig] with a well-typed [BulkConfig] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun bulkConfig(bulkConfig: JsonField<BulkConfig>) = apply {
                this.bulkConfig = bulkConfig
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("bulk")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Bulk].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bulkConfig()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Bulk =
                Bulk(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bulkConfig", bulkConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): Bulk = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bulkConfig().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("bulk")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (bulkConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("bulk")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Bulk && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bulkConfig == other.bulkConfig && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bulkConfig, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Bulk{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bulkConfig=$bulkConfig, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class ThresholdTotalAmount
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("threshold_total_amount_config")
            @ExcludeMissing
            thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            thresholdTotalAmountConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("threshold_total_amount")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun thresholdTotalAmountConfig(): ThresholdTotalAmountConfig =
            thresholdTotalAmountConfig.getRequired("threshold_total_amount_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [thresholdTotalAmountConfig].
         *
         * Unlike [thresholdTotalAmountConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("threshold_total_amount_config")
        @ExcludeMissing
        fun _thresholdTotalAmountConfig(): JsonField<ThresholdTotalAmountConfig> =
            thresholdTotalAmountConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [ThresholdTotalAmount].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .thresholdTotalAmountConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [ThresholdTotalAmount]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("threshold_total_amount")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(thresholdTotalAmount: ThresholdTotalAmount) = apply {
                id = thresholdTotalAmount.id
                billableMetric = thresholdTotalAmount.billableMetric
                billingCycleConfiguration = thresholdTotalAmount.billingCycleConfiguration
                cadence = thresholdTotalAmount.cadence
                conversionRate = thresholdTotalAmount.conversionRate
                conversionRateConfig = thresholdTotalAmount.conversionRateConfig
                createdAt = thresholdTotalAmount.createdAt
                creditAllocation = thresholdTotalAmount.creditAllocation
                currency = thresholdTotalAmount.currency
                discount = thresholdTotalAmount.discount
                externalPriceId = thresholdTotalAmount.externalPriceId
                fixedPriceQuantity = thresholdTotalAmount.fixedPriceQuantity
                invoicingCycleConfiguration = thresholdTotalAmount.invoicingCycleConfiguration
                item = thresholdTotalAmount.item
                maximum = thresholdTotalAmount.maximum
                maximumAmount = thresholdTotalAmount.maximumAmount
                metadata = thresholdTotalAmount.metadata
                minimum = thresholdTotalAmount.minimum
                minimumAmount = thresholdTotalAmount.minimumAmount
                modelType = thresholdTotalAmount.modelType
                name = thresholdTotalAmount.name
                planPhaseOrder = thresholdTotalAmount.planPhaseOrder
                priceType = thresholdTotalAmount.priceType
                replacesPriceId = thresholdTotalAmount.replacesPriceId
                thresholdTotalAmountConfig = thresholdTotalAmount.thresholdTotalAmountConfig
                dimensionalPriceConfiguration = thresholdTotalAmount.dimensionalPriceConfiguration
                additionalProperties = thresholdTotalAmount.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("threshold_total_amount")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun thresholdTotalAmountConfig(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) =
                thresholdTotalAmountConfig(JsonField.of(thresholdTotalAmountConfig))

            /**
             * Sets [Builder.thresholdTotalAmountConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.thresholdTotalAmountConfig] with a well-typed
             * [ThresholdTotalAmountConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun thresholdTotalAmountConfig(
                thresholdTotalAmountConfig: JsonField<ThresholdTotalAmountConfig>
            ) = apply { this.thresholdTotalAmountConfig = thresholdTotalAmountConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [ThresholdTotalAmount].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .thresholdTotalAmountConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): ThresholdTotalAmount =
                ThresholdTotalAmount(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("thresholdTotalAmountConfig", thresholdTotalAmountConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): ThresholdTotalAmount = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("threshold_total_amount")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            thresholdTotalAmountConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("threshold_total_amount")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (thresholdTotalAmountConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ThresholdTotalAmountConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [ThresholdTotalAmountConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [ThresholdTotalAmountConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(thresholdTotalAmountConfig: ThresholdTotalAmountConfig) = apply {
                    additionalProperties =
                        thresholdTotalAmountConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [ThresholdTotalAmountConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): ThresholdTotalAmountConfig =
                    ThresholdTotalAmountConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): ThresholdTotalAmountConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ThresholdTotalAmountConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "ThresholdTotalAmountConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is ThresholdTotalAmount && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && thresholdTotalAmountConfig == other.thresholdTotalAmountConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, thresholdTotalAmountConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "ThresholdTotalAmount{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, thresholdTotalAmountConfig=$thresholdTotalAmountConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class TieredPackage
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val tieredPackageConfig: JsonField<TieredPackageConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("tiered_package_config")
            @ExcludeMissing
            tieredPackageConfig: JsonField<TieredPackageConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            tieredPackageConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("tiered_package")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredPackageConfig(): TieredPackageConfig =
            tieredPackageConfig.getRequired("tiered_package_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [tieredPackageConfig].
         *
         * Unlike [tieredPackageConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("tiered_package_config")
        @ExcludeMissing
        fun _tieredPackageConfig(): JsonField<TieredPackageConfig> = tieredPackageConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredPackage].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredPackageConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredPackage]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("tiered_package")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var tieredPackageConfig: JsonField<TieredPackageConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredPackage: TieredPackage) = apply {
                id = tieredPackage.id
                billableMetric = tieredPackage.billableMetric
                billingCycleConfiguration = tieredPackage.billingCycleConfiguration
                cadence = tieredPackage.cadence
                conversionRate = tieredPackage.conversionRate
                conversionRateConfig = tieredPackage.conversionRateConfig
                createdAt = tieredPackage.createdAt
                creditAllocation = tieredPackage.creditAllocation
                currency = tieredPackage.currency
                discount = tieredPackage.discount
                externalPriceId = tieredPackage.externalPriceId
                fixedPriceQuantity = tieredPackage.fixedPriceQuantity
                invoicingCycleConfiguration = tieredPackage.invoicingCycleConfiguration
                item = tieredPackage.item
                maximum = tieredPackage.maximum
                maximumAmount = tieredPackage.maximumAmount
                metadata = tieredPackage.metadata
                minimum = tieredPackage.minimum
                minimumAmount = tieredPackage.minimumAmount
                modelType = tieredPackage.modelType
                name = tieredPackage.name
                planPhaseOrder = tieredPackage.planPhaseOrder
                priceType = tieredPackage.priceType
                replacesPriceId = tieredPackage.replacesPriceId
                tieredPackageConfig = tieredPackage.tieredPackageConfig
                dimensionalPriceConfiguration = tieredPackage.dimensionalPriceConfiguration
                additionalProperties = tieredPackage.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("tiered_package")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun tieredPackageConfig(tieredPackageConfig: TieredPackageConfig) =
                tieredPackageConfig(JsonField.of(tieredPackageConfig))

            /**
             * Sets [Builder.tieredPackageConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredPackageConfig] with a well-typed
             * [TieredPackageConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun tieredPackageConfig(tieredPackageConfig: JsonField<TieredPackageConfig>) = apply {
                this.tieredPackageConfig = tieredPackageConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [TieredPackage].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredPackageConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): TieredPackage =
                TieredPackage(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("tieredPackageConfig", tieredPackageConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): TieredPackage = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("tiered_package")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            tieredPackageConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("tiered_package")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (tieredPackageConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class TieredPackageConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [TieredPackageConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [TieredPackageConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredPackageConfig: TieredPackageConfig) = apply {
                    additionalProperties = tieredPackageConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [TieredPackageConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): TieredPackageConfig =
                    TieredPackageConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): TieredPackageConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredPackageConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredPackageConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredPackage && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && tieredPackageConfig == other.tieredPackageConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, tieredPackageConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredPackage{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, tieredPackageConfig=$tieredPackageConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class GroupedTiered
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val groupedTieredConfig: JsonField<GroupedTieredConfig>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("grouped_tiered_config")
            @ExcludeMissing
            groupedTieredConfig: JsonField<GroupedTieredConfig> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            groupedTieredConfig,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedTieredConfig(): GroupedTieredConfig =
            groupedTieredConfig.getRequired("grouped_tiered_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("grouped_tiered")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedTieredConfig].
         *
         * Unlike [groupedTieredConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("grouped_tiered_config")
        @ExcludeMissing
        fun _groupedTieredConfig(): JsonField<GroupedTieredConfig> = groupedTieredConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [GroupedTiered].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedTieredConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedTiered]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedTieredConfig: JsonField<GroupedTieredConfig>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("grouped_tiered")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedTiered: GroupedTiered) = apply {
                id = groupedTiered.id
                billableMetric = groupedTiered.billableMetric
                billingCycleConfiguration = groupedTiered.billingCycleConfiguration
                cadence = groupedTiered.cadence
                conversionRate = groupedTiered.conversionRate
                conversionRateConfig = groupedTiered.conversionRateConfig
                createdAt = groupedTiered.createdAt
                creditAllocation = groupedTiered.creditAllocation
                currency = groupedTiered.currency
                discount = groupedTiered.discount
                externalPriceId = groupedTiered.externalPriceId
                fixedPriceQuantity = groupedTiered.fixedPriceQuantity
                groupedTieredConfig = groupedTiered.groupedTieredConfig
                invoicingCycleConfiguration = groupedTiered.invoicingCycleConfiguration
                item = groupedTiered.item
                maximum = groupedTiered.maximum
                maximumAmount = groupedTiered.maximumAmount
                metadata = groupedTiered.metadata
                minimum = groupedTiered.minimum
                minimumAmount = groupedTiered.minimumAmount
                modelType = groupedTiered.modelType
                name = groupedTiered.name
                planPhaseOrder = groupedTiered.planPhaseOrder
                priceType = groupedTiered.priceType
                replacesPriceId = groupedTiered.replacesPriceId
                dimensionalPriceConfiguration = groupedTiered.dimensionalPriceConfiguration
                additionalProperties = groupedTiered.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedTieredConfig(groupedTieredConfig: GroupedTieredConfig) =
                groupedTieredConfig(JsonField.of(groupedTieredConfig))

            /**
             * Sets [Builder.groupedTieredConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedTieredConfig] with a well-typed
             * [GroupedTieredConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun groupedTieredConfig(groupedTieredConfig: JsonField<GroupedTieredConfig>) = apply {
                this.groupedTieredConfig = groupedTieredConfig
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("grouped_tiered")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [GroupedTiered].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedTieredConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): GroupedTiered =
                GroupedTiered(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedTieredConfig", groupedTieredConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): GroupedTiered = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedTieredConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("grouped_tiered")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (groupedTieredConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("grouped_tiered")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        class GroupedTieredConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of [GroupedTieredConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [GroupedTieredConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(groupedTieredConfig: GroupedTieredConfig) = apply {
                    additionalProperties = groupedTieredConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [GroupedTieredConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): GroupedTieredConfig =
                    GroupedTieredConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): GroupedTieredConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedTieredConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedTieredConfig{additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedTiered && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedTieredConfig == other.groupedTieredConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedTieredConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedTiered{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedTieredConfig=$groupedTieredConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class TieredWithMinimum
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("tiered_with_minimum_config")
            @ExcludeMissing
            tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            tieredWithMinimumConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("tiered_with_minimum")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredWithMinimumConfig(): TieredWithMinimumConfig =
            tieredWithMinimumConfig.getRequired("tiered_with_minimum_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [tieredWithMinimumConfig].
         *
         * Unlike [tieredWithMinimumConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("tiered_with_minimum_config")
        @ExcludeMissing
        fun _tieredWithMinimumConfig(): JsonField<TieredWithMinimumConfig> = tieredWithMinimumConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredWithMinimum].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredWithMinimumConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredWithMinimum]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("tiered_with_minimum")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredWithMinimum: TieredWithMinimum) = apply {
                id = tieredWithMinimum.id
                billableMetric = tieredWithMinimum.billableMetric
                billingCycleConfiguration = tieredWithMinimum.billingCycleConfiguration
                cadence = tieredWithMinimum.cadence
                conversionRate = tieredWithMinimum.conversionRate
                conversionRateConfig = tieredWithMinimum.conversionRateConfig
                createdAt = tieredWithMinimum.createdAt
                creditAllocation = tieredWithMinimum.creditAllocation
                currency = tieredWithMinimum.currency
                discount = tieredWithMinimum.discount
                externalPriceId = tieredWithMinimum.externalPriceId
                fixedPriceQuantity = tieredWithMinimum.fixedPriceQuantity
                invoicingCycleConfiguration = tieredWithMinimum.invoicingCycleConfiguration
                item = tieredWithMinimum.item
                maximum = tieredWithMinimum.maximum
                maximumAmount = tieredWithMinimum.maximumAmount
                metadata = tieredWithMinimum.metadata
                minimum = tieredWithMinimum.minimum
                minimumAmount = tieredWithMinimum.minimumAmount
                modelType = tieredWithMinimum.modelType
                name = tieredWithMinimum.name
                planPhaseOrder = tieredWithMinimum.planPhaseOrder
                priceType = tieredWithMinimum.priceType
                replacesPriceId = tieredWithMinimum.replacesPriceId
                tieredWithMinimumConfig = tieredWithMinimum.tieredWithMinimumConfig
                dimensionalPriceConfiguration = tieredWithMinimum.dimensionalPriceConfiguration
                additionalProperties = tieredWithMinimum.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("tiered_with_minimum")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun tieredWithMinimumConfig(tieredWithMinimumConfig: TieredWithMinimumConfig) =
                tieredWithMinimumConfig(JsonField.of(tieredWithMinimumConfig))

            /**
             * Sets [Builder.tieredWithMinimumConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredWithMinimumConfig] with a well-typed
             * [TieredWithMinimumConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun tieredWithMinimumConfig(
                tieredWithMinimumConfig: JsonField<TieredWithMinimumConfig>
            ) = apply { this.tieredWithMinimumConfig = tieredWithMinimumConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [TieredWithMinimum].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredWithMinimumConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): TieredWithMinimum =
                TieredWithMinimum(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("tieredWithMinimumConfig", tieredWithMinimumConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): TieredWithMinimum = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("tiered_with_minimum")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            tieredWithMinimumConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("tiered_with_minimum")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (tieredWithMinimumConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class TieredWithMinimumConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [TieredWithMinimumConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [TieredWithMinimumConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredWithMinimumConfig: TieredWithMinimumConfig) = apply {
                    additionalProperties =
                        tieredWithMinimumConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [TieredWithMinimumConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): TieredWithMinimumConfig =
                    TieredWithMinimumConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): TieredWithMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredWithMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredWithMinimumConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredWithMinimum && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && tieredWithMinimumConfig == other.tieredWithMinimumConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, tieredWithMinimumConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredWithMinimum{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, tieredWithMinimumConfig=$tieredWithMinimumConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class TieredPackageWithMinimum
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("tiered_package_with_minimum_config")
            @ExcludeMissing
            tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig> =
                JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            tieredPackageWithMinimumConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("tiered_package_with_minimum")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredPackageWithMinimumConfig(): TieredPackageWithMinimumConfig =
            tieredPackageWithMinimumConfig.getRequired("tiered_package_with_minimum_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [tieredPackageWithMinimumConfig].
         *
         * Unlike [tieredPackageWithMinimumConfig], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("tiered_package_with_minimum_config")
        @ExcludeMissing
        fun _tieredPackageWithMinimumConfig(): JsonField<TieredPackageWithMinimumConfig> =
            tieredPackageWithMinimumConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredPackageWithMinimum].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredPackageWithMinimumConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredPackageWithMinimum]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("tiered_package_with_minimum")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig>? =
                null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredPackageWithMinimum: TieredPackageWithMinimum) = apply {
                id = tieredPackageWithMinimum.id
                billableMetric = tieredPackageWithMinimum.billableMetric
                billingCycleConfiguration = tieredPackageWithMinimum.billingCycleConfiguration
                cadence = tieredPackageWithMinimum.cadence
                conversionRate = tieredPackageWithMinimum.conversionRate
                conversionRateConfig = tieredPackageWithMinimum.conversionRateConfig
                createdAt = tieredPackageWithMinimum.createdAt
                creditAllocation = tieredPackageWithMinimum.creditAllocation
                currency = tieredPackageWithMinimum.currency
                discount = tieredPackageWithMinimum.discount
                externalPriceId = tieredPackageWithMinimum.externalPriceId
                fixedPriceQuantity = tieredPackageWithMinimum.fixedPriceQuantity
                invoicingCycleConfiguration = tieredPackageWithMinimum.invoicingCycleConfiguration
                item = tieredPackageWithMinimum.item
                maximum = tieredPackageWithMinimum.maximum
                maximumAmount = tieredPackageWithMinimum.maximumAmount
                metadata = tieredPackageWithMinimum.metadata
                minimum = tieredPackageWithMinimum.minimum
                minimumAmount = tieredPackageWithMinimum.minimumAmount
                modelType = tieredPackageWithMinimum.modelType
                name = tieredPackageWithMinimum.name
                planPhaseOrder = tieredPackageWithMinimum.planPhaseOrder
                priceType = tieredPackageWithMinimum.priceType
                replacesPriceId = tieredPackageWithMinimum.replacesPriceId
                tieredPackageWithMinimumConfig =
                    tieredPackageWithMinimum.tieredPackageWithMinimumConfig
                dimensionalPriceConfiguration =
                    tieredPackageWithMinimum.dimensionalPriceConfiguration
                additionalProperties = tieredPackageWithMinimum.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("tiered_package_with_minimum")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun tieredPackageWithMinimumConfig(
                tieredPackageWithMinimumConfig: TieredPackageWithMinimumConfig
            ) = tieredPackageWithMinimumConfig(JsonField.of(tieredPackageWithMinimumConfig))

            /**
             * Sets [Builder.tieredPackageWithMinimumConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredPackageWithMinimumConfig] with a well-typed
             * [TieredPackageWithMinimumConfig] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun tieredPackageWithMinimumConfig(
                tieredPackageWithMinimumConfig: JsonField<TieredPackageWithMinimumConfig>
            ) = apply { this.tieredPackageWithMinimumConfig = tieredPackageWithMinimumConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [TieredPackageWithMinimum].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredPackageWithMinimumConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): TieredPackageWithMinimum =
                TieredPackageWithMinimum(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("tieredPackageWithMinimumConfig", tieredPackageWithMinimumConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): TieredPackageWithMinimum = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("tiered_package_with_minimum")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            tieredPackageWithMinimumConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let {
                    if (it == JsonValue.from("tiered_package_with_minimum")) 1 else 0
                } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (tieredPackageWithMinimumConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class TieredPackageWithMinimumConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [TieredPackageWithMinimumConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [TieredPackageWithMinimumConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredPackageWithMinimumConfig: TieredPackageWithMinimumConfig) =
                    apply {
                        additionalProperties =
                            tieredPackageWithMinimumConfig.additionalProperties.toMutableMap()
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [TieredPackageWithMinimumConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): TieredPackageWithMinimumConfig =
                    TieredPackageWithMinimumConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): TieredPackageWithMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredPackageWithMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredPackageWithMinimumConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredPackageWithMinimum && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && tieredPackageWithMinimumConfig == other.tieredPackageWithMinimumConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, tieredPackageWithMinimumConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredPackageWithMinimum{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, tieredPackageWithMinimumConfig=$tieredPackageWithMinimumConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class PackageWithAllocation
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("package_with_allocation_config")
            @ExcludeMissing
            packageWithAllocationConfig: JsonField<PackageWithAllocationConfig> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            packageWithAllocationConfig,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("package_with_allocation")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun packageWithAllocationConfig(): PackageWithAllocationConfig =
            packageWithAllocationConfig.getRequired("package_with_allocation_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [packageWithAllocationConfig].
         *
         * Unlike [packageWithAllocationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("package_with_allocation_config")
        @ExcludeMissing
        fun _packageWithAllocationConfig(): JsonField<PackageWithAllocationConfig> =
            packageWithAllocationConfig

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [PackageWithAllocation].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .packageWithAllocationConfig()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [PackageWithAllocation]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("package_with_allocation")
            private var name: JsonField<String>? = null
            private var packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(packageWithAllocation: PackageWithAllocation) = apply {
                id = packageWithAllocation.id
                billableMetric = packageWithAllocation.billableMetric
                billingCycleConfiguration = packageWithAllocation.billingCycleConfiguration
                cadence = packageWithAllocation.cadence
                conversionRate = packageWithAllocation.conversionRate
                conversionRateConfig = packageWithAllocation.conversionRateConfig
                createdAt = packageWithAllocation.createdAt
                creditAllocation = packageWithAllocation.creditAllocation
                currency = packageWithAllocation.currency
                discount = packageWithAllocation.discount
                externalPriceId = packageWithAllocation.externalPriceId
                fixedPriceQuantity = packageWithAllocation.fixedPriceQuantity
                invoicingCycleConfiguration = packageWithAllocation.invoicingCycleConfiguration
                item = packageWithAllocation.item
                maximum = packageWithAllocation.maximum
                maximumAmount = packageWithAllocation.maximumAmount
                metadata = packageWithAllocation.metadata
                minimum = packageWithAllocation.minimum
                minimumAmount = packageWithAllocation.minimumAmount
                modelType = packageWithAllocation.modelType
                name = packageWithAllocation.name
                packageWithAllocationConfig = packageWithAllocation.packageWithAllocationConfig
                planPhaseOrder = packageWithAllocation.planPhaseOrder
                priceType = packageWithAllocation.priceType
                replacesPriceId = packageWithAllocation.replacesPriceId
                dimensionalPriceConfiguration = packageWithAllocation.dimensionalPriceConfiguration
                additionalProperties = packageWithAllocation.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("package_with_allocation")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun packageWithAllocationConfig(
                packageWithAllocationConfig: PackageWithAllocationConfig
            ) = packageWithAllocationConfig(JsonField.of(packageWithAllocationConfig))

            /**
             * Sets [Builder.packageWithAllocationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.packageWithAllocationConfig] with a well-typed
             * [PackageWithAllocationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun packageWithAllocationConfig(
                packageWithAllocationConfig: JsonField<PackageWithAllocationConfig>
            ) = apply { this.packageWithAllocationConfig = packageWithAllocationConfig }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [PackageWithAllocation].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .packageWithAllocationConfig()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): PackageWithAllocation =
                PackageWithAllocation(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("packageWithAllocationConfig", packageWithAllocationConfig),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): PackageWithAllocation = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("package_with_allocation")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            packageWithAllocationConfig().validate()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("package_with_allocation")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (packageWithAllocationConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PackageWithAllocationConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [PackageWithAllocationConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [PackageWithAllocationConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(packageWithAllocationConfig: PackageWithAllocationConfig) =
                    apply {
                        additionalProperties =
                            packageWithAllocationConfig.additionalProperties.toMutableMap()
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [PackageWithAllocationConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): PackageWithAllocationConfig =
                    PackageWithAllocationConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): PackageWithAllocationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PackageWithAllocationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "PackageWithAllocationConfig{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is PackageWithAllocation && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && packageWithAllocationConfig == other.packageWithAllocationConfig && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, packageWithAllocationConfig, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "PackageWithAllocation{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, packageWithAllocationConfig=$packageWithAllocationConfig, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class UnitWithPercent
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val unitWithPercentConfig: JsonField<UnitWithPercentConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("unit_with_percent_config")
            @ExcludeMissing
            unitWithPercentConfig: JsonField<UnitWithPercentConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            unitWithPercentConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("unit_with_percent")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun unitWithPercentConfig(): UnitWithPercentConfig =
            unitWithPercentConfig.getRequired("unit_with_percent_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [unitWithPercentConfig].
         *
         * Unlike [unitWithPercentConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("unit_with_percent_config")
        @ExcludeMissing
        fun _unitWithPercentConfig(): JsonField<UnitWithPercentConfig> = unitWithPercentConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [UnitWithPercent].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .unitWithPercentConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [UnitWithPercent]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("unit_with_percent")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var unitWithPercentConfig: JsonField<UnitWithPercentConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(unitWithPercent: UnitWithPercent) = apply {
                id = unitWithPercent.id
                billableMetric = unitWithPercent.billableMetric
                billingCycleConfiguration = unitWithPercent.billingCycleConfiguration
                cadence = unitWithPercent.cadence
                conversionRate = unitWithPercent.conversionRate
                conversionRateConfig = unitWithPercent.conversionRateConfig
                createdAt = unitWithPercent.createdAt
                creditAllocation = unitWithPercent.creditAllocation
                currency = unitWithPercent.currency
                discount = unitWithPercent.discount
                externalPriceId = unitWithPercent.externalPriceId
                fixedPriceQuantity = unitWithPercent.fixedPriceQuantity
                invoicingCycleConfiguration = unitWithPercent.invoicingCycleConfiguration
                item = unitWithPercent.item
                maximum = unitWithPercent.maximum
                maximumAmount = unitWithPercent.maximumAmount
                metadata = unitWithPercent.metadata
                minimum = unitWithPercent.minimum
                minimumAmount = unitWithPercent.minimumAmount
                modelType = unitWithPercent.modelType
                name = unitWithPercent.name
                planPhaseOrder = unitWithPercent.planPhaseOrder
                priceType = unitWithPercent.priceType
                replacesPriceId = unitWithPercent.replacesPriceId
                unitWithPercentConfig = unitWithPercent.unitWithPercentConfig
                dimensionalPriceConfiguration = unitWithPercent.dimensionalPriceConfiguration
                additionalProperties = unitWithPercent.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("unit_with_percent")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun unitWithPercentConfig(unitWithPercentConfig: UnitWithPercentConfig) =
                unitWithPercentConfig(JsonField.of(unitWithPercentConfig))

            /**
             * Sets [Builder.unitWithPercentConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.unitWithPercentConfig] with a well-typed
             * [UnitWithPercentConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun unitWithPercentConfig(unitWithPercentConfig: JsonField<UnitWithPercentConfig>) =
                apply {
                    this.unitWithPercentConfig = unitWithPercentConfig
                }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [UnitWithPercent].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .unitWithPercentConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): UnitWithPercent =
                UnitWithPercent(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("unitWithPercentConfig", unitWithPercentConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): UnitWithPercent = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("unit_with_percent")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            unitWithPercentConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("unit_with_percent")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (unitWithPercentConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class UnitWithPercentConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [UnitWithPercentConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [UnitWithPercentConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(unitWithPercentConfig: UnitWithPercentConfig) = apply {
                    additionalProperties = unitWithPercentConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [UnitWithPercentConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): UnitWithPercentConfig =
                    UnitWithPercentConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): UnitWithPercentConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is UnitWithPercentConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "UnitWithPercentConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is UnitWithPercent && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && unitWithPercentConfig == other.unitWithPercentConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, unitWithPercentConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "UnitWithPercent{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, unitWithPercentConfig=$unitWithPercentConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class MatrixWithAllocation
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("matrix_with_allocation_config")
            @ExcludeMissing
            matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            matrixWithAllocationConfig,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun matrixWithAllocationConfig(): MatrixWithAllocationConfig =
            matrixWithAllocationConfig.getRequired("matrix_with_allocation_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("matrix_with_allocation")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [matrixWithAllocationConfig].
         *
         * Unlike [matrixWithAllocationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("matrix_with_allocation_config")
        @ExcludeMissing
        fun _matrixWithAllocationConfig(): JsonField<MatrixWithAllocationConfig> =
            matrixWithAllocationConfig

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [MatrixWithAllocation].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixWithAllocationConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [MatrixWithAllocation]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("matrix_with_allocation")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(matrixWithAllocation: MatrixWithAllocation) = apply {
                id = matrixWithAllocation.id
                billableMetric = matrixWithAllocation.billableMetric
                billingCycleConfiguration = matrixWithAllocation.billingCycleConfiguration
                cadence = matrixWithAllocation.cadence
                conversionRate = matrixWithAllocation.conversionRate
                conversionRateConfig = matrixWithAllocation.conversionRateConfig
                createdAt = matrixWithAllocation.createdAt
                creditAllocation = matrixWithAllocation.creditAllocation
                currency = matrixWithAllocation.currency
                discount = matrixWithAllocation.discount
                externalPriceId = matrixWithAllocation.externalPriceId
                fixedPriceQuantity = matrixWithAllocation.fixedPriceQuantity
                invoicingCycleConfiguration = matrixWithAllocation.invoicingCycleConfiguration
                item = matrixWithAllocation.item
                matrixWithAllocationConfig = matrixWithAllocation.matrixWithAllocationConfig
                maximum = matrixWithAllocation.maximum
                maximumAmount = matrixWithAllocation.maximumAmount
                metadata = matrixWithAllocation.metadata
                minimum = matrixWithAllocation.minimum
                minimumAmount = matrixWithAllocation.minimumAmount
                modelType = matrixWithAllocation.modelType
                name = matrixWithAllocation.name
                planPhaseOrder = matrixWithAllocation.planPhaseOrder
                priceType = matrixWithAllocation.priceType
                replacesPriceId = matrixWithAllocation.replacesPriceId
                dimensionalPriceConfiguration = matrixWithAllocation.dimensionalPriceConfiguration
                additionalProperties = matrixWithAllocation.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            fun matrixWithAllocationConfig(matrixWithAllocationConfig: MatrixWithAllocationConfig) =
                matrixWithAllocationConfig(JsonField.of(matrixWithAllocationConfig))

            /**
             * Sets [Builder.matrixWithAllocationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.matrixWithAllocationConfig] with a well-typed
             * [MatrixWithAllocationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun matrixWithAllocationConfig(
                matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfig>
            ) = apply { this.matrixWithAllocationConfig = matrixWithAllocationConfig }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("matrix_with_allocation")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [MatrixWithAllocation].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixWithAllocationConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): MatrixWithAllocation =
                MatrixWithAllocation(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixWithAllocationConfig", matrixWithAllocationConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): MatrixWithAllocation = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            matrixWithAllocationConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("matrix_with_allocation")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (matrixWithAllocationConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("matrix_with_allocation")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MatrixWithAllocation && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && matrixWithAllocationConfig == other.matrixWithAllocationConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, matrixWithAllocationConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MatrixWithAllocation{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixWithAllocationConfig=$matrixWithAllocationConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class TieredWithProration
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val tieredWithProrationConfig: JsonField<TieredWithProrationConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("tiered_with_proration_config")
            @ExcludeMissing
            tieredWithProrationConfig: JsonField<TieredWithProrationConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            tieredWithProrationConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("tiered_with_proration")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun tieredWithProrationConfig(): TieredWithProrationConfig =
            tieredWithProrationConfig.getRequired("tiered_with_proration_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [tieredWithProrationConfig].
         *
         * Unlike [tieredWithProrationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("tiered_with_proration_config")
        @ExcludeMissing
        fun _tieredWithProrationConfig(): JsonField<TieredWithProrationConfig> =
            tieredWithProrationConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredWithProration].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredWithProrationConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredWithProration]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("tiered_with_proration")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var tieredWithProrationConfig: JsonField<TieredWithProrationConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredWithProration: TieredWithProration) = apply {
                id = tieredWithProration.id
                billableMetric = tieredWithProration.billableMetric
                billingCycleConfiguration = tieredWithProration.billingCycleConfiguration
                cadence = tieredWithProration.cadence
                conversionRate = tieredWithProration.conversionRate
                conversionRateConfig = tieredWithProration.conversionRateConfig
                createdAt = tieredWithProration.createdAt
                creditAllocation = tieredWithProration.creditAllocation
                currency = tieredWithProration.currency
                discount = tieredWithProration.discount
                externalPriceId = tieredWithProration.externalPriceId
                fixedPriceQuantity = tieredWithProration.fixedPriceQuantity
                invoicingCycleConfiguration = tieredWithProration.invoicingCycleConfiguration
                item = tieredWithProration.item
                maximum = tieredWithProration.maximum
                maximumAmount = tieredWithProration.maximumAmount
                metadata = tieredWithProration.metadata
                minimum = tieredWithProration.minimum
                minimumAmount = tieredWithProration.minimumAmount
                modelType = tieredWithProration.modelType
                name = tieredWithProration.name
                planPhaseOrder = tieredWithProration.planPhaseOrder
                priceType = tieredWithProration.priceType
                replacesPriceId = tieredWithProration.replacesPriceId
                tieredWithProrationConfig = tieredWithProration.tieredWithProrationConfig
                dimensionalPriceConfiguration = tieredWithProration.dimensionalPriceConfiguration
                additionalProperties = tieredWithProration.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("tiered_with_proration")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun tieredWithProrationConfig(tieredWithProrationConfig: TieredWithProrationConfig) =
                tieredWithProrationConfig(JsonField.of(tieredWithProrationConfig))

            /**
             * Sets [Builder.tieredWithProrationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.tieredWithProrationConfig] with a well-typed
             * [TieredWithProrationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun tieredWithProrationConfig(
                tieredWithProrationConfig: JsonField<TieredWithProrationConfig>
            ) = apply { this.tieredWithProrationConfig = tieredWithProrationConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [TieredWithProration].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .tieredWithProrationConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): TieredWithProration =
                TieredWithProration(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("tieredWithProrationConfig", tieredWithProrationConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): TieredWithProration = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("tiered_with_proration")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            tieredWithProrationConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("tiered_with_proration")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (tieredWithProrationConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class TieredWithProrationConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [TieredWithProrationConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [TieredWithProrationConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(tieredWithProrationConfig: TieredWithProrationConfig) = apply {
                    additionalProperties =
                        tieredWithProrationConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [TieredWithProrationConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): TieredWithProrationConfig =
                    TieredWithProrationConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): TieredWithProrationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is TieredWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "TieredWithProrationConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredWithProration && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && tieredWithProrationConfig == other.tieredWithProrationConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, tieredWithProrationConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredWithProration{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, tieredWithProrationConfig=$tieredWithProrationConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class UnitWithProration
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val unitWithProrationConfig: JsonField<UnitWithProrationConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("unit_with_proration_config")
            @ExcludeMissing
            unitWithProrationConfig: JsonField<UnitWithProrationConfig> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            unitWithProrationConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("unit_with_proration")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun unitWithProrationConfig(): UnitWithProrationConfig =
            unitWithProrationConfig.getRequired("unit_with_proration_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [unitWithProrationConfig].
         *
         * Unlike [unitWithProrationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("unit_with_proration_config")
        @ExcludeMissing
        fun _unitWithProrationConfig(): JsonField<UnitWithProrationConfig> = unitWithProrationConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [UnitWithProration].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .unitWithProrationConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [UnitWithProration]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("unit_with_proration")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var unitWithProrationConfig: JsonField<UnitWithProrationConfig>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(unitWithProration: UnitWithProration) = apply {
                id = unitWithProration.id
                billableMetric = unitWithProration.billableMetric
                billingCycleConfiguration = unitWithProration.billingCycleConfiguration
                cadence = unitWithProration.cadence
                conversionRate = unitWithProration.conversionRate
                conversionRateConfig = unitWithProration.conversionRateConfig
                createdAt = unitWithProration.createdAt
                creditAllocation = unitWithProration.creditAllocation
                currency = unitWithProration.currency
                discount = unitWithProration.discount
                externalPriceId = unitWithProration.externalPriceId
                fixedPriceQuantity = unitWithProration.fixedPriceQuantity
                invoicingCycleConfiguration = unitWithProration.invoicingCycleConfiguration
                item = unitWithProration.item
                maximum = unitWithProration.maximum
                maximumAmount = unitWithProration.maximumAmount
                metadata = unitWithProration.metadata
                minimum = unitWithProration.minimum
                minimumAmount = unitWithProration.minimumAmount
                modelType = unitWithProration.modelType
                name = unitWithProration.name
                planPhaseOrder = unitWithProration.planPhaseOrder
                priceType = unitWithProration.priceType
                replacesPriceId = unitWithProration.replacesPriceId
                unitWithProrationConfig = unitWithProration.unitWithProrationConfig
                dimensionalPriceConfiguration = unitWithProration.dimensionalPriceConfiguration
                additionalProperties = unitWithProration.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("unit_with_proration")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun unitWithProrationConfig(unitWithProrationConfig: UnitWithProrationConfig) =
                unitWithProrationConfig(JsonField.of(unitWithProrationConfig))

            /**
             * Sets [Builder.unitWithProrationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.unitWithProrationConfig] with a well-typed
             * [UnitWithProrationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun unitWithProrationConfig(
                unitWithProrationConfig: JsonField<UnitWithProrationConfig>
            ) = apply { this.unitWithProrationConfig = unitWithProrationConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [UnitWithProration].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .unitWithProrationConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): UnitWithProration =
                UnitWithProration(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired("unitWithProrationConfig", unitWithProrationConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): UnitWithProration = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("unit_with_proration")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            unitWithProrationConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("unit_with_proration")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (unitWithProrationConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class UnitWithProrationConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [UnitWithProrationConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [UnitWithProrationConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(unitWithProrationConfig: UnitWithProrationConfig) = apply {
                    additionalProperties =
                        unitWithProrationConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [UnitWithProrationConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): UnitWithProrationConfig =
                    UnitWithProrationConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): UnitWithProrationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is UnitWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "UnitWithProrationConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is UnitWithProration && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && unitWithProrationConfig == other.unitWithProrationConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, unitWithProrationConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "UnitWithProration{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, unitWithProrationConfig=$unitWithProrationConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class GroupedAllocation
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val groupedAllocationConfig: JsonField<GroupedAllocationConfig>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("grouped_allocation_config")
            @ExcludeMissing
            groupedAllocationConfig: JsonField<GroupedAllocationConfig> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            groupedAllocationConfig,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedAllocationConfig(): GroupedAllocationConfig =
            groupedAllocationConfig.getRequired("grouped_allocation_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("grouped_allocation")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedAllocationConfig].
         *
         * Unlike [groupedAllocationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("grouped_allocation_config")
        @ExcludeMissing
        fun _groupedAllocationConfig(): JsonField<GroupedAllocationConfig> = groupedAllocationConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [GroupedAllocation].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedAllocationConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedAllocation]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedAllocationConfig: JsonField<GroupedAllocationConfig>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("grouped_allocation")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedAllocation: GroupedAllocation) = apply {
                id = groupedAllocation.id
                billableMetric = groupedAllocation.billableMetric
                billingCycleConfiguration = groupedAllocation.billingCycleConfiguration
                cadence = groupedAllocation.cadence
                conversionRate = groupedAllocation.conversionRate
                conversionRateConfig = groupedAllocation.conversionRateConfig
                createdAt = groupedAllocation.createdAt
                creditAllocation = groupedAllocation.creditAllocation
                currency = groupedAllocation.currency
                discount = groupedAllocation.discount
                externalPriceId = groupedAllocation.externalPriceId
                fixedPriceQuantity = groupedAllocation.fixedPriceQuantity
                groupedAllocationConfig = groupedAllocation.groupedAllocationConfig
                invoicingCycleConfiguration = groupedAllocation.invoicingCycleConfiguration
                item = groupedAllocation.item
                maximum = groupedAllocation.maximum
                maximumAmount = groupedAllocation.maximumAmount
                metadata = groupedAllocation.metadata
                minimum = groupedAllocation.minimum
                minimumAmount = groupedAllocation.minimumAmount
                modelType = groupedAllocation.modelType
                name = groupedAllocation.name
                planPhaseOrder = groupedAllocation.planPhaseOrder
                priceType = groupedAllocation.priceType
                replacesPriceId = groupedAllocation.replacesPriceId
                dimensionalPriceConfiguration = groupedAllocation.dimensionalPriceConfiguration
                additionalProperties = groupedAllocation.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedAllocationConfig(groupedAllocationConfig: GroupedAllocationConfig) =
                groupedAllocationConfig(JsonField.of(groupedAllocationConfig))

            /**
             * Sets [Builder.groupedAllocationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedAllocationConfig] with a well-typed
             * [GroupedAllocationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun groupedAllocationConfig(
                groupedAllocationConfig: JsonField<GroupedAllocationConfig>
            ) = apply { this.groupedAllocationConfig = groupedAllocationConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("grouped_allocation")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [GroupedAllocation].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedAllocationConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): GroupedAllocation =
                GroupedAllocation(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedAllocationConfig", groupedAllocationConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): GroupedAllocation = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedAllocationConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("grouped_allocation")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (groupedAllocationConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("grouped_allocation")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        class GroupedAllocationConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedAllocationConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [GroupedAllocationConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(groupedAllocationConfig: GroupedAllocationConfig) = apply {
                    additionalProperties =
                        groupedAllocationConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [GroupedAllocationConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): GroupedAllocationConfig =
                    GroupedAllocationConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): GroupedAllocationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedAllocationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedAllocationConfig{additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedAllocation && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedAllocationConfig == other.groupedAllocationConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedAllocationConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedAllocation{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedAllocationConfig=$groupedAllocationConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class GroupedWithProratedMinimum
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val groupedWithProratedMinimumConfig: JsonField<GroupedWithProratedMinimumConfig>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("grouped_with_prorated_minimum_config")
            @ExcludeMissing
            groupedWithProratedMinimumConfig: JsonField<GroupedWithProratedMinimumConfig> =
                JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            groupedWithProratedMinimumConfig,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedWithProratedMinimumConfig(): GroupedWithProratedMinimumConfig =
            groupedWithProratedMinimumConfig.getRequired("grouped_with_prorated_minimum_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("grouped_with_prorated_minimum")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedWithProratedMinimumConfig].
         *
         * Unlike [groupedWithProratedMinimumConfig], this method doesn't throw if the JSON field
         * has an unexpected type.
         */
        @JsonProperty("grouped_with_prorated_minimum_config")
        @ExcludeMissing
        fun _groupedWithProratedMinimumConfig(): JsonField<GroupedWithProratedMinimumConfig> =
            groupedWithProratedMinimumConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [GroupedWithProratedMinimum].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithProratedMinimumConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedWithProratedMinimum]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedWithProratedMinimumConfig:
                JsonField<GroupedWithProratedMinimumConfig>? =
                null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("grouped_with_prorated_minimum")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedWithProratedMinimum: GroupedWithProratedMinimum) = apply {
                id = groupedWithProratedMinimum.id
                billableMetric = groupedWithProratedMinimum.billableMetric
                billingCycleConfiguration = groupedWithProratedMinimum.billingCycleConfiguration
                cadence = groupedWithProratedMinimum.cadence
                conversionRate = groupedWithProratedMinimum.conversionRate
                conversionRateConfig = groupedWithProratedMinimum.conversionRateConfig
                createdAt = groupedWithProratedMinimum.createdAt
                creditAllocation = groupedWithProratedMinimum.creditAllocation
                currency = groupedWithProratedMinimum.currency
                discount = groupedWithProratedMinimum.discount
                externalPriceId = groupedWithProratedMinimum.externalPriceId
                fixedPriceQuantity = groupedWithProratedMinimum.fixedPriceQuantity
                groupedWithProratedMinimumConfig =
                    groupedWithProratedMinimum.groupedWithProratedMinimumConfig
                invoicingCycleConfiguration = groupedWithProratedMinimum.invoicingCycleConfiguration
                item = groupedWithProratedMinimum.item
                maximum = groupedWithProratedMinimum.maximum
                maximumAmount = groupedWithProratedMinimum.maximumAmount
                metadata = groupedWithProratedMinimum.metadata
                minimum = groupedWithProratedMinimum.minimum
                minimumAmount = groupedWithProratedMinimum.minimumAmount
                modelType = groupedWithProratedMinimum.modelType
                name = groupedWithProratedMinimum.name
                planPhaseOrder = groupedWithProratedMinimum.planPhaseOrder
                priceType = groupedWithProratedMinimum.priceType
                replacesPriceId = groupedWithProratedMinimum.replacesPriceId
                dimensionalPriceConfiguration =
                    groupedWithProratedMinimum.dimensionalPriceConfiguration
                additionalProperties =
                    groupedWithProratedMinimum.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
            ) = groupedWithProratedMinimumConfig(JsonField.of(groupedWithProratedMinimumConfig))

            /**
             * Sets [Builder.groupedWithProratedMinimumConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedWithProratedMinimumConfig] with a well-typed
             * [GroupedWithProratedMinimumConfig] value instead. This method is primarily for
             * setting the field to an undocumented or not yet supported value.
             */
            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: JsonField<GroupedWithProratedMinimumConfig>
            ) = apply { this.groupedWithProratedMinimumConfig = groupedWithProratedMinimumConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("grouped_with_prorated_minimum")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [GroupedWithProratedMinimum].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithProratedMinimumConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): GroupedWithProratedMinimum =
                GroupedWithProratedMinimum(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired(
                        "groupedWithProratedMinimumConfig",
                        groupedWithProratedMinimumConfig,
                    ),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): GroupedWithProratedMinimum = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedWithProratedMinimumConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("grouped_with_prorated_minimum")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (groupedWithProratedMinimumConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let {
                    if (it == JsonValue.from("grouped_with_prorated_minimum")) 1 else 0
                } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        class GroupedWithProratedMinimumConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedWithProratedMinimumConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [GroupedWithProratedMinimumConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    groupedWithProratedMinimumConfig: GroupedWithProratedMinimumConfig
                ) = apply {
                    additionalProperties =
                        groupedWithProratedMinimumConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [GroupedWithProratedMinimumConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): GroupedWithProratedMinimumConfig =
                    GroupedWithProratedMinimumConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): GroupedWithProratedMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedWithProratedMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedWithProratedMinimumConfig{additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedWithProratedMinimum && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedWithProratedMinimumConfig == other.groupedWithProratedMinimumConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedWithProratedMinimumConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedWithProratedMinimum{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedWithProratedMinimumConfig=$groupedWithProratedMinimumConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class GroupedWithMeteredMinimum
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("grouped_with_metered_minimum_config")
            @ExcludeMissing
            groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig> =
                JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            groupedWithMeteredMinimumConfig,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedWithMeteredMinimumConfig(): GroupedWithMeteredMinimumConfig =
            groupedWithMeteredMinimumConfig.getRequired("grouped_with_metered_minimum_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("grouped_with_metered_minimum")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedWithMeteredMinimumConfig].
         *
         * Unlike [groupedWithMeteredMinimumConfig], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("grouped_with_metered_minimum_config")
        @ExcludeMissing
        fun _groupedWithMeteredMinimumConfig(): JsonField<GroupedWithMeteredMinimumConfig> =
            groupedWithMeteredMinimumConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [GroupedWithMeteredMinimum].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithMeteredMinimumConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedWithMeteredMinimum]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedWithMeteredMinimumConfig:
                JsonField<GroupedWithMeteredMinimumConfig>? =
                null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("grouped_with_metered_minimum")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedWithMeteredMinimum: GroupedWithMeteredMinimum) = apply {
                id = groupedWithMeteredMinimum.id
                billableMetric = groupedWithMeteredMinimum.billableMetric
                billingCycleConfiguration = groupedWithMeteredMinimum.billingCycleConfiguration
                cadence = groupedWithMeteredMinimum.cadence
                conversionRate = groupedWithMeteredMinimum.conversionRate
                conversionRateConfig = groupedWithMeteredMinimum.conversionRateConfig
                createdAt = groupedWithMeteredMinimum.createdAt
                creditAllocation = groupedWithMeteredMinimum.creditAllocation
                currency = groupedWithMeteredMinimum.currency
                discount = groupedWithMeteredMinimum.discount
                externalPriceId = groupedWithMeteredMinimum.externalPriceId
                fixedPriceQuantity = groupedWithMeteredMinimum.fixedPriceQuantity
                groupedWithMeteredMinimumConfig =
                    groupedWithMeteredMinimum.groupedWithMeteredMinimumConfig
                invoicingCycleConfiguration = groupedWithMeteredMinimum.invoicingCycleConfiguration
                item = groupedWithMeteredMinimum.item
                maximum = groupedWithMeteredMinimum.maximum
                maximumAmount = groupedWithMeteredMinimum.maximumAmount
                metadata = groupedWithMeteredMinimum.metadata
                minimum = groupedWithMeteredMinimum.minimum
                minimumAmount = groupedWithMeteredMinimum.minimumAmount
                modelType = groupedWithMeteredMinimum.modelType
                name = groupedWithMeteredMinimum.name
                planPhaseOrder = groupedWithMeteredMinimum.planPhaseOrder
                priceType = groupedWithMeteredMinimum.priceType
                replacesPriceId = groupedWithMeteredMinimum.replacesPriceId
                dimensionalPriceConfiguration =
                    groupedWithMeteredMinimum.dimensionalPriceConfiguration
                additionalProperties = groupedWithMeteredMinimum.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
            ) = groupedWithMeteredMinimumConfig(JsonField.of(groupedWithMeteredMinimumConfig))

            /**
             * Sets [Builder.groupedWithMeteredMinimumConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedWithMeteredMinimumConfig] with a well-typed
             * [GroupedWithMeteredMinimumConfig] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: JsonField<GroupedWithMeteredMinimumConfig>
            ) = apply { this.groupedWithMeteredMinimumConfig = groupedWithMeteredMinimumConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("grouped_with_metered_minimum")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [GroupedWithMeteredMinimum].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithMeteredMinimumConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): GroupedWithMeteredMinimum =
                GroupedWithMeteredMinimum(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired(
                        "groupedWithMeteredMinimumConfig",
                        groupedWithMeteredMinimumConfig,
                    ),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): GroupedWithMeteredMinimum = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedWithMeteredMinimumConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("grouped_with_metered_minimum")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (groupedWithMeteredMinimumConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let {
                    if (it == JsonValue.from("grouped_with_metered_minimum")) 1 else 0
                } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        class GroupedWithMeteredMinimumConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedWithMeteredMinimumConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [GroupedWithMeteredMinimumConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    groupedWithMeteredMinimumConfig: GroupedWithMeteredMinimumConfig
                ) = apply {
                    additionalProperties =
                        groupedWithMeteredMinimumConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [GroupedWithMeteredMinimumConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): GroupedWithMeteredMinimumConfig =
                    GroupedWithMeteredMinimumConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): GroupedWithMeteredMinimumConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedWithMeteredMinimumConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedWithMeteredMinimumConfig{additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedWithMeteredMinimum && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedWithMeteredMinimumConfig == other.groupedWithMeteredMinimumConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedWithMeteredMinimumConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedWithMeteredMinimum{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedWithMeteredMinimumConfig=$groupedWithMeteredMinimumConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class MatrixWithDisplayName
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("matrix_with_display_name_config")
            @ExcludeMissing
            matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            matrixWithDisplayNameConfig,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun matrixWithDisplayNameConfig(): MatrixWithDisplayNameConfig =
            matrixWithDisplayNameConfig.getRequired("matrix_with_display_name_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("matrix_with_display_name")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [matrixWithDisplayNameConfig].
         *
         * Unlike [matrixWithDisplayNameConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("matrix_with_display_name_config")
        @ExcludeMissing
        fun _matrixWithDisplayNameConfig(): JsonField<MatrixWithDisplayNameConfig> =
            matrixWithDisplayNameConfig

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [MatrixWithDisplayName].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixWithDisplayNameConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [MatrixWithDisplayName]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("matrix_with_display_name")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(matrixWithDisplayName: MatrixWithDisplayName) = apply {
                id = matrixWithDisplayName.id
                billableMetric = matrixWithDisplayName.billableMetric
                billingCycleConfiguration = matrixWithDisplayName.billingCycleConfiguration
                cadence = matrixWithDisplayName.cadence
                conversionRate = matrixWithDisplayName.conversionRate
                conversionRateConfig = matrixWithDisplayName.conversionRateConfig
                createdAt = matrixWithDisplayName.createdAt
                creditAllocation = matrixWithDisplayName.creditAllocation
                currency = matrixWithDisplayName.currency
                discount = matrixWithDisplayName.discount
                externalPriceId = matrixWithDisplayName.externalPriceId
                fixedPriceQuantity = matrixWithDisplayName.fixedPriceQuantity
                invoicingCycleConfiguration = matrixWithDisplayName.invoicingCycleConfiguration
                item = matrixWithDisplayName.item
                matrixWithDisplayNameConfig = matrixWithDisplayName.matrixWithDisplayNameConfig
                maximum = matrixWithDisplayName.maximum
                maximumAmount = matrixWithDisplayName.maximumAmount
                metadata = matrixWithDisplayName.metadata
                minimum = matrixWithDisplayName.minimum
                minimumAmount = matrixWithDisplayName.minimumAmount
                modelType = matrixWithDisplayName.modelType
                name = matrixWithDisplayName.name
                planPhaseOrder = matrixWithDisplayName.planPhaseOrder
                priceType = matrixWithDisplayName.priceType
                replacesPriceId = matrixWithDisplayName.replacesPriceId
                dimensionalPriceConfiguration = matrixWithDisplayName.dimensionalPriceConfiguration
                additionalProperties = matrixWithDisplayName.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig
            ) = matrixWithDisplayNameConfig(JsonField.of(matrixWithDisplayNameConfig))

            /**
             * Sets [Builder.matrixWithDisplayNameConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.matrixWithDisplayNameConfig] with a well-typed
             * [MatrixWithDisplayNameConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: JsonField<MatrixWithDisplayNameConfig>
            ) = apply { this.matrixWithDisplayNameConfig = matrixWithDisplayNameConfig }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("matrix_with_display_name")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [MatrixWithDisplayName].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixWithDisplayNameConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): MatrixWithDisplayName =
                MatrixWithDisplayName(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixWithDisplayNameConfig", matrixWithDisplayNameConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): MatrixWithDisplayName = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            matrixWithDisplayNameConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("matrix_with_display_name")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (matrixWithDisplayNameConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("matrix_with_display_name")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        class MatrixWithDisplayNameConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [MatrixWithDisplayNameConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [MatrixWithDisplayNameConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(matrixWithDisplayNameConfig: MatrixWithDisplayNameConfig) =
                    apply {
                        additionalProperties =
                            matrixWithDisplayNameConfig.additionalProperties.toMutableMap()
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [MatrixWithDisplayNameConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): MatrixWithDisplayNameConfig =
                    MatrixWithDisplayNameConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): MatrixWithDisplayNameConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is MatrixWithDisplayNameConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "MatrixWithDisplayNameConfig{additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MatrixWithDisplayName && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && matrixWithDisplayNameConfig == other.matrixWithDisplayNameConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, matrixWithDisplayNameConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MatrixWithDisplayName{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixWithDisplayNameConfig=$matrixWithDisplayNameConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class BulkWithProration
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val bulkWithProrationConfig: JsonField<BulkWithProrationConfig>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("bulk_with_proration_config")
            @ExcludeMissing
            bulkWithProrationConfig: JsonField<BulkWithProrationConfig> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            bulkWithProrationConfig,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun bulkWithProrationConfig(): BulkWithProrationConfig =
            bulkWithProrationConfig.getRequired("bulk_with_proration_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("bulk_with_proration")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [bulkWithProrationConfig].
         *
         * Unlike [bulkWithProrationConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("bulk_with_proration_config")
        @ExcludeMissing
        fun _bulkWithProrationConfig(): JsonField<BulkWithProrationConfig> = bulkWithProrationConfig

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [BulkWithProration].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bulkWithProrationConfig()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [BulkWithProration]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var bulkWithProrationConfig: JsonField<BulkWithProrationConfig>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("bulk_with_proration")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bulkWithProration: BulkWithProration) = apply {
                id = bulkWithProration.id
                billableMetric = bulkWithProration.billableMetric
                billingCycleConfiguration = bulkWithProration.billingCycleConfiguration
                bulkWithProrationConfig = bulkWithProration.bulkWithProrationConfig
                cadence = bulkWithProration.cadence
                conversionRate = bulkWithProration.conversionRate
                conversionRateConfig = bulkWithProration.conversionRateConfig
                createdAt = bulkWithProration.createdAt
                creditAllocation = bulkWithProration.creditAllocation
                currency = bulkWithProration.currency
                discount = bulkWithProration.discount
                externalPriceId = bulkWithProration.externalPriceId
                fixedPriceQuantity = bulkWithProration.fixedPriceQuantity
                invoicingCycleConfiguration = bulkWithProration.invoicingCycleConfiguration
                item = bulkWithProration.item
                maximum = bulkWithProration.maximum
                maximumAmount = bulkWithProration.maximumAmount
                metadata = bulkWithProration.metadata
                minimum = bulkWithProration.minimum
                minimumAmount = bulkWithProration.minimumAmount
                modelType = bulkWithProration.modelType
                name = bulkWithProration.name
                planPhaseOrder = bulkWithProration.planPhaseOrder
                priceType = bulkWithProration.priceType
                replacesPriceId = bulkWithProration.replacesPriceId
                dimensionalPriceConfiguration = bulkWithProration.dimensionalPriceConfiguration
                additionalProperties = bulkWithProration.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bulkWithProrationConfig(bulkWithProrationConfig: BulkWithProrationConfig) =
                bulkWithProrationConfig(JsonField.of(bulkWithProrationConfig))

            /**
             * Sets [Builder.bulkWithProrationConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.bulkWithProrationConfig] with a well-typed
             * [BulkWithProrationConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun bulkWithProrationConfig(
                bulkWithProrationConfig: JsonField<BulkWithProrationConfig>
            ) = apply { this.bulkWithProrationConfig = bulkWithProrationConfig }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("bulk_with_proration")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [BulkWithProration].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bulkWithProrationConfig()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): BulkWithProration =
                BulkWithProration(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bulkWithProrationConfig", bulkWithProrationConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): BulkWithProration = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bulkWithProrationConfig().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("bulk_with_proration")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (bulkWithProrationConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("bulk_with_proration")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class BulkWithProrationConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [BulkWithProrationConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [BulkWithProrationConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(bulkWithProrationConfig: BulkWithProrationConfig) = apply {
                    additionalProperties =
                        bulkWithProrationConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [BulkWithProrationConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): BulkWithProrationConfig =
                    BulkWithProrationConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): BulkWithProrationConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is BulkWithProrationConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "BulkWithProrationConfig{additionalProperties=$additionalProperties}"
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BulkWithProration && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bulkWithProrationConfig == other.bulkWithProrationConfig && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bulkWithProrationConfig, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BulkWithProration{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bulkWithProrationConfig=$bulkWithProrationConfig, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class GroupedTieredPackage
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("grouped_tiered_package_config")
            @ExcludeMissing
            groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            groupedTieredPackageConfig,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedTieredPackageConfig(): GroupedTieredPackageConfig =
            groupedTieredPackageConfig.getRequired("grouped_tiered_package_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("grouped_tiered_package")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedTieredPackageConfig].
         *
         * Unlike [groupedTieredPackageConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("grouped_tiered_package_config")
        @ExcludeMissing
        fun _groupedTieredPackageConfig(): JsonField<GroupedTieredPackageConfig> =
            groupedTieredPackageConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [GroupedTieredPackage].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedTieredPackageConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedTieredPackage]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("grouped_tiered_package")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedTieredPackage: GroupedTieredPackage) = apply {
                id = groupedTieredPackage.id
                billableMetric = groupedTieredPackage.billableMetric
                billingCycleConfiguration = groupedTieredPackage.billingCycleConfiguration
                cadence = groupedTieredPackage.cadence
                conversionRate = groupedTieredPackage.conversionRate
                conversionRateConfig = groupedTieredPackage.conversionRateConfig
                createdAt = groupedTieredPackage.createdAt
                creditAllocation = groupedTieredPackage.creditAllocation
                currency = groupedTieredPackage.currency
                discount = groupedTieredPackage.discount
                externalPriceId = groupedTieredPackage.externalPriceId
                fixedPriceQuantity = groupedTieredPackage.fixedPriceQuantity
                groupedTieredPackageConfig = groupedTieredPackage.groupedTieredPackageConfig
                invoicingCycleConfiguration = groupedTieredPackage.invoicingCycleConfiguration
                item = groupedTieredPackage.item
                maximum = groupedTieredPackage.maximum
                maximumAmount = groupedTieredPackage.maximumAmount
                metadata = groupedTieredPackage.metadata
                minimum = groupedTieredPackage.minimum
                minimumAmount = groupedTieredPackage.minimumAmount
                modelType = groupedTieredPackage.modelType
                name = groupedTieredPackage.name
                planPhaseOrder = groupedTieredPackage.planPhaseOrder
                priceType = groupedTieredPackage.priceType
                replacesPriceId = groupedTieredPackage.replacesPriceId
                dimensionalPriceConfiguration = groupedTieredPackage.dimensionalPriceConfiguration
                additionalProperties = groupedTieredPackage.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedTieredPackageConfig(groupedTieredPackageConfig: GroupedTieredPackageConfig) =
                groupedTieredPackageConfig(JsonField.of(groupedTieredPackageConfig))

            /**
             * Sets [Builder.groupedTieredPackageConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedTieredPackageConfig] with a well-typed
             * [GroupedTieredPackageConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun groupedTieredPackageConfig(
                groupedTieredPackageConfig: JsonField<GroupedTieredPackageConfig>
            ) = apply { this.groupedTieredPackageConfig = groupedTieredPackageConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("grouped_tiered_package")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [GroupedTieredPackage].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedTieredPackageConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): GroupedTieredPackage =
                GroupedTieredPackage(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedTieredPackageConfig", groupedTieredPackageConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): GroupedTieredPackage = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedTieredPackageConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("grouped_tiered_package")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (groupedTieredPackageConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("grouped_tiered_package")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        class GroupedTieredPackageConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedTieredPackageConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [GroupedTieredPackageConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(groupedTieredPackageConfig: GroupedTieredPackageConfig) = apply {
                    additionalProperties =
                        groupedTieredPackageConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [GroupedTieredPackageConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): GroupedTieredPackageConfig =
                    GroupedTieredPackageConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): GroupedTieredPackageConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedTieredPackageConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedTieredPackageConfig{additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedTieredPackage && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedTieredPackageConfig == other.groupedTieredPackageConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedTieredPackageConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedTieredPackage{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedTieredPackageConfig=$groupedTieredPackageConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class MaxGroupTieredPackage
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maxGroupTieredPackageConfig: JsonField<MaxGroupTieredPackageConfig>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("max_group_tiered_package_config")
            @ExcludeMissing
            maxGroupTieredPackageConfig: JsonField<MaxGroupTieredPackageConfig> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maxGroupTieredPackageConfig,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun maxGroupTieredPackageConfig(): MaxGroupTieredPackageConfig =
            maxGroupTieredPackageConfig.getRequired("max_group_tiered_package_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("max_group_tiered_package")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maxGroupTieredPackageConfig].
         *
         * Unlike [maxGroupTieredPackageConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("max_group_tiered_package_config")
        @ExcludeMissing
        fun _maxGroupTieredPackageConfig(): JsonField<MaxGroupTieredPackageConfig> =
            maxGroupTieredPackageConfig

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [MaxGroupTieredPackage].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maxGroupTieredPackageConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [MaxGroupTieredPackage]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maxGroupTieredPackageConfig: JsonField<MaxGroupTieredPackageConfig>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("max_group_tiered_package")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(maxGroupTieredPackage: MaxGroupTieredPackage) = apply {
                id = maxGroupTieredPackage.id
                billableMetric = maxGroupTieredPackage.billableMetric
                billingCycleConfiguration = maxGroupTieredPackage.billingCycleConfiguration
                cadence = maxGroupTieredPackage.cadence
                conversionRate = maxGroupTieredPackage.conversionRate
                conversionRateConfig = maxGroupTieredPackage.conversionRateConfig
                createdAt = maxGroupTieredPackage.createdAt
                creditAllocation = maxGroupTieredPackage.creditAllocation
                currency = maxGroupTieredPackage.currency
                discount = maxGroupTieredPackage.discount
                externalPriceId = maxGroupTieredPackage.externalPriceId
                fixedPriceQuantity = maxGroupTieredPackage.fixedPriceQuantity
                invoicingCycleConfiguration = maxGroupTieredPackage.invoicingCycleConfiguration
                item = maxGroupTieredPackage.item
                maxGroupTieredPackageConfig = maxGroupTieredPackage.maxGroupTieredPackageConfig
                maximum = maxGroupTieredPackage.maximum
                maximumAmount = maxGroupTieredPackage.maximumAmount
                metadata = maxGroupTieredPackage.metadata
                minimum = maxGroupTieredPackage.minimum
                minimumAmount = maxGroupTieredPackage.minimumAmount
                modelType = maxGroupTieredPackage.modelType
                name = maxGroupTieredPackage.name
                planPhaseOrder = maxGroupTieredPackage.planPhaseOrder
                priceType = maxGroupTieredPackage.priceType
                replacesPriceId = maxGroupTieredPackage.replacesPriceId
                dimensionalPriceConfiguration = maxGroupTieredPackage.dimensionalPriceConfiguration
                additionalProperties = maxGroupTieredPackage.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            fun maxGroupTieredPackageConfig(
                maxGroupTieredPackageConfig: MaxGroupTieredPackageConfig
            ) = maxGroupTieredPackageConfig(JsonField.of(maxGroupTieredPackageConfig))

            /**
             * Sets [Builder.maxGroupTieredPackageConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maxGroupTieredPackageConfig] with a well-typed
             * [MaxGroupTieredPackageConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun maxGroupTieredPackageConfig(
                maxGroupTieredPackageConfig: JsonField<MaxGroupTieredPackageConfig>
            ) = apply { this.maxGroupTieredPackageConfig = maxGroupTieredPackageConfig }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("max_group_tiered_package")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [MaxGroupTieredPackage].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maxGroupTieredPackageConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): MaxGroupTieredPackage =
                MaxGroupTieredPackage(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maxGroupTieredPackageConfig", maxGroupTieredPackageConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): MaxGroupTieredPackage = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maxGroupTieredPackageConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("max_group_tiered_package")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maxGroupTieredPackageConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("max_group_tiered_package")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        class MaxGroupTieredPackageConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [MaxGroupTieredPackageConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [MaxGroupTieredPackageConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(maxGroupTieredPackageConfig: MaxGroupTieredPackageConfig) =
                    apply {
                        additionalProperties =
                            maxGroupTieredPackageConfig.additionalProperties.toMutableMap()
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [MaxGroupTieredPackageConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): MaxGroupTieredPackageConfig =
                    MaxGroupTieredPackageConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): MaxGroupTieredPackageConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is MaxGroupTieredPackageConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "MaxGroupTieredPackageConfig{additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MaxGroupTieredPackage && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maxGroupTieredPackageConfig == other.maxGroupTieredPackageConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maxGroupTieredPackageConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MaxGroupTieredPackage{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maxGroupTieredPackageConfig=$maxGroupTieredPackageConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class ScalableMatrixWithUnitPricing
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val scalableMatrixWithUnitPricingConfig:
            JsonField<ScalableMatrixWithUnitPricingConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("scalable_matrix_with_unit_pricing_config")
            @ExcludeMissing
            scalableMatrixWithUnitPricingConfig: JsonField<ScalableMatrixWithUnitPricingConfig> =
                JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            scalableMatrixWithUnitPricingConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("scalable_matrix_with_unit_pricing")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun scalableMatrixWithUnitPricingConfig(): ScalableMatrixWithUnitPricingConfig =
            scalableMatrixWithUnitPricingConfig.getRequired(
                "scalable_matrix_with_unit_pricing_config"
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [scalableMatrixWithUnitPricingConfig].
         *
         * Unlike [scalableMatrixWithUnitPricingConfig], this method doesn't throw if the JSON field
         * has an unexpected type.
         */
        @JsonProperty("scalable_matrix_with_unit_pricing_config")
        @ExcludeMissing
        fun _scalableMatrixWithUnitPricingConfig(): JsonField<ScalableMatrixWithUnitPricingConfig> =
            scalableMatrixWithUnitPricingConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [ScalableMatrixWithUnitPricing].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .scalableMatrixWithUnitPricingConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [ScalableMatrixWithUnitPricing]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("scalable_matrix_with_unit_pricing")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var scalableMatrixWithUnitPricingConfig:
                JsonField<ScalableMatrixWithUnitPricingConfig>? =
                null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(scalableMatrixWithUnitPricing: ScalableMatrixWithUnitPricing) =
                apply {
                    id = scalableMatrixWithUnitPricing.id
                    billableMetric = scalableMatrixWithUnitPricing.billableMetric
                    billingCycleConfiguration =
                        scalableMatrixWithUnitPricing.billingCycleConfiguration
                    cadence = scalableMatrixWithUnitPricing.cadence
                    conversionRate = scalableMatrixWithUnitPricing.conversionRate
                    conversionRateConfig = scalableMatrixWithUnitPricing.conversionRateConfig
                    createdAt = scalableMatrixWithUnitPricing.createdAt
                    creditAllocation = scalableMatrixWithUnitPricing.creditAllocation
                    currency = scalableMatrixWithUnitPricing.currency
                    discount = scalableMatrixWithUnitPricing.discount
                    externalPriceId = scalableMatrixWithUnitPricing.externalPriceId
                    fixedPriceQuantity = scalableMatrixWithUnitPricing.fixedPriceQuantity
                    invoicingCycleConfiguration =
                        scalableMatrixWithUnitPricing.invoicingCycleConfiguration
                    item = scalableMatrixWithUnitPricing.item
                    maximum = scalableMatrixWithUnitPricing.maximum
                    maximumAmount = scalableMatrixWithUnitPricing.maximumAmount
                    metadata = scalableMatrixWithUnitPricing.metadata
                    minimum = scalableMatrixWithUnitPricing.minimum
                    minimumAmount = scalableMatrixWithUnitPricing.minimumAmount
                    modelType = scalableMatrixWithUnitPricing.modelType
                    name = scalableMatrixWithUnitPricing.name
                    planPhaseOrder = scalableMatrixWithUnitPricing.planPhaseOrder
                    priceType = scalableMatrixWithUnitPricing.priceType
                    replacesPriceId = scalableMatrixWithUnitPricing.replacesPriceId
                    scalableMatrixWithUnitPricingConfig =
                        scalableMatrixWithUnitPricing.scalableMatrixWithUnitPricingConfig
                    dimensionalPriceConfiguration =
                        scalableMatrixWithUnitPricing.dimensionalPriceConfiguration
                    additionalProperties =
                        scalableMatrixWithUnitPricing.additionalProperties.toMutableMap()
                }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("scalable_matrix_with_unit_pricing")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun scalableMatrixWithUnitPricingConfig(
                scalableMatrixWithUnitPricingConfig: ScalableMatrixWithUnitPricingConfig
            ) =
                scalableMatrixWithUnitPricingConfig(
                    JsonField.of(scalableMatrixWithUnitPricingConfig)
                )

            /**
             * Sets [Builder.scalableMatrixWithUnitPricingConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.scalableMatrixWithUnitPricingConfig] with a
             * well-typed [ScalableMatrixWithUnitPricingConfig] value instead. This method is
             * primarily for setting the field to an undocumented or not yet supported value.
             */
            fun scalableMatrixWithUnitPricingConfig(
                scalableMatrixWithUnitPricingConfig: JsonField<ScalableMatrixWithUnitPricingConfig>
            ) = apply {
                this.scalableMatrixWithUnitPricingConfig = scalableMatrixWithUnitPricingConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [ScalableMatrixWithUnitPricing].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .scalableMatrixWithUnitPricingConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): ScalableMatrixWithUnitPricing =
                ScalableMatrixWithUnitPricing(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired(
                        "scalableMatrixWithUnitPricingConfig",
                        scalableMatrixWithUnitPricingConfig,
                    ),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): ScalableMatrixWithUnitPricing = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("scalable_matrix_with_unit_pricing")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            scalableMatrixWithUnitPricingConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let {
                    if (it == JsonValue.from("scalable_matrix_with_unit_pricing")) 1 else 0
                } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (scalableMatrixWithUnitPricingConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ScalableMatrixWithUnitPricingConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [ScalableMatrixWithUnitPricingConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [ScalableMatrixWithUnitPricingConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    scalableMatrixWithUnitPricingConfig: ScalableMatrixWithUnitPricingConfig
                ) = apply {
                    additionalProperties =
                        scalableMatrixWithUnitPricingConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [ScalableMatrixWithUnitPricingConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): ScalableMatrixWithUnitPricingConfig =
                    ScalableMatrixWithUnitPricingConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): ScalableMatrixWithUnitPricingConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ScalableMatrixWithUnitPricingConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "ScalableMatrixWithUnitPricingConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is ScalableMatrixWithUnitPricing && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && scalableMatrixWithUnitPricingConfig == other.scalableMatrixWithUnitPricingConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, scalableMatrixWithUnitPricingConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "ScalableMatrixWithUnitPricing{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, scalableMatrixWithUnitPricingConfig=$scalableMatrixWithUnitPricingConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class ScalableMatrixWithTieredPricing
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val scalableMatrixWithTieredPricingConfig:
            JsonField<ScalableMatrixWithTieredPricingConfig>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("scalable_matrix_with_tiered_pricing_config")
            @ExcludeMissing
            scalableMatrixWithTieredPricingConfig:
                JsonField<ScalableMatrixWithTieredPricingConfig> =
                JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            scalableMatrixWithTieredPricingConfig,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("scalable_matrix_with_tiered_pricing")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun scalableMatrixWithTieredPricingConfig(): ScalableMatrixWithTieredPricingConfig =
            scalableMatrixWithTieredPricingConfig.getRequired(
                "scalable_matrix_with_tiered_pricing_config"
            )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [scalableMatrixWithTieredPricingConfig].
         *
         * Unlike [scalableMatrixWithTieredPricingConfig], this method doesn't throw if the JSON
         * field has an unexpected type.
         */
        @JsonProperty("scalable_matrix_with_tiered_pricing_config")
        @ExcludeMissing
        fun _scalableMatrixWithTieredPricingConfig():
            JsonField<ScalableMatrixWithTieredPricingConfig> = scalableMatrixWithTieredPricingConfig

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [ScalableMatrixWithTieredPricing].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .scalableMatrixWithTieredPricingConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [ScalableMatrixWithTieredPricing]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("scalable_matrix_with_tiered_pricing")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var scalableMatrixWithTieredPricingConfig:
                JsonField<ScalableMatrixWithTieredPricingConfig>? =
                null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(scalableMatrixWithTieredPricing: ScalableMatrixWithTieredPricing) =
                apply {
                    id = scalableMatrixWithTieredPricing.id
                    billableMetric = scalableMatrixWithTieredPricing.billableMetric
                    billingCycleConfiguration =
                        scalableMatrixWithTieredPricing.billingCycleConfiguration
                    cadence = scalableMatrixWithTieredPricing.cadence
                    conversionRate = scalableMatrixWithTieredPricing.conversionRate
                    conversionRateConfig = scalableMatrixWithTieredPricing.conversionRateConfig
                    createdAt = scalableMatrixWithTieredPricing.createdAt
                    creditAllocation = scalableMatrixWithTieredPricing.creditAllocation
                    currency = scalableMatrixWithTieredPricing.currency
                    discount = scalableMatrixWithTieredPricing.discount
                    externalPriceId = scalableMatrixWithTieredPricing.externalPriceId
                    fixedPriceQuantity = scalableMatrixWithTieredPricing.fixedPriceQuantity
                    invoicingCycleConfiguration =
                        scalableMatrixWithTieredPricing.invoicingCycleConfiguration
                    item = scalableMatrixWithTieredPricing.item
                    maximum = scalableMatrixWithTieredPricing.maximum
                    maximumAmount = scalableMatrixWithTieredPricing.maximumAmount
                    metadata = scalableMatrixWithTieredPricing.metadata
                    minimum = scalableMatrixWithTieredPricing.minimum
                    minimumAmount = scalableMatrixWithTieredPricing.minimumAmount
                    modelType = scalableMatrixWithTieredPricing.modelType
                    name = scalableMatrixWithTieredPricing.name
                    planPhaseOrder = scalableMatrixWithTieredPricing.planPhaseOrder
                    priceType = scalableMatrixWithTieredPricing.priceType
                    replacesPriceId = scalableMatrixWithTieredPricing.replacesPriceId
                    scalableMatrixWithTieredPricingConfig =
                        scalableMatrixWithTieredPricing.scalableMatrixWithTieredPricingConfig
                    dimensionalPriceConfiguration =
                        scalableMatrixWithTieredPricing.dimensionalPriceConfiguration
                    additionalProperties =
                        scalableMatrixWithTieredPricing.additionalProperties.toMutableMap()
                }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("scalable_matrix_with_tiered_pricing")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun scalableMatrixWithTieredPricingConfig(
                scalableMatrixWithTieredPricingConfig: ScalableMatrixWithTieredPricingConfig
            ) =
                scalableMatrixWithTieredPricingConfig(
                    JsonField.of(scalableMatrixWithTieredPricingConfig)
                )

            /**
             * Sets [Builder.scalableMatrixWithTieredPricingConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.scalableMatrixWithTieredPricingConfig] with a
             * well-typed [ScalableMatrixWithTieredPricingConfig] value instead. This method is
             * primarily for setting the field to an undocumented or not yet supported value.
             */
            fun scalableMatrixWithTieredPricingConfig(
                scalableMatrixWithTieredPricingConfig:
                    JsonField<ScalableMatrixWithTieredPricingConfig>
            ) = apply {
                this.scalableMatrixWithTieredPricingConfig = scalableMatrixWithTieredPricingConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [ScalableMatrixWithTieredPricing].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * .scalableMatrixWithTieredPricingConfig()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): ScalableMatrixWithTieredPricing =
                ScalableMatrixWithTieredPricing(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    checkRequired(
                        "scalableMatrixWithTieredPricingConfig",
                        scalableMatrixWithTieredPricingConfig,
                    ),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): ScalableMatrixWithTieredPricing = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("scalable_matrix_with_tiered_pricing")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            scalableMatrixWithTieredPricingConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let {
                    if (it == JsonValue.from("scalable_matrix_with_tiered_pricing")) 1 else 0
                } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (scalableMatrixWithTieredPricingConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class ScalableMatrixWithTieredPricingConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [ScalableMatrixWithTieredPricingConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [ScalableMatrixWithTieredPricingConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    scalableMatrixWithTieredPricingConfig: ScalableMatrixWithTieredPricingConfig
                ) = apply {
                    additionalProperties =
                        scalableMatrixWithTieredPricingConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [ScalableMatrixWithTieredPricingConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): ScalableMatrixWithTieredPricingConfig =
                    ScalableMatrixWithTieredPricingConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): ScalableMatrixWithTieredPricingConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ScalableMatrixWithTieredPricingConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "ScalableMatrixWithTieredPricingConfig{additionalProperties=$additionalProperties}"
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is ScalableMatrixWithTieredPricing && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && scalableMatrixWithTieredPricingConfig == other.scalableMatrixWithTieredPricingConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, scalableMatrixWithTieredPricingConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "ScalableMatrixWithTieredPricing{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, scalableMatrixWithTieredPricingConfig=$scalableMatrixWithTieredPricingConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class CumulativeGroupedBulk
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val cumulativeGroupedBulkConfig: JsonField<CumulativeGroupedBulkConfig>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("cumulative_grouped_bulk_config")
            @ExcludeMissing
            cumulativeGroupedBulkConfig: JsonField<CumulativeGroupedBulkConfig> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            cumulativeGroupedBulkConfig,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cumulativeGroupedBulkConfig(): CumulativeGroupedBulkConfig =
            cumulativeGroupedBulkConfig.getRequired("cumulative_grouped_bulk_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("cumulative_grouped_bulk")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [cumulativeGroupedBulkConfig].
         *
         * Unlike [cumulativeGroupedBulkConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("cumulative_grouped_bulk_config")
        @ExcludeMissing
        fun _cumulativeGroupedBulkConfig(): JsonField<CumulativeGroupedBulkConfig> =
            cumulativeGroupedBulkConfig

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [CumulativeGroupedBulk].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .cumulativeGroupedBulkConfig()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [CumulativeGroupedBulk]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var cumulativeGroupedBulkConfig: JsonField<CumulativeGroupedBulkConfig>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("cumulative_grouped_bulk")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(cumulativeGroupedBulk: CumulativeGroupedBulk) = apply {
                id = cumulativeGroupedBulk.id
                billableMetric = cumulativeGroupedBulk.billableMetric
                billingCycleConfiguration = cumulativeGroupedBulk.billingCycleConfiguration
                cadence = cumulativeGroupedBulk.cadence
                conversionRate = cumulativeGroupedBulk.conversionRate
                conversionRateConfig = cumulativeGroupedBulk.conversionRateConfig
                createdAt = cumulativeGroupedBulk.createdAt
                creditAllocation = cumulativeGroupedBulk.creditAllocation
                cumulativeGroupedBulkConfig = cumulativeGroupedBulk.cumulativeGroupedBulkConfig
                currency = cumulativeGroupedBulk.currency
                discount = cumulativeGroupedBulk.discount
                externalPriceId = cumulativeGroupedBulk.externalPriceId
                fixedPriceQuantity = cumulativeGroupedBulk.fixedPriceQuantity
                invoicingCycleConfiguration = cumulativeGroupedBulk.invoicingCycleConfiguration
                item = cumulativeGroupedBulk.item
                maximum = cumulativeGroupedBulk.maximum
                maximumAmount = cumulativeGroupedBulk.maximumAmount
                metadata = cumulativeGroupedBulk.metadata
                minimum = cumulativeGroupedBulk.minimum
                minimumAmount = cumulativeGroupedBulk.minimumAmount
                modelType = cumulativeGroupedBulk.modelType
                name = cumulativeGroupedBulk.name
                planPhaseOrder = cumulativeGroupedBulk.planPhaseOrder
                priceType = cumulativeGroupedBulk.priceType
                replacesPriceId = cumulativeGroupedBulk.replacesPriceId
                dimensionalPriceConfiguration = cumulativeGroupedBulk.dimensionalPriceConfiguration
                additionalProperties = cumulativeGroupedBulk.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun cumulativeGroupedBulkConfig(
                cumulativeGroupedBulkConfig: CumulativeGroupedBulkConfig
            ) = cumulativeGroupedBulkConfig(JsonField.of(cumulativeGroupedBulkConfig))

            /**
             * Sets [Builder.cumulativeGroupedBulkConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cumulativeGroupedBulkConfig] with a well-typed
             * [CumulativeGroupedBulkConfig] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun cumulativeGroupedBulkConfig(
                cumulativeGroupedBulkConfig: JsonField<CumulativeGroupedBulkConfig>
            ) = apply { this.cumulativeGroupedBulkConfig = cumulativeGroupedBulkConfig }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("cumulative_grouped_bulk")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [CumulativeGroupedBulk].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .cumulativeGroupedBulkConfig()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): CumulativeGroupedBulk =
                CumulativeGroupedBulk(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("cumulativeGroupedBulkConfig", cumulativeGroupedBulkConfig),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): CumulativeGroupedBulk = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            cumulativeGroupedBulkConfig().validate()
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("cumulative_grouped_bulk")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (cumulativeGroupedBulkConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let { if (it == JsonValue.from("cumulative_grouped_bulk")) 1 else 0 } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        class CumulativeGroupedBulkConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [CumulativeGroupedBulkConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [CumulativeGroupedBulkConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(cumulativeGroupedBulkConfig: CumulativeGroupedBulkConfig) =
                    apply {
                        additionalProperties =
                            cumulativeGroupedBulkConfig.additionalProperties.toMutableMap()
                    }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [CumulativeGroupedBulkConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): CumulativeGroupedBulkConfig =
                    CumulativeGroupedBulkConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): CumulativeGroupedBulkConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is CumulativeGroupedBulkConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "CumulativeGroupedBulkConfig{additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is CumulativeGroupedBulk && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && cumulativeGroupedBulkConfig == other.cumulativeGroupedBulkConfig && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, cumulativeGroupedBulkConfig, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "CumulativeGroupedBulk{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, cumulativeGroupedBulkConfig=$cumulativeGroupedBulkConfig, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    class GroupedWithMinMaxThresholds
    private constructor(
        private val id: JsonField<String>,
        private val billableMetric: JsonField<BillableMetricTiny>,
        private val billingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val cadence: JsonField<Cadence>,
        private val conversionRate: JsonField<Double>,
        private val conversionRateConfig: JsonField<ConversionRateConfig>,
        private val createdAt: JsonField<OffsetDateTime>,
        private val creditAllocation: JsonField<Allocation>,
        private val currency: JsonField<String>,
        private val discount: JsonField<Discount>,
        private val externalPriceId: JsonField<String>,
        private val fixedPriceQuantity: JsonField<Double>,
        private val groupedWithMinMaxThresholdsConfig: JsonField<GroupedWithMinMaxThresholdsConfig>,
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>,
        private val item: JsonField<ItemSlim>,
        private val maximum: JsonField<Maximum>,
        private val maximumAmount: JsonField<String>,
        private val metadata: JsonField<Metadata>,
        private val minimum: JsonField<Minimum>,
        private val minimumAmount: JsonField<String>,
        private val modelType: JsonValue,
        private val name: JsonField<String>,
        private val planPhaseOrder: JsonField<Long>,
        private val priceType: JsonField<PriceType>,
        private val replacesPriceId: JsonField<String>,
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>,
        private val additionalProperties: MutableMap<String, JsonValue>,
    ) {

        @JsonCreator
        private constructor(
            @JsonProperty("id") @ExcludeMissing id: JsonField<String> = JsonMissing.of(),
            @JsonProperty("billable_metric")
            @ExcludeMissing
            billableMetric: JsonField<BillableMetricTiny> = JsonMissing.of(),
            @JsonProperty("billing_cycle_configuration")
            @ExcludeMissing
            billingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("cadence") @ExcludeMissing cadence: JsonField<Cadence> = JsonMissing.of(),
            @JsonProperty("conversion_rate")
            @ExcludeMissing
            conversionRate: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("conversion_rate_config")
            @ExcludeMissing
            conversionRateConfig: JsonField<ConversionRateConfig> = JsonMissing.of(),
            @JsonProperty("created_at")
            @ExcludeMissing
            createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
            @JsonProperty("credit_allocation")
            @ExcludeMissing
            creditAllocation: JsonField<Allocation> = JsonMissing.of(),
            @JsonProperty("currency")
            @ExcludeMissing
            currency: JsonField<String> = JsonMissing.of(),
            @JsonProperty("discount")
            @ExcludeMissing
            discount: JsonField<Discount> = JsonMissing.of(),
            @JsonProperty("external_price_id")
            @ExcludeMissing
            externalPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("fixed_price_quantity")
            @ExcludeMissing
            fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
            @JsonProperty("grouped_with_min_max_thresholds_config")
            @ExcludeMissing
            groupedWithMinMaxThresholdsConfig: JsonField<GroupedWithMinMaxThresholdsConfig> =
                JsonMissing.of(),
            @JsonProperty("invoicing_cycle_configuration")
            @ExcludeMissing
            invoicingCycleConfiguration: JsonField<BillingCycleConfiguration> = JsonMissing.of(),
            @JsonProperty("item") @ExcludeMissing item: JsonField<ItemSlim> = JsonMissing.of(),
            @JsonProperty("maximum") @ExcludeMissing maximum: JsonField<Maximum> = JsonMissing.of(),
            @JsonProperty("maximum_amount")
            @ExcludeMissing
            maximumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("metadata")
            @ExcludeMissing
            metadata: JsonField<Metadata> = JsonMissing.of(),
            @JsonProperty("minimum") @ExcludeMissing minimum: JsonField<Minimum> = JsonMissing.of(),
            @JsonProperty("minimum_amount")
            @ExcludeMissing
            minimumAmount: JsonField<String> = JsonMissing.of(),
            @JsonProperty("model_type") @ExcludeMissing modelType: JsonValue = JsonMissing.of(),
            @JsonProperty("name") @ExcludeMissing name: JsonField<String> = JsonMissing.of(),
            @JsonProperty("plan_phase_order")
            @ExcludeMissing
            planPhaseOrder: JsonField<Long> = JsonMissing.of(),
            @JsonProperty("price_type")
            @ExcludeMissing
            priceType: JsonField<PriceType> = JsonMissing.of(),
            @JsonProperty("replaces_price_id")
            @ExcludeMissing
            replacesPriceId: JsonField<String> = JsonMissing.of(),
            @JsonProperty("dimensional_price_configuration")
            @ExcludeMissing
            dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of(),
        ) : this(
            id,
            billableMetric,
            billingCycleConfiguration,
            cadence,
            conversionRate,
            conversionRateConfig,
            createdAt,
            creditAllocation,
            currency,
            discount,
            externalPriceId,
            fixedPriceQuantity,
            groupedWithMinMaxThresholdsConfig,
            invoicingCycleConfiguration,
            item,
            maximum,
            maximumAmount,
            metadata,
            minimum,
            minimumAmount,
            modelType,
            name,
            planPhaseOrder,
            priceType,
            replacesPriceId,
            dimensionalPriceConfiguration,
            mutableMapOf(),
        )

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun id(): String = id.getRequired("id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun billableMetric(): Optional<BillableMetricTiny> =
            billableMetric.getOptional("billable_metric")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun billingCycleConfiguration(): BillingCycleConfiguration =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun cadence(): Cadence = cadence.getRequired("cadence")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRate(): Optional<Double> = conversionRate.getOptional("conversion_rate")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun conversionRateConfig(): Optional<ConversionRateConfig> =
            conversionRateConfig.getOptional("conversion_rate_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun creditAllocation(): Optional<Allocation> =
            creditAllocation.getOptional("credit_allocation")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun currency(): String = currency.getRequired("currency")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun discount(): Optional<Discount> = discount.getOptional("discount")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalPriceId(): Optional<String> = externalPriceId.getOptional("external_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun fixedPriceQuantity(): Optional<Double> =
            fixedPriceQuantity.getOptional("fixed_price_quantity")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun groupedWithMinMaxThresholdsConfig(): GroupedWithMinMaxThresholdsConfig =
            groupedWithMinMaxThresholdsConfig.getRequired("grouped_with_min_max_thresholds_config")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun invoicingCycleConfiguration(): Optional<BillingCycleConfiguration> =
            invoicingCycleConfiguration.getOptional("invoicing_cycle_configuration")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun item(): ItemSlim = item.getRequired("item")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun maximum(): Optional<Maximum> = maximum.getOptional("maximum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun maximumAmount(): Optional<String> = maximumAmount.getOptional("maximum_amount")

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated") fun minimum(): Optional<Minimum> = minimum.getOptional("minimum")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        @Deprecated("deprecated")
        fun minimumAmount(): Optional<String> = minimumAmount.getOptional("minimum_amount")

        /**
         * Expected to always return the following:
         * ```java
         * JsonValue.from("grouped_with_min_max_thresholds")
         * ```
         *
         * However, this method can be useful for debugging and logging (e.g. if the server
         * responded with an unexpected value).
         */
        @JsonProperty("model_type") @ExcludeMissing fun _modelType(): JsonValue = modelType

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun name(): String = name.getRequired("name")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun planPhaseOrder(): Optional<Long> = planPhaseOrder.getOptional("plan_phase_order")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun priceType(): PriceType = priceType.getRequired("price_type")

        /**
         * The price id this price replaces. This price will take the place of the replaced price in
         * plan version migrations.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun replacesPriceId(): Optional<String> = replacesPriceId.getOptional("replaces_price_id")

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration.getOptional("dimensional_price_configuration")

        /**
         * Returns the raw JSON value of [id].
         *
         * Unlike [id], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        /**
         * Returns the raw JSON value of [billableMetric].
         *
         * Unlike [billableMetric], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTiny> = billableMetric

        /**
         * Returns the raw JSON value of [billingCycleConfiguration].
         *
         * Unlike [billingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            billingCycleConfiguration

        /**
         * Returns the raw JSON value of [cadence].
         *
         * Unlike [cadence], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        /**
         * Returns the raw JSON value of [conversionRate].
         *
         * Unlike [conversionRate], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        /**
         * Returns the raw JSON value of [conversionRateConfig].
         *
         * Unlike [conversionRateConfig], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("conversion_rate_config")
        @ExcludeMissing
        fun _conversionRateConfig(): JsonField<ConversionRateConfig> = conversionRateConfig

        /**
         * Returns the raw JSON value of [createdAt].
         *
         * Unlike [createdAt], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        /**
         * Returns the raw JSON value of [creditAllocation].
         *
         * Unlike [creditAllocation], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<Allocation> = creditAllocation

        /**
         * Returns the raw JSON value of [currency].
         *
         * Unlike [currency], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        /**
         * Returns the raw JSON value of [discount].
         *
         * Unlike [discount], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("discount")
        @ExcludeMissing
        fun _discount(): JsonField<Discount> = discount

        /**
         * Returns the raw JSON value of [externalPriceId].
         *
         * Unlike [externalPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        /**
         * Returns the raw JSON value of [fixedPriceQuantity].
         *
         * Unlike [fixedPriceQuantity], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        /**
         * Returns the raw JSON value of [groupedWithMinMaxThresholdsConfig].
         *
         * Unlike [groupedWithMinMaxThresholdsConfig], this method doesn't throw if the JSON field
         * has an unexpected type.
         */
        @JsonProperty("grouped_with_min_max_thresholds_config")
        @ExcludeMissing
        fun _groupedWithMinMaxThresholdsConfig(): JsonField<GroupedWithMinMaxThresholdsConfig> =
            groupedWithMinMaxThresholdsConfig

        /**
         * Returns the raw JSON value of [invoicingCycleConfiguration].
         *
         * Unlike [invoicingCycleConfiguration], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfiguration> =
            invoicingCycleConfiguration

        /**
         * Returns the raw JSON value of [item].
         *
         * Unlike [item], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlim> = item

        /**
         * Returns the raw JSON value of [maximum].
         *
         * Unlike [maximum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum")
        @ExcludeMissing
        fun _maximum(): JsonField<Maximum> = maximum

        /**
         * Returns the raw JSON value of [maximumAmount].
         *
         * Unlike [maximumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * Returns the raw JSON value of [metadata].
         *
         * Unlike [metadata], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        /**
         * Returns the raw JSON value of [minimum].
         *
         * Unlike [minimum], this method doesn't throw if the JSON field has an unexpected type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum")
        @ExcludeMissing
        fun _minimum(): JsonField<Minimum> = minimum

        /**
         * Returns the raw JSON value of [minimumAmount].
         *
         * Unlike [minimumAmount], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @Deprecated("deprecated")
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        /**
         * Returns the raw JSON value of [name].
         *
         * Unlike [name], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        /**
         * Returns the raw JSON value of [planPhaseOrder].
         *
         * Unlike [planPhaseOrder], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        /**
         * Returns the raw JSON value of [priceType].
         *
         * Unlike [priceType], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        /**
         * Returns the raw JSON value of [replacesPriceId].
         *
         * Unlike [replacesPriceId], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("replaces_price_id")
        @ExcludeMissing
        fun _replacesPriceId(): JsonField<String> = replacesPriceId

        /**
         * Returns the raw JSON value of [dimensionalPriceConfiguration].
         *
         * Unlike [dimensionalPriceConfiguration], this method doesn't throw if the JSON field has
         * an unexpected type.
         */
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfiguration> =
            dimensionalPriceConfiguration

        @JsonAnySetter
        private fun putAdditionalProperty(key: String, value: JsonValue) {
            additionalProperties.put(key, value)
        }

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> =
            Collections.unmodifiableMap(additionalProperties)

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [GroupedWithMinMaxThresholds].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithMinMaxThresholdsConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedWithMinMaxThresholds]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTiny>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var conversionRateConfig: JsonField<ConversionRateConfig>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<Allocation>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedWithMinMaxThresholdsConfig:
                JsonField<GroupedWithMinMaxThresholdsConfig>? =
                null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>? = null
            private var item: JsonField<ItemSlim>? = null
            private var maximum: JsonField<Maximum>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<Minimum>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonValue = JsonValue.from("grouped_with_min_max_thresholds")
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var replacesPriceId: JsonField<String>? = null
            private var dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedWithMinMaxThresholds: GroupedWithMinMaxThresholds) = apply {
                id = groupedWithMinMaxThresholds.id
                billableMetric = groupedWithMinMaxThresholds.billableMetric
                billingCycleConfiguration = groupedWithMinMaxThresholds.billingCycleConfiguration
                cadence = groupedWithMinMaxThresholds.cadence
                conversionRate = groupedWithMinMaxThresholds.conversionRate
                conversionRateConfig = groupedWithMinMaxThresholds.conversionRateConfig
                createdAt = groupedWithMinMaxThresholds.createdAt
                creditAllocation = groupedWithMinMaxThresholds.creditAllocation
                currency = groupedWithMinMaxThresholds.currency
                discount = groupedWithMinMaxThresholds.discount
                externalPriceId = groupedWithMinMaxThresholds.externalPriceId
                fixedPriceQuantity = groupedWithMinMaxThresholds.fixedPriceQuantity
                groupedWithMinMaxThresholdsConfig =
                    groupedWithMinMaxThresholds.groupedWithMinMaxThresholdsConfig
                invoicingCycleConfiguration =
                    groupedWithMinMaxThresholds.invoicingCycleConfiguration
                item = groupedWithMinMaxThresholds.item
                maximum = groupedWithMinMaxThresholds.maximum
                maximumAmount = groupedWithMinMaxThresholds.maximumAmount
                metadata = groupedWithMinMaxThresholds.metadata
                minimum = groupedWithMinMaxThresholds.minimum
                minimumAmount = groupedWithMinMaxThresholds.minimumAmount
                modelType = groupedWithMinMaxThresholds.modelType
                name = groupedWithMinMaxThresholds.name
                planPhaseOrder = groupedWithMinMaxThresholds.planPhaseOrder
                priceType = groupedWithMinMaxThresholds.priceType
                replacesPriceId = groupedWithMinMaxThresholds.replacesPriceId
                dimensionalPriceConfiguration =
                    groupedWithMinMaxThresholds.dimensionalPriceConfiguration
                additionalProperties =
                    groupedWithMinMaxThresholds.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            /**
             * Sets [Builder.id] to an arbitrary JSON value.
             *
             * You should usually call [Builder.id] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTiny?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            /** Alias for calling [Builder.billableMetric] with `billableMetric.orElse(null)`. */
            fun billableMetric(billableMetric: Optional<BillableMetricTiny>) =
                billableMetric(billableMetric.getOrNull())

            /**
             * Sets [Builder.billableMetric] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billableMetric] with a well-typed
             * [BillableMetricTiny] value instead. This method is primarily for setting the field to
             * an undocumented or not yet supported value.
             */
            fun billableMetric(billableMetric: JsonField<BillableMetricTiny>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(billingCycleConfiguration: BillingCycleConfiguration) =
                billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            /**
             * Sets [Builder.billingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.billingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            /**
             * Sets [Builder.cadence] to an arbitrary JSON value.
             *
             * You should usually call [Builder.cadence] with a well-typed [Cadence] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            /**
             * Alias for [Builder.conversionRate].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            /** Alias for calling [Builder.conversionRate] with `conversionRate.orElse(null)`. */
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.getOrNull())

            /**
             * Sets [Builder.conversionRate] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRate] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun conversionRateConfig(conversionRateConfig: ConversionRateConfig?) =
                conversionRateConfig(JsonField.ofNullable(conversionRateConfig))

            /**
             * Alias for calling [Builder.conversionRateConfig] with
             * `conversionRateConfig.orElse(null)`.
             */
            fun conversionRateConfig(conversionRateConfig: Optional<ConversionRateConfig>) =
                conversionRateConfig(conversionRateConfig.getOrNull())

            /**
             * Sets [Builder.conversionRateConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.conversionRateConfig] with a well-typed
             * [ConversionRateConfig] value instead. This method is primarily for setting the field
             * to an undocumented or not yet supported value.
             */
            fun conversionRateConfig(conversionRateConfig: JsonField<ConversionRateConfig>) =
                apply {
                    this.conversionRateConfig = conversionRateConfig
                }

            /**
             * Alias for calling [conversionRateConfig] with `ConversionRateConfig.ofUnit(unit)`.
             */
            fun conversionRateConfig(unit: UnitConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofUnit(unit))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * UnitConversionRateConfig.builder()
             *     .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
             *     .unitConfig(unitConfig)
             *     .build()
             * ```
             */
            fun unitConversionRateConfig(unitConfig: ConversionRateUnitConfig) =
                conversionRateConfig(
                    UnitConversionRateConfig.builder()
                        .conversionRateType(UnitConversionRateConfig.ConversionRateType.UNIT)
                        .unitConfig(unitConfig)
                        .build()
                )

            /**
             * Alias for calling [conversionRateConfig] with
             * `ConversionRateConfig.ofTiered(tiered)`.
             */
            fun conversionRateConfig(tiered: TieredConversionRateConfig) =
                conversionRateConfig(ConversionRateConfig.ofTiered(tiered))

            /**
             * Alias for calling [conversionRateConfig] with the following:
             * ```java
             * TieredConversionRateConfig.builder()
             *     .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
             *     .tieredConfig(tieredConfig)
             *     .build()
             * ```
             */
            fun tieredConversionRateConfig(tieredConfig: ConversionRateTieredConfig) =
                conversionRateConfig(
                    TieredConversionRateConfig.builder()
                        .conversionRateType(TieredConversionRateConfig.ConversionRateType.TIERED)
                        .tieredConfig(tieredConfig)
                        .build()
                )

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            /**
             * Sets [Builder.createdAt] to an arbitrary JSON value.
             *
             * You should usually call [Builder.createdAt] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: Allocation?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            /**
             * Alias for calling [Builder.creditAllocation] with `creditAllocation.orElse(null)`.
             */
            fun creditAllocation(creditAllocation: Optional<Allocation>) =
                creditAllocation(creditAllocation.getOrNull())

            /**
             * Sets [Builder.creditAllocation] to an arbitrary JSON value.
             *
             * You should usually call [Builder.creditAllocation] with a well-typed [Allocation]
             * value instead. This method is primarily for setting the field to an undocumented or
             * not yet supported value.
             */
            fun creditAllocation(creditAllocation: JsonField<Allocation>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            /**
             * Sets [Builder.currency] to an arbitrary JSON value.
             *
             * You should usually call [Builder.currency] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            @Deprecated("deprecated")
            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            /** Alias for calling [Builder.discount] with `discount.orElse(null)`. */
            @Deprecated("deprecated")
            fun discount(discount: Optional<Discount>) = discount(discount.getOrNull())

            /**
             * Sets [Builder.discount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.discount] with a well-typed [Discount] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            /** Alias for calling [discount] with `Discount.ofPercentage(percentage)`. */
            @Deprecated("deprecated")
            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * PercentageDiscount.builder()
             *     .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
             *     .percentageDiscount(percentageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun percentageDiscount(percentageDiscount: Double) =
                discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(percentageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofTrial(trial)`. */
            @Deprecated("deprecated")
            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            /** Alias for calling [discount] with `Discount.ofUsage(usage)`. */
            @Deprecated("deprecated")
            fun discount(usage: UsageDiscount) = discount(Discount.ofUsage(usage))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * UsageDiscount.builder()
             *     .discountType(UsageDiscount.DiscountType.USAGE)
             *     .usageDiscount(usageDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun usageDiscount(usageDiscount: Double) =
                discount(
                    UsageDiscount.builder()
                        .discountType(UsageDiscount.DiscountType.USAGE)
                        .usageDiscount(usageDiscount)
                        .build()
                )

            /** Alias for calling [discount] with `Discount.ofAmount(amount)`. */
            @Deprecated("deprecated")
            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            /**
             * Alias for calling [discount] with the following:
             * ```java
             * AmountDiscount.builder()
             *     .discountType(AmountDiscount.DiscountType.AMOUNT)
             *     .amountDiscount(amountDiscount)
             *     .build()
             * ```
             */
            @Deprecated("deprecated")
            fun amountDiscount(amountDiscount: String) =
                discount(
                    AmountDiscount.builder()
                        .discountType(AmountDiscount.DiscountType.AMOUNT)
                        .amountDiscount(amountDiscount)
                        .build()
                )

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            /** Alias for calling [Builder.externalPriceId] with `externalPriceId.orElse(null)`. */
            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.getOrNull())

            /**
             * Sets [Builder.externalPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            /**
             * Alias for [Builder.fixedPriceQuantity].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            /**
             * Alias for calling [Builder.fixedPriceQuantity] with
             * `fixedPriceQuantity.orElse(null)`.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.getOrNull())

            /**
             * Sets [Builder.fixedPriceQuantity] to an arbitrary JSON value.
             *
             * You should usually call [Builder.fixedPriceQuantity] with a well-typed [Double] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedWithMinMaxThresholdsConfig(
                groupedWithMinMaxThresholdsConfig: GroupedWithMinMaxThresholdsConfig
            ) = groupedWithMinMaxThresholdsConfig(JsonField.of(groupedWithMinMaxThresholdsConfig))

            /**
             * Sets [Builder.groupedWithMinMaxThresholdsConfig] to an arbitrary JSON value.
             *
             * You should usually call [Builder.groupedWithMinMaxThresholdsConfig] with a well-typed
             * [GroupedWithMinMaxThresholdsConfig] value instead. This method is primarily for
             * setting the field to an undocumented or not yet supported value.
             */
            fun groupedWithMinMaxThresholdsConfig(
                groupedWithMinMaxThresholdsConfig: JsonField<GroupedWithMinMaxThresholdsConfig>
            ) = apply { this.groupedWithMinMaxThresholdsConfig = groupedWithMinMaxThresholdsConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfiguration?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            /**
             * Alias for calling [Builder.invoicingCycleConfiguration] with
             * `invoicingCycleConfiguration.orElse(null)`.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfiguration>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.getOrNull())

            /**
             * Sets [Builder.invoicingCycleConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.invoicingCycleConfiguration] with a well-typed
             * [BillingCycleConfiguration] value instead. This method is primarily for setting the
             * field to an undocumented or not yet supported value.
             */
            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfiguration>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlim) = item(JsonField.of(item))

            /**
             * Sets [Builder.item] to an arbitrary JSON value.
             *
             * You should usually call [Builder.item] with a well-typed [ItemSlim] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun item(item: JsonField<ItemSlim>) = apply { this.item = item }

            @Deprecated("deprecated")
            fun maximum(maximum: Maximum?) = maximum(JsonField.ofNullable(maximum))

            /** Alias for calling [Builder.maximum] with `maximum.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximum(maximum: Optional<Maximum>) = maximum(maximum.getOrNull())

            /**
             * Sets [Builder.maximum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximum] with a well-typed [Maximum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximum(maximum: JsonField<Maximum>) = apply { this.maximum = maximum }

            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            /** Alias for calling [Builder.maximumAmount] with `maximumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.getOrNull())

            /**
             * Sets [Builder.maximumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.maximumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * Sets [Builder.metadata] to an arbitrary JSON value.
             *
             * You should usually call [Builder.metadata] with a well-typed [Metadata] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            @Deprecated("deprecated")
            fun minimum(minimum: Minimum?) = minimum(JsonField.ofNullable(minimum))

            /** Alias for calling [Builder.minimum] with `minimum.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimum(minimum: Optional<Minimum>) = minimum(minimum.getOrNull())

            /**
             * Sets [Builder.minimum] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimum] with a well-typed [Minimum] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimum(minimum: JsonField<Minimum>) = apply { this.minimum = minimum }

            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            /** Alias for calling [Builder.minimumAmount] with `minimumAmount.orElse(null)`. */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.getOrNull())

            /**
             * Sets [Builder.minimumAmount] to an arbitrary JSON value.
             *
             * You should usually call [Builder.minimumAmount] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            @Deprecated("deprecated")
            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            /**
             * Sets the field to an arbitrary JSON value.
             *
             * It is usually unnecessary to call this method because the field defaults to the
             * following:
             * ```java
             * JsonValue.from("grouped_with_min_max_thresholds")
             * ```
             *
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun modelType(modelType: JsonValue) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            /**
             * Sets [Builder.name] to an arbitrary JSON value.
             *
             * You should usually call [Builder.name] with a well-typed [String] value instead. This
             * method is primarily for setting the field to an undocumented or not yet supported
             * value.
             */
            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            /**
             * Alias for [Builder.planPhaseOrder].
             *
             * This unboxed primitive overload exists for backwards compatibility.
             */
            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            /** Alias for calling [Builder.planPhaseOrder] with `planPhaseOrder.orElse(null)`. */
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.getOrNull())

            /**
             * Sets [Builder.planPhaseOrder] to an arbitrary JSON value.
             *
             * You should usually call [Builder.planPhaseOrder] with a well-typed [Long] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            /**
             * Sets [Builder.priceType] to an arbitrary JSON value.
             *
             * You should usually call [Builder.priceType] with a well-typed [PriceType] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            /**
             * The price id this price replaces. This price will take the place of the replaced
             * price in plan version migrations.
             */
            fun replacesPriceId(replacesPriceId: String?) =
                replacesPriceId(JsonField.ofNullable(replacesPriceId))

            /** Alias for calling [Builder.replacesPriceId] with `replacesPriceId.orElse(null)`. */
            fun replacesPriceId(replacesPriceId: Optional<String>) =
                replacesPriceId(replacesPriceId.getOrNull())

            /**
             * Sets [Builder.replacesPriceId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.replacesPriceId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun replacesPriceId(replacesPriceId: JsonField<String>) = apply {
                this.replacesPriceId = replacesPriceId
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfiguration?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            /**
             * Alias for calling [Builder.dimensionalPriceConfiguration] with
             * `dimensionalPriceConfiguration.orElse(null)`.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfiguration>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.getOrNull())

            /**
             * Sets [Builder.dimensionalPriceConfiguration] to an arbitrary JSON value.
             *
             * You should usually call [Builder.dimensionalPriceConfiguration] with a well-typed
             * [DimensionalPriceConfiguration] value instead. This method is primarily for setting
             * the field to an undocumented or not yet supported value.
             */
            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfiguration>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [GroupedWithMinMaxThresholds].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .conversionRateConfig()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithMinMaxThresholdsConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .replacesPriceId()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): GroupedWithMinMaxThresholds =
                GroupedWithMinMaxThresholds(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("conversionRateConfig", conversionRateConfig),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired(
                        "groupedWithMinMaxThresholdsConfig",
                        groupedWithMinMaxThresholdsConfig,
                    ),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    modelType,
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("replacesPriceId", replacesPriceId),
                    dimensionalPriceConfiguration,
                    additionalProperties.toMutableMap(),
                )
        }

        private var validated: Boolean = false

        fun validate(): GroupedWithMinMaxThresholds = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence().validate()
            conversionRate()
            conversionRateConfig().ifPresent { it.validate() }
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedWithMinMaxThresholdsConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            _modelType().let {
                if (it != JsonValue.from("grouped_with_min_max_thresholds")) {
                    throw OrbInvalidDataException("'modelType' is invalid, received $it")
                }
            }
            name()
            planPhaseOrder()
            priceType().validate()
            replacesPriceId()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun isValid(): Boolean =
            try {
                validate()
                true
            } catch (e: OrbInvalidDataException) {
                false
            }

        /**
         * Returns a score indicating how many valid values are contained in this object
         * recursively.
         *
         * Used for best match union deserialization.
         */
        @JvmSynthetic
        internal fun validity(): Int =
            (if (id.asKnown().isPresent) 1 else 0) +
                (billableMetric.asKnown().getOrNull()?.validity() ?: 0) +
                (billingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (cadence.asKnown().getOrNull()?.validity() ?: 0) +
                (if (conversionRate.asKnown().isPresent) 1 else 0) +
                (conversionRateConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (if (createdAt.asKnown().isPresent) 1 else 0) +
                (creditAllocation.asKnown().getOrNull()?.validity() ?: 0) +
                (if (currency.asKnown().isPresent) 1 else 0) +
                (discount.asKnown().getOrNull()?.validity() ?: 0) +
                (if (externalPriceId.asKnown().isPresent) 1 else 0) +
                (if (fixedPriceQuantity.asKnown().isPresent) 1 else 0) +
                (groupedWithMinMaxThresholdsConfig.asKnown().getOrNull()?.validity() ?: 0) +
                (invoicingCycleConfiguration.asKnown().getOrNull()?.validity() ?: 0) +
                (item.asKnown().getOrNull()?.validity() ?: 0) +
                (maximum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (maximumAmount.asKnown().isPresent) 1 else 0) +
                (metadata.asKnown().getOrNull()?.validity() ?: 0) +
                (minimum.asKnown().getOrNull()?.validity() ?: 0) +
                (if (minimumAmount.asKnown().isPresent) 1 else 0) +
                modelType.let {
                    if (it == JsonValue.from("grouped_with_min_max_thresholds")) 1 else 0
                } +
                (if (name.asKnown().isPresent) 1 else 0) +
                (if (planPhaseOrder.asKnown().isPresent) 1 else 0) +
                (priceType.asKnown().getOrNull()?.validity() ?: 0) +
                (if (replacesPriceId.asKnown().isPresent) 1 else 0) +
                (dimensionalPriceConfiguration.asKnown().getOrNull()?.validity() ?: 0)

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): Cadence = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        @JsonDeserialize(using = ConversionRateConfig.Deserializer::class)
        @JsonSerialize(using = ConversionRateConfig.Serializer::class)
        class ConversionRateConfig
        private constructor(
            private val unit: UnitConversionRateConfig? = null,
            private val tiered: TieredConversionRateConfig? = null,
            private val _json: JsonValue? = null,
        ) {

            fun unit(): Optional<UnitConversionRateConfig> = Optional.ofNullable(unit)

            fun tiered(): Optional<TieredConversionRateConfig> = Optional.ofNullable(tiered)

            fun isUnit(): Boolean = unit != null

            fun isTiered(): Boolean = tiered != null

            fun asUnit(): UnitConversionRateConfig = unit.getOrThrow("unit")

            fun asTiered(): TieredConversionRateConfig = tiered.getOrThrow("tiered")

            fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

            fun <T> accept(visitor: Visitor<T>): T =
                when {
                    unit != null -> visitor.visitUnit(unit)
                    tiered != null -> visitor.visitTiered(tiered)
                    else -> visitor.unknown(_json)
                }

            private var validated: Boolean = false

            fun validate(): ConversionRateConfig = apply {
                if (validated) {
                    return@apply
                }

                accept(
                    object : Visitor<Unit> {
                        override fun visitUnit(unit: UnitConversionRateConfig) {
                            unit.validate()
                        }

                        override fun visitTiered(tiered: TieredConversionRateConfig) {
                            tiered.validate()
                        }
                    }
                )
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                accept(
                    object : Visitor<Int> {
                        override fun visitUnit(unit: UnitConversionRateConfig) = unit.validity()

                        override fun visitTiered(tiered: TieredConversionRateConfig) =
                            tiered.validity()

                        override fun unknown(json: JsonValue?) = 0
                    }
                )

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ConversionRateConfig && unit == other.unit && tiered == other.tiered /* spotless:on */
            }

            override fun hashCode(): Int = /* spotless:off */ Objects.hash(unit, tiered) /* spotless:on */

            override fun toString(): String =
                when {
                    unit != null -> "ConversionRateConfig{unit=$unit}"
                    tiered != null -> "ConversionRateConfig{tiered=$tiered}"
                    _json != null -> "ConversionRateConfig{_unknown=$_json}"
                    else -> throw IllegalStateException("Invalid ConversionRateConfig")
                }

            companion object {

                @JvmStatic
                fun ofUnit(unit: UnitConversionRateConfig) = ConversionRateConfig(unit = unit)

                @JvmStatic
                fun ofTiered(tiered: TieredConversionRateConfig) =
                    ConversionRateConfig(tiered = tiered)
            }

            /**
             * An interface that defines how to map each variant of [ConversionRateConfig] to a
             * value of type [T].
             */
            interface Visitor<out T> {

                fun visitUnit(unit: UnitConversionRateConfig): T

                fun visitTiered(tiered: TieredConversionRateConfig): T

                /**
                 * Maps an unknown variant of [ConversionRateConfig] to a value of type [T].
                 *
                 * An instance of [ConversionRateConfig] can contain an unknown variant if it was
                 * deserialized from data that doesn't match any known variant. For example, if the
                 * SDK is on an older version than the API, then the API may respond with new
                 * variants that the SDK is unaware of.
                 *
                 * @throws OrbInvalidDataException in the default implementation.
                 */
                fun unknown(json: JsonValue?): T {
                    throw OrbInvalidDataException("Unknown ConversionRateConfig: $json")
                }
            }

            internal class Deserializer :
                BaseDeserializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun ObjectCodec.deserialize(node: JsonNode): ConversionRateConfig {
                    val json = JsonValue.fromJsonNode(node)
                    val conversionRateType =
                        json
                            .asObject()
                            .getOrNull()
                            ?.get("conversion_rate_type")
                            ?.asString()
                            ?.getOrNull()

                    when (conversionRateType) {
                        "unit" -> {
                            return tryDeserialize(node, jacksonTypeRef<UnitConversionRateConfig>())
                                ?.let { ConversionRateConfig(unit = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                        "tiered" -> {
                            return tryDeserialize(
                                    node,
                                    jacksonTypeRef<TieredConversionRateConfig>(),
                                )
                                ?.let { ConversionRateConfig(tiered = it, _json = json) }
                                ?: ConversionRateConfig(_json = json)
                        }
                    }

                    return ConversionRateConfig(_json = json)
                }
            }

            internal class Serializer :
                BaseSerializer<ConversionRateConfig>(ConversionRateConfig::class) {

                override fun serialize(
                    value: ConversionRateConfig,
                    generator: JsonGenerator,
                    provider: SerializerProvider,
                ) {
                    when {
                        value.unit != null -> generator.writeObject(value.unit)
                        value.tiered != null -> generator.writeObject(value.tiered)
                        value._json != null -> generator.writeObject(value._json)
                        else -> throw IllegalStateException("Invalid ConversionRateConfig")
                    }
                }
            }
        }

        class GroupedWithMinMaxThresholdsConfig
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /**
                 * Returns a mutable builder for constructing an instance of
                 * [GroupedWithMinMaxThresholdsConfig].
                 */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [GroupedWithMinMaxThresholdsConfig]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(
                    groupedWithMinMaxThresholdsConfig: GroupedWithMinMaxThresholdsConfig
                ) = apply {
                    additionalProperties =
                        groupedWithMinMaxThresholdsConfig.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [GroupedWithMinMaxThresholdsConfig].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): GroupedWithMinMaxThresholdsConfig =
                    GroupedWithMinMaxThresholdsConfig(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): GroupedWithMinMaxThresholdsConfig = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is GroupedWithMinMaxThresholdsConfig && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() =
                "GroupedWithMinMaxThresholdsConfig{additionalProperties=$additionalProperties}"
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        class Metadata
        @JsonCreator
        private constructor(
            @com.fasterxml.jackson.annotation.JsonValue
            private val additionalProperties: Map<String, JsonValue>
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                /**
                 * Returns an immutable instance of [Metadata].
                 *
                 * Further updates to this [Builder] will not mutate the returned instance.
                 */
                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic
            internal fun validity(): Int =
                additionalProperties.count { (_, value) -> !value.isNull() && !value.isMissing() }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            private var validated: Boolean = false

            fun validate(): PriceType = apply {
                if (validated) {
                    return@apply
                }

                known()
                validated = true
            }

            fun isValid(): Boolean =
                try {
                    validate()
                    true
                } catch (e: OrbInvalidDataException) {
                    false
                }

            /**
             * Returns a score indicating how many valid values are contained in this object
             * recursively.
             *
             * Used for best match union deserialization.
             */
            @JvmSynthetic internal fun validity(): Int = if (value() == Value._UNKNOWN) 0 else 1

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedWithMinMaxThresholds && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && conversionRateConfig == other.conversionRateConfig && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedWithMinMaxThresholdsConfig == other.groupedWithMinMaxThresholdsConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && replacesPriceId == other.replacesPriceId && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, conversionRateConfig, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedWithMinMaxThresholdsConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, replacesPriceId, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedWithMinMaxThresholds{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, conversionRateConfig=$conversionRateConfig, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedWithMinMaxThresholdsConfig=$groupedWithMinMaxThresholdsConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, replacesPriceId=$replacesPriceId, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }
}
