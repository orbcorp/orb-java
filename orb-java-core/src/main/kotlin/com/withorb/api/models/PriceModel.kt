// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.ObjectCodec
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.annotation.JsonDeserialize
import com.fasterxml.jackson.databind.annotation.JsonSerialize
import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.withorb.api.core.BaseDeserializer
import com.withorb.api.core.BaseSerializer
import com.withorb.api.core.Enum
import com.withorb.api.core.ExcludeMissing
import com.withorb.api.core.JsonField
import com.withorb.api.core.JsonMissing
import com.withorb.api.core.JsonValue
import com.withorb.api.core.NoAutoDetect
import com.withorb.api.core.checkRequired
import com.withorb.api.core.getOrThrow
import com.withorb.api.core.immutableEmptyMap
import com.withorb.api.core.toImmutable
import com.withorb.api.errors.OrbInvalidDataException
import java.time.OffsetDateTime
import java.util.Objects
import java.util.Optional
import kotlin.jvm.optionals.getOrNull

/**
 * The Price resource represents a price that can be billed on a subscription, resulting in a charge
 * on an invoice in the form of an invoice line item. Prices take a quantity and determine an amount
 * to bill.
 *
 * Orb supports a few different pricing models out of the box. Each of these models is serialized
 * differently in a given Price object. The model_type field determines the key for the
 * configuration object that is present.
 *
 * For more on the types of prices, see
 * [the core concepts documentation](/core-concepts#plan-and-price)
 */
@JsonDeserialize(using = PriceModel.Deserializer::class)
@JsonSerialize(using = PriceModel.Serializer::class)
class PriceModel
private constructor(
    private val unitPrice: UnitPrice? = null,
    private val packagePrice: PackagePrice? = null,
    private val matrixPrice: MatrixPrice? = null,
    private val tieredPrice: TieredPrice? = null,
    private val tieredBpsPrice: TieredBpsPrice? = null,
    private val bpsPrice: BpsPrice? = null,
    private val bulkBpsPrice: BulkBpsPrice? = null,
    private val bulkPrice: BulkPrice? = null,
    private val thresholdTotalAmountPrice: ThresholdTotalAmountPrice? = null,
    private val tieredPackagePrice: TieredPackagePrice? = null,
    private val groupedTieredPrice: GroupedTieredPrice? = null,
    private val tieredWithMinimumPrice: TieredWithMinimumPrice? = null,
    private val tieredPackageWithMinimumPrice: TieredPackageWithMinimumPrice? = null,
    private val packageWithAllocationPrice: PackageWithAllocationPrice? = null,
    private val unitWithPercentPrice: UnitWithPercentPrice? = null,
    private val matrixWithAllocationPrice: MatrixWithAllocationPrice? = null,
    private val tieredWithProrationPrice: TieredWithProrationPrice? = null,
    private val unitWithProrationPrice: UnitWithProrationPrice? = null,
    private val groupedAllocationPrice: GroupedAllocationPrice? = null,
    private val groupedWithProratedMinimumPrice: GroupedWithProratedMinimumPrice? = null,
    private val groupedWithMeteredMinimumPrice: GroupedWithMeteredMinimumPrice? = null,
    private val matrixWithDisplayNamePrice: MatrixWithDisplayNamePrice? = null,
    private val bulkWithProrationPrice: BulkWithProrationPrice? = null,
    private val groupedTieredPackagePrice: GroupedTieredPackagePrice? = null,
    private val maxGroupTieredPackagePrice: MaxGroupTieredPackagePrice? = null,
    private val scalableMatrixWithUnitPricingPrice: ScalableMatrixWithUnitPricingPrice? = null,
    private val scalableMatrixWithTieredPricingPrice: ScalableMatrixWithTieredPricingPrice? = null,
    private val cumulativeGroupedBulkPrice: CumulativeGroupedBulkPrice? = null,
    private val _json: JsonValue? = null,
) {

    fun unitPrice(): Optional<UnitPrice> = Optional.ofNullable(unitPrice)

    fun packagePrice(): Optional<PackagePrice> = Optional.ofNullable(packagePrice)

    fun matrixPrice(): Optional<MatrixPrice> = Optional.ofNullable(matrixPrice)

    fun tieredPrice(): Optional<TieredPrice> = Optional.ofNullable(tieredPrice)

    fun tieredBpsPrice(): Optional<TieredBpsPrice> = Optional.ofNullable(tieredBpsPrice)

    fun bpsPrice(): Optional<BpsPrice> = Optional.ofNullable(bpsPrice)

    fun bulkBpsPrice(): Optional<BulkBpsPrice> = Optional.ofNullable(bulkBpsPrice)

    fun bulkPrice(): Optional<BulkPrice> = Optional.ofNullable(bulkPrice)

    fun thresholdTotalAmountPrice(): Optional<ThresholdTotalAmountPrice> =
        Optional.ofNullable(thresholdTotalAmountPrice)

    fun tieredPackagePrice(): Optional<TieredPackagePrice> = Optional.ofNullable(tieredPackagePrice)

    fun groupedTieredPrice(): Optional<GroupedTieredPrice> = Optional.ofNullable(groupedTieredPrice)

    fun tieredWithMinimumPrice(): Optional<TieredWithMinimumPrice> =
        Optional.ofNullable(tieredWithMinimumPrice)

    fun tieredPackageWithMinimumPrice(): Optional<TieredPackageWithMinimumPrice> =
        Optional.ofNullable(tieredPackageWithMinimumPrice)

    fun packageWithAllocationPrice(): Optional<PackageWithAllocationPrice> =
        Optional.ofNullable(packageWithAllocationPrice)

    fun unitWithPercentPrice(): Optional<UnitWithPercentPrice> =
        Optional.ofNullable(unitWithPercentPrice)

    fun matrixWithAllocationPrice(): Optional<MatrixWithAllocationPrice> =
        Optional.ofNullable(matrixWithAllocationPrice)

    fun tieredWithProrationPrice(): Optional<TieredWithProrationPrice> =
        Optional.ofNullable(tieredWithProrationPrice)

    fun unitWithProrationPrice(): Optional<UnitWithProrationPrice> =
        Optional.ofNullable(unitWithProrationPrice)

    fun groupedAllocationPrice(): Optional<GroupedAllocationPrice> =
        Optional.ofNullable(groupedAllocationPrice)

    fun groupedWithProratedMinimumPrice(): Optional<GroupedWithProratedMinimumPrice> =
        Optional.ofNullable(groupedWithProratedMinimumPrice)

    fun groupedWithMeteredMinimumPrice(): Optional<GroupedWithMeteredMinimumPrice> =
        Optional.ofNullable(groupedWithMeteredMinimumPrice)

    fun matrixWithDisplayNamePrice(): Optional<MatrixWithDisplayNamePrice> =
        Optional.ofNullable(matrixWithDisplayNamePrice)

    fun bulkWithProrationPrice(): Optional<BulkWithProrationPrice> =
        Optional.ofNullable(bulkWithProrationPrice)

    fun groupedTieredPackagePrice(): Optional<GroupedTieredPackagePrice> =
        Optional.ofNullable(groupedTieredPackagePrice)

    fun maxGroupTieredPackagePrice(): Optional<MaxGroupTieredPackagePrice> =
        Optional.ofNullable(maxGroupTieredPackagePrice)

    fun scalableMatrixWithUnitPricingPrice(): Optional<ScalableMatrixWithUnitPricingPrice> =
        Optional.ofNullable(scalableMatrixWithUnitPricingPrice)

    fun scalableMatrixWithTieredPricingPrice(): Optional<ScalableMatrixWithTieredPricingPrice> =
        Optional.ofNullable(scalableMatrixWithTieredPricingPrice)

    fun cumulativeGroupedBulkPrice(): Optional<CumulativeGroupedBulkPrice> =
        Optional.ofNullable(cumulativeGroupedBulkPrice)

    fun isUnitPrice(): Boolean = unitPrice != null

    fun isPackagePrice(): Boolean = packagePrice != null

    fun isMatrixPrice(): Boolean = matrixPrice != null

    fun isTieredPrice(): Boolean = tieredPrice != null

    fun isTieredBpsPrice(): Boolean = tieredBpsPrice != null

    fun isBpsPrice(): Boolean = bpsPrice != null

    fun isBulkBpsPrice(): Boolean = bulkBpsPrice != null

    fun isBulkPrice(): Boolean = bulkPrice != null

    fun isThresholdTotalAmountPrice(): Boolean = thresholdTotalAmountPrice != null

    fun isTieredPackagePrice(): Boolean = tieredPackagePrice != null

    fun isGroupedTieredPrice(): Boolean = groupedTieredPrice != null

    fun isTieredWithMinimumPrice(): Boolean = tieredWithMinimumPrice != null

    fun isTieredPackageWithMinimumPrice(): Boolean = tieredPackageWithMinimumPrice != null

    fun isPackageWithAllocationPrice(): Boolean = packageWithAllocationPrice != null

    fun isUnitWithPercentPrice(): Boolean = unitWithPercentPrice != null

    fun isMatrixWithAllocationPrice(): Boolean = matrixWithAllocationPrice != null

    fun isTieredWithProrationPrice(): Boolean = tieredWithProrationPrice != null

    fun isUnitWithProrationPrice(): Boolean = unitWithProrationPrice != null

    fun isGroupedAllocationPrice(): Boolean = groupedAllocationPrice != null

    fun isGroupedWithProratedMinimumPrice(): Boolean = groupedWithProratedMinimumPrice != null

    fun isGroupedWithMeteredMinimumPrice(): Boolean = groupedWithMeteredMinimumPrice != null

    fun isMatrixWithDisplayNamePrice(): Boolean = matrixWithDisplayNamePrice != null

    fun isBulkWithProrationPrice(): Boolean = bulkWithProrationPrice != null

    fun isGroupedTieredPackagePrice(): Boolean = groupedTieredPackagePrice != null

    fun isMaxGroupTieredPackagePrice(): Boolean = maxGroupTieredPackagePrice != null

    fun isScalableMatrixWithUnitPricingPrice(): Boolean = scalableMatrixWithUnitPricingPrice != null

    fun isScalableMatrixWithTieredPricingPrice(): Boolean =
        scalableMatrixWithTieredPricingPrice != null

    fun isCumulativeGroupedBulkPrice(): Boolean = cumulativeGroupedBulkPrice != null

    fun asUnitPrice(): UnitPrice = unitPrice.getOrThrow("unitPrice")

    fun asPackagePrice(): PackagePrice = packagePrice.getOrThrow("packagePrice")

    fun asMatrixPrice(): MatrixPrice = matrixPrice.getOrThrow("matrixPrice")

    fun asTieredPrice(): TieredPrice = tieredPrice.getOrThrow("tieredPrice")

    fun asTieredBpsPrice(): TieredBpsPrice = tieredBpsPrice.getOrThrow("tieredBpsPrice")

    fun asBpsPrice(): BpsPrice = bpsPrice.getOrThrow("bpsPrice")

    fun asBulkBpsPrice(): BulkBpsPrice = bulkBpsPrice.getOrThrow("bulkBpsPrice")

    fun asBulkPrice(): BulkPrice = bulkPrice.getOrThrow("bulkPrice")

    fun asThresholdTotalAmountPrice(): ThresholdTotalAmountPrice =
        thresholdTotalAmountPrice.getOrThrow("thresholdTotalAmountPrice")

    fun asTieredPackagePrice(): TieredPackagePrice =
        tieredPackagePrice.getOrThrow("tieredPackagePrice")

    fun asGroupedTieredPrice(): GroupedTieredPrice =
        groupedTieredPrice.getOrThrow("groupedTieredPrice")

    fun asTieredWithMinimumPrice(): TieredWithMinimumPrice =
        tieredWithMinimumPrice.getOrThrow("tieredWithMinimumPrice")

    fun asTieredPackageWithMinimumPrice(): TieredPackageWithMinimumPrice =
        tieredPackageWithMinimumPrice.getOrThrow("tieredPackageWithMinimumPrice")

    fun asPackageWithAllocationPrice(): PackageWithAllocationPrice =
        packageWithAllocationPrice.getOrThrow("packageWithAllocationPrice")

    fun asUnitWithPercentPrice(): UnitWithPercentPrice =
        unitWithPercentPrice.getOrThrow("unitWithPercentPrice")

    fun asMatrixWithAllocationPrice(): MatrixWithAllocationPrice =
        matrixWithAllocationPrice.getOrThrow("matrixWithAllocationPrice")

    fun asTieredWithProrationPrice(): TieredWithProrationPrice =
        tieredWithProrationPrice.getOrThrow("tieredWithProrationPrice")

    fun asUnitWithProrationPrice(): UnitWithProrationPrice =
        unitWithProrationPrice.getOrThrow("unitWithProrationPrice")

    fun asGroupedAllocationPrice(): GroupedAllocationPrice =
        groupedAllocationPrice.getOrThrow("groupedAllocationPrice")

    fun asGroupedWithProratedMinimumPrice(): GroupedWithProratedMinimumPrice =
        groupedWithProratedMinimumPrice.getOrThrow("groupedWithProratedMinimumPrice")

    fun asGroupedWithMeteredMinimumPrice(): GroupedWithMeteredMinimumPrice =
        groupedWithMeteredMinimumPrice.getOrThrow("groupedWithMeteredMinimumPrice")

    fun asMatrixWithDisplayNamePrice(): MatrixWithDisplayNamePrice =
        matrixWithDisplayNamePrice.getOrThrow("matrixWithDisplayNamePrice")

    fun asBulkWithProrationPrice(): BulkWithProrationPrice =
        bulkWithProrationPrice.getOrThrow("bulkWithProrationPrice")

    fun asGroupedTieredPackagePrice(): GroupedTieredPackagePrice =
        groupedTieredPackagePrice.getOrThrow("groupedTieredPackagePrice")

    fun asMaxGroupTieredPackagePrice(): MaxGroupTieredPackagePrice =
        maxGroupTieredPackagePrice.getOrThrow("maxGroupTieredPackagePrice")

    fun asScalableMatrixWithUnitPricingPrice(): ScalableMatrixWithUnitPricingPrice =
        scalableMatrixWithUnitPricingPrice.getOrThrow("scalableMatrixWithUnitPricingPrice")

    fun asScalableMatrixWithTieredPricingPrice(): ScalableMatrixWithTieredPricingPrice =
        scalableMatrixWithTieredPricingPrice.getOrThrow("scalableMatrixWithTieredPricingPrice")

    fun asCumulativeGroupedBulkPrice(): CumulativeGroupedBulkPrice =
        cumulativeGroupedBulkPrice.getOrThrow("cumulativeGroupedBulkPrice")

    fun _json(): Optional<JsonValue> = Optional.ofNullable(_json)

    fun <T> accept(visitor: Visitor<T>): T {
        return when {
            unitPrice != null -> visitor.visitUnitPrice(unitPrice)
            packagePrice != null -> visitor.visitPackagePrice(packagePrice)
            matrixPrice != null -> visitor.visitMatrixPrice(matrixPrice)
            tieredPrice != null -> visitor.visitTieredPrice(tieredPrice)
            tieredBpsPrice != null -> visitor.visitTieredBpsPrice(tieredBpsPrice)
            bpsPrice != null -> visitor.visitBpsPrice(bpsPrice)
            bulkBpsPrice != null -> visitor.visitBulkBpsPrice(bulkBpsPrice)
            bulkPrice != null -> visitor.visitBulkPrice(bulkPrice)
            thresholdTotalAmountPrice != null ->
                visitor.visitThresholdTotalAmountPrice(thresholdTotalAmountPrice)
            tieredPackagePrice != null -> visitor.visitTieredPackagePrice(tieredPackagePrice)
            groupedTieredPrice != null -> visitor.visitGroupedTieredPrice(groupedTieredPrice)
            tieredWithMinimumPrice != null ->
                visitor.visitTieredWithMinimumPrice(tieredWithMinimumPrice)
            tieredPackageWithMinimumPrice != null ->
                visitor.visitTieredPackageWithMinimumPrice(tieredPackageWithMinimumPrice)
            packageWithAllocationPrice != null ->
                visitor.visitPackageWithAllocationPrice(packageWithAllocationPrice)
            unitWithPercentPrice != null -> visitor.visitUnitWithPercentPrice(unitWithPercentPrice)
            matrixWithAllocationPrice != null ->
                visitor.visitMatrixWithAllocationPrice(matrixWithAllocationPrice)
            tieredWithProrationPrice != null ->
                visitor.visitTieredWithProrationPrice(tieredWithProrationPrice)
            unitWithProrationPrice != null ->
                visitor.visitUnitWithProrationPrice(unitWithProrationPrice)
            groupedAllocationPrice != null ->
                visitor.visitGroupedAllocationPrice(groupedAllocationPrice)
            groupedWithProratedMinimumPrice != null ->
                visitor.visitGroupedWithProratedMinimumPrice(groupedWithProratedMinimumPrice)
            groupedWithMeteredMinimumPrice != null ->
                visitor.visitGroupedWithMeteredMinimumPrice(groupedWithMeteredMinimumPrice)
            matrixWithDisplayNamePrice != null ->
                visitor.visitMatrixWithDisplayNamePrice(matrixWithDisplayNamePrice)
            bulkWithProrationPrice != null ->
                visitor.visitBulkWithProrationPrice(bulkWithProrationPrice)
            groupedTieredPackagePrice != null ->
                visitor.visitGroupedTieredPackagePrice(groupedTieredPackagePrice)
            maxGroupTieredPackagePrice != null ->
                visitor.visitMaxGroupTieredPackagePrice(maxGroupTieredPackagePrice)
            scalableMatrixWithUnitPricingPrice != null ->
                visitor.visitScalableMatrixWithUnitPricingPrice(scalableMatrixWithUnitPricingPrice)
            scalableMatrixWithTieredPricingPrice != null ->
                visitor.visitScalableMatrixWithTieredPricingPrice(
                    scalableMatrixWithTieredPricingPrice
                )
            cumulativeGroupedBulkPrice != null ->
                visitor.visitCumulativeGroupedBulkPrice(cumulativeGroupedBulkPrice)
            else -> visitor.unknown(_json)
        }
    }

    private var validated: Boolean = false

    fun validate(): PriceModel = apply {
        if (validated) {
            return@apply
        }

        accept(
            object : Visitor<Unit> {
                override fun visitUnitPrice(unitPrice: UnitPrice) {
                    unitPrice.validate()
                }

                override fun visitPackagePrice(packagePrice: PackagePrice) {
                    packagePrice.validate()
                }

                override fun visitMatrixPrice(matrixPrice: MatrixPrice) {
                    matrixPrice.validate()
                }

                override fun visitTieredPrice(tieredPrice: TieredPrice) {
                    tieredPrice.validate()
                }

                override fun visitTieredBpsPrice(tieredBpsPrice: TieredBpsPrice) {
                    tieredBpsPrice.validate()
                }

                override fun visitBpsPrice(bpsPrice: BpsPrice) {
                    bpsPrice.validate()
                }

                override fun visitBulkBpsPrice(bulkBpsPrice: BulkBpsPrice) {
                    bulkBpsPrice.validate()
                }

                override fun visitBulkPrice(bulkPrice: BulkPrice) {
                    bulkPrice.validate()
                }

                override fun visitThresholdTotalAmountPrice(
                    thresholdTotalAmountPrice: ThresholdTotalAmountPrice
                ) {
                    thresholdTotalAmountPrice.validate()
                }

                override fun visitTieredPackagePrice(tieredPackagePrice: TieredPackagePrice) {
                    tieredPackagePrice.validate()
                }

                override fun visitGroupedTieredPrice(groupedTieredPrice: GroupedTieredPrice) {
                    groupedTieredPrice.validate()
                }

                override fun visitTieredWithMinimumPrice(
                    tieredWithMinimumPrice: TieredWithMinimumPrice
                ) {
                    tieredWithMinimumPrice.validate()
                }

                override fun visitTieredPackageWithMinimumPrice(
                    tieredPackageWithMinimumPrice: TieredPackageWithMinimumPrice
                ) {
                    tieredPackageWithMinimumPrice.validate()
                }

                override fun visitPackageWithAllocationPrice(
                    packageWithAllocationPrice: PackageWithAllocationPrice
                ) {
                    packageWithAllocationPrice.validate()
                }

                override fun visitUnitWithPercentPrice(unitWithPercentPrice: UnitWithPercentPrice) {
                    unitWithPercentPrice.validate()
                }

                override fun visitMatrixWithAllocationPrice(
                    matrixWithAllocationPrice: MatrixWithAllocationPrice
                ) {
                    matrixWithAllocationPrice.validate()
                }

                override fun visitTieredWithProrationPrice(
                    tieredWithProrationPrice: TieredWithProrationPrice
                ) {
                    tieredWithProrationPrice.validate()
                }

                override fun visitUnitWithProrationPrice(
                    unitWithProrationPrice: UnitWithProrationPrice
                ) {
                    unitWithProrationPrice.validate()
                }

                override fun visitGroupedAllocationPrice(
                    groupedAllocationPrice: GroupedAllocationPrice
                ) {
                    groupedAllocationPrice.validate()
                }

                override fun visitGroupedWithProratedMinimumPrice(
                    groupedWithProratedMinimumPrice: GroupedWithProratedMinimumPrice
                ) {
                    groupedWithProratedMinimumPrice.validate()
                }

                override fun visitGroupedWithMeteredMinimumPrice(
                    groupedWithMeteredMinimumPrice: GroupedWithMeteredMinimumPrice
                ) {
                    groupedWithMeteredMinimumPrice.validate()
                }

                override fun visitMatrixWithDisplayNamePrice(
                    matrixWithDisplayNamePrice: MatrixWithDisplayNamePrice
                ) {
                    matrixWithDisplayNamePrice.validate()
                }

                override fun visitBulkWithProrationPrice(
                    bulkWithProrationPrice: BulkWithProrationPrice
                ) {
                    bulkWithProrationPrice.validate()
                }

                override fun visitGroupedTieredPackagePrice(
                    groupedTieredPackagePrice: GroupedTieredPackagePrice
                ) {
                    groupedTieredPackagePrice.validate()
                }

                override fun visitMaxGroupTieredPackagePrice(
                    maxGroupTieredPackagePrice: MaxGroupTieredPackagePrice
                ) {
                    maxGroupTieredPackagePrice.validate()
                }

                override fun visitScalableMatrixWithUnitPricingPrice(
                    scalableMatrixWithUnitPricingPrice: ScalableMatrixWithUnitPricingPrice
                ) {
                    scalableMatrixWithUnitPricingPrice.validate()
                }

                override fun visitScalableMatrixWithTieredPricingPrice(
                    scalableMatrixWithTieredPricingPrice: ScalableMatrixWithTieredPricingPrice
                ) {
                    scalableMatrixWithTieredPricingPrice.validate()
                }

                override fun visitCumulativeGroupedBulkPrice(
                    cumulativeGroupedBulkPrice: CumulativeGroupedBulkPrice
                ) {
                    cumulativeGroupedBulkPrice.validate()
                }
            }
        )
        validated = true
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return /* spotless:off */ other is PriceModel && unitPrice == other.unitPrice && packagePrice == other.packagePrice && matrixPrice == other.matrixPrice && tieredPrice == other.tieredPrice && tieredBpsPrice == other.tieredBpsPrice && bpsPrice == other.bpsPrice && bulkBpsPrice == other.bulkBpsPrice && bulkPrice == other.bulkPrice && thresholdTotalAmountPrice == other.thresholdTotalAmountPrice && tieredPackagePrice == other.tieredPackagePrice && groupedTieredPrice == other.groupedTieredPrice && tieredWithMinimumPrice == other.tieredWithMinimumPrice && tieredPackageWithMinimumPrice == other.tieredPackageWithMinimumPrice && packageWithAllocationPrice == other.packageWithAllocationPrice && unitWithPercentPrice == other.unitWithPercentPrice && matrixWithAllocationPrice == other.matrixWithAllocationPrice && tieredWithProrationPrice == other.tieredWithProrationPrice && unitWithProrationPrice == other.unitWithProrationPrice && groupedAllocationPrice == other.groupedAllocationPrice && groupedWithProratedMinimumPrice == other.groupedWithProratedMinimumPrice && groupedWithMeteredMinimumPrice == other.groupedWithMeteredMinimumPrice && matrixWithDisplayNamePrice == other.matrixWithDisplayNamePrice && bulkWithProrationPrice == other.bulkWithProrationPrice && groupedTieredPackagePrice == other.groupedTieredPackagePrice && maxGroupTieredPackagePrice == other.maxGroupTieredPackagePrice && scalableMatrixWithUnitPricingPrice == other.scalableMatrixWithUnitPricingPrice && scalableMatrixWithTieredPricingPrice == other.scalableMatrixWithTieredPricingPrice && cumulativeGroupedBulkPrice == other.cumulativeGroupedBulkPrice /* spotless:on */
    }

    override fun hashCode(): Int = /* spotless:off */ Objects.hash(unitPrice, packagePrice, matrixPrice, tieredPrice, tieredBpsPrice, bpsPrice, bulkBpsPrice, bulkPrice, thresholdTotalAmountPrice, tieredPackagePrice, groupedTieredPrice, tieredWithMinimumPrice, tieredPackageWithMinimumPrice, packageWithAllocationPrice, unitWithPercentPrice, matrixWithAllocationPrice, tieredWithProrationPrice, unitWithProrationPrice, groupedAllocationPrice, groupedWithProratedMinimumPrice, groupedWithMeteredMinimumPrice, matrixWithDisplayNamePrice, bulkWithProrationPrice, groupedTieredPackagePrice, maxGroupTieredPackagePrice, scalableMatrixWithUnitPricingPrice, scalableMatrixWithTieredPricingPrice, cumulativeGroupedBulkPrice) /* spotless:on */

    override fun toString(): String =
        when {
            unitPrice != null -> "PriceModel{unitPrice=$unitPrice}"
            packagePrice != null -> "PriceModel{packagePrice=$packagePrice}"
            matrixPrice != null -> "PriceModel{matrixPrice=$matrixPrice}"
            tieredPrice != null -> "PriceModel{tieredPrice=$tieredPrice}"
            tieredBpsPrice != null -> "PriceModel{tieredBpsPrice=$tieredBpsPrice}"
            bpsPrice != null -> "PriceModel{bpsPrice=$bpsPrice}"
            bulkBpsPrice != null -> "PriceModel{bulkBpsPrice=$bulkBpsPrice}"
            bulkPrice != null -> "PriceModel{bulkPrice=$bulkPrice}"
            thresholdTotalAmountPrice != null ->
                "PriceModel{thresholdTotalAmountPrice=$thresholdTotalAmountPrice}"
            tieredPackagePrice != null -> "PriceModel{tieredPackagePrice=$tieredPackagePrice}"
            groupedTieredPrice != null -> "PriceModel{groupedTieredPrice=$groupedTieredPrice}"
            tieredWithMinimumPrice != null ->
                "PriceModel{tieredWithMinimumPrice=$tieredWithMinimumPrice}"
            tieredPackageWithMinimumPrice != null ->
                "PriceModel{tieredPackageWithMinimumPrice=$tieredPackageWithMinimumPrice}"
            packageWithAllocationPrice != null ->
                "PriceModel{packageWithAllocationPrice=$packageWithAllocationPrice}"
            unitWithPercentPrice != null -> "PriceModel{unitWithPercentPrice=$unitWithPercentPrice}"
            matrixWithAllocationPrice != null ->
                "PriceModel{matrixWithAllocationPrice=$matrixWithAllocationPrice}"
            tieredWithProrationPrice != null ->
                "PriceModel{tieredWithProrationPrice=$tieredWithProrationPrice}"
            unitWithProrationPrice != null ->
                "PriceModel{unitWithProrationPrice=$unitWithProrationPrice}"
            groupedAllocationPrice != null ->
                "PriceModel{groupedAllocationPrice=$groupedAllocationPrice}"
            groupedWithProratedMinimumPrice != null ->
                "PriceModel{groupedWithProratedMinimumPrice=$groupedWithProratedMinimumPrice}"
            groupedWithMeteredMinimumPrice != null ->
                "PriceModel{groupedWithMeteredMinimumPrice=$groupedWithMeteredMinimumPrice}"
            matrixWithDisplayNamePrice != null ->
                "PriceModel{matrixWithDisplayNamePrice=$matrixWithDisplayNamePrice}"
            bulkWithProrationPrice != null ->
                "PriceModel{bulkWithProrationPrice=$bulkWithProrationPrice}"
            groupedTieredPackagePrice != null ->
                "PriceModel{groupedTieredPackagePrice=$groupedTieredPackagePrice}"
            maxGroupTieredPackagePrice != null ->
                "PriceModel{maxGroupTieredPackagePrice=$maxGroupTieredPackagePrice}"
            scalableMatrixWithUnitPricingPrice != null ->
                "PriceModel{scalableMatrixWithUnitPricingPrice=$scalableMatrixWithUnitPricingPrice}"
            scalableMatrixWithTieredPricingPrice != null ->
                "PriceModel{scalableMatrixWithTieredPricingPrice=$scalableMatrixWithTieredPricingPrice}"
            cumulativeGroupedBulkPrice != null ->
                "PriceModel{cumulativeGroupedBulkPrice=$cumulativeGroupedBulkPrice}"
            _json != null -> "PriceModel{_unknown=$_json}"
            else -> throw IllegalStateException("Invalid PriceModel")
        }

    companion object {

        @JvmStatic fun ofUnitPrice(unitPrice: UnitPrice) = PriceModel(unitPrice = unitPrice)

        @JvmStatic
        fun ofPackagePrice(packagePrice: PackagePrice) = PriceModel(packagePrice = packagePrice)

        @JvmStatic
        fun ofMatrixPrice(matrixPrice: MatrixPrice) = PriceModel(matrixPrice = matrixPrice)

        @JvmStatic
        fun ofTieredPrice(tieredPrice: TieredPrice) = PriceModel(tieredPrice = tieredPrice)

        @JvmStatic
        fun ofTieredBpsPrice(tieredBpsPrice: TieredBpsPrice) =
            PriceModel(tieredBpsPrice = tieredBpsPrice)

        @JvmStatic fun ofBpsPrice(bpsPrice: BpsPrice) = PriceModel(bpsPrice = bpsPrice)

        @JvmStatic
        fun ofBulkBpsPrice(bulkBpsPrice: BulkBpsPrice) = PriceModel(bulkBpsPrice = bulkBpsPrice)

        @JvmStatic fun ofBulkPrice(bulkPrice: BulkPrice) = PriceModel(bulkPrice = bulkPrice)

        @JvmStatic
        fun ofThresholdTotalAmountPrice(thresholdTotalAmountPrice: ThresholdTotalAmountPrice) =
            PriceModel(thresholdTotalAmountPrice = thresholdTotalAmountPrice)

        @JvmStatic
        fun ofTieredPackagePrice(tieredPackagePrice: TieredPackagePrice) =
            PriceModel(tieredPackagePrice = tieredPackagePrice)

        @JvmStatic
        fun ofGroupedTieredPrice(groupedTieredPrice: GroupedTieredPrice) =
            PriceModel(groupedTieredPrice = groupedTieredPrice)

        @JvmStatic
        fun ofTieredWithMinimumPrice(tieredWithMinimumPrice: TieredWithMinimumPrice) =
            PriceModel(tieredWithMinimumPrice = tieredWithMinimumPrice)

        @JvmStatic
        fun ofTieredPackageWithMinimumPrice(
            tieredPackageWithMinimumPrice: TieredPackageWithMinimumPrice
        ) = PriceModel(tieredPackageWithMinimumPrice = tieredPackageWithMinimumPrice)

        @JvmStatic
        fun ofPackageWithAllocationPrice(packageWithAllocationPrice: PackageWithAllocationPrice) =
            PriceModel(packageWithAllocationPrice = packageWithAllocationPrice)

        @JvmStatic
        fun ofUnitWithPercentPrice(unitWithPercentPrice: UnitWithPercentPrice) =
            PriceModel(unitWithPercentPrice = unitWithPercentPrice)

        @JvmStatic
        fun ofMatrixWithAllocationPrice(matrixWithAllocationPrice: MatrixWithAllocationPrice) =
            PriceModel(matrixWithAllocationPrice = matrixWithAllocationPrice)

        @JvmStatic
        fun ofTieredWithProrationPrice(tieredWithProrationPrice: TieredWithProrationPrice) =
            PriceModel(tieredWithProrationPrice = tieredWithProrationPrice)

        @JvmStatic
        fun ofUnitWithProrationPrice(unitWithProrationPrice: UnitWithProrationPrice) =
            PriceModel(unitWithProrationPrice = unitWithProrationPrice)

        @JvmStatic
        fun ofGroupedAllocationPrice(groupedAllocationPrice: GroupedAllocationPrice) =
            PriceModel(groupedAllocationPrice = groupedAllocationPrice)

        @JvmStatic
        fun ofGroupedWithProratedMinimumPrice(
            groupedWithProratedMinimumPrice: GroupedWithProratedMinimumPrice
        ) = PriceModel(groupedWithProratedMinimumPrice = groupedWithProratedMinimumPrice)

        @JvmStatic
        fun ofGroupedWithMeteredMinimumPrice(
            groupedWithMeteredMinimumPrice: GroupedWithMeteredMinimumPrice
        ) = PriceModel(groupedWithMeteredMinimumPrice = groupedWithMeteredMinimumPrice)

        @JvmStatic
        fun ofMatrixWithDisplayNamePrice(matrixWithDisplayNamePrice: MatrixWithDisplayNamePrice) =
            PriceModel(matrixWithDisplayNamePrice = matrixWithDisplayNamePrice)

        @JvmStatic
        fun ofBulkWithProrationPrice(bulkWithProrationPrice: BulkWithProrationPrice) =
            PriceModel(bulkWithProrationPrice = bulkWithProrationPrice)

        @JvmStatic
        fun ofGroupedTieredPackagePrice(groupedTieredPackagePrice: GroupedTieredPackagePrice) =
            PriceModel(groupedTieredPackagePrice = groupedTieredPackagePrice)

        @JvmStatic
        fun ofMaxGroupTieredPackagePrice(maxGroupTieredPackagePrice: MaxGroupTieredPackagePrice) =
            PriceModel(maxGroupTieredPackagePrice = maxGroupTieredPackagePrice)

        @JvmStatic
        fun ofScalableMatrixWithUnitPricingPrice(
            scalableMatrixWithUnitPricingPrice: ScalableMatrixWithUnitPricingPrice
        ) = PriceModel(scalableMatrixWithUnitPricingPrice = scalableMatrixWithUnitPricingPrice)

        @JvmStatic
        fun ofScalableMatrixWithTieredPricingPrice(
            scalableMatrixWithTieredPricingPrice: ScalableMatrixWithTieredPricingPrice
        ) = PriceModel(scalableMatrixWithTieredPricingPrice = scalableMatrixWithTieredPricingPrice)

        @JvmStatic
        fun ofCumulativeGroupedBulkPrice(cumulativeGroupedBulkPrice: CumulativeGroupedBulkPrice) =
            PriceModel(cumulativeGroupedBulkPrice = cumulativeGroupedBulkPrice)
    }

    /** An interface that defines how to map each variant of [PriceModel] to a value of type [T]. */
    interface Visitor<out T> {

        fun visitUnitPrice(unitPrice: UnitPrice): T

        fun visitPackagePrice(packagePrice: PackagePrice): T

        fun visitMatrixPrice(matrixPrice: MatrixPrice): T

        fun visitTieredPrice(tieredPrice: TieredPrice): T

        fun visitTieredBpsPrice(tieredBpsPrice: TieredBpsPrice): T

        fun visitBpsPrice(bpsPrice: BpsPrice): T

        fun visitBulkBpsPrice(bulkBpsPrice: BulkBpsPrice): T

        fun visitBulkPrice(bulkPrice: BulkPrice): T

        fun visitThresholdTotalAmountPrice(thresholdTotalAmountPrice: ThresholdTotalAmountPrice): T

        fun visitTieredPackagePrice(tieredPackagePrice: TieredPackagePrice): T

        fun visitGroupedTieredPrice(groupedTieredPrice: GroupedTieredPrice): T

        fun visitTieredWithMinimumPrice(tieredWithMinimumPrice: TieredWithMinimumPrice): T

        fun visitTieredPackageWithMinimumPrice(
            tieredPackageWithMinimumPrice: TieredPackageWithMinimumPrice
        ): T

        fun visitPackageWithAllocationPrice(
            packageWithAllocationPrice: PackageWithAllocationPrice
        ): T

        fun visitUnitWithPercentPrice(unitWithPercentPrice: UnitWithPercentPrice): T

        fun visitMatrixWithAllocationPrice(matrixWithAllocationPrice: MatrixWithAllocationPrice): T

        fun visitTieredWithProrationPrice(tieredWithProrationPrice: TieredWithProrationPrice): T

        fun visitUnitWithProrationPrice(unitWithProrationPrice: UnitWithProrationPrice): T

        fun visitGroupedAllocationPrice(groupedAllocationPrice: GroupedAllocationPrice): T

        fun visitGroupedWithProratedMinimumPrice(
            groupedWithProratedMinimumPrice: GroupedWithProratedMinimumPrice
        ): T

        fun visitGroupedWithMeteredMinimumPrice(
            groupedWithMeteredMinimumPrice: GroupedWithMeteredMinimumPrice
        ): T

        fun visitMatrixWithDisplayNamePrice(
            matrixWithDisplayNamePrice: MatrixWithDisplayNamePrice
        ): T

        fun visitBulkWithProrationPrice(bulkWithProrationPrice: BulkWithProrationPrice): T

        fun visitGroupedTieredPackagePrice(groupedTieredPackagePrice: GroupedTieredPackagePrice): T

        fun visitMaxGroupTieredPackagePrice(
            maxGroupTieredPackagePrice: MaxGroupTieredPackagePrice
        ): T

        fun visitScalableMatrixWithUnitPricingPrice(
            scalableMatrixWithUnitPricingPrice: ScalableMatrixWithUnitPricingPrice
        ): T

        fun visitScalableMatrixWithTieredPricingPrice(
            scalableMatrixWithTieredPricingPrice: ScalableMatrixWithTieredPricingPrice
        ): T

        fun visitCumulativeGroupedBulkPrice(
            cumulativeGroupedBulkPrice: CumulativeGroupedBulkPrice
        ): T

        /**
         * Maps an unknown variant of [PriceModel] to a value of type [T].
         *
         * An instance of [PriceModel] can contain an unknown variant if it was deserialized from
         * data that doesn't match any known variant. For example, if the SDK is on an older version
         * than the API, then the API may respond with new variants that the SDK is unaware of.
         *
         * @throws OrbInvalidDataException in the default implementation.
         */
        fun unknown(json: JsonValue?): T {
            throw OrbInvalidDataException("Unknown PriceModel: $json")
        }
    }

    internal class Deserializer : BaseDeserializer<PriceModel>(PriceModel::class) {

        override fun ObjectCodec.deserialize(node: JsonNode): PriceModel {
            val json = JsonValue.fromJsonNode(node)
            val modelType = json.asObject().getOrNull()?.get("model_type")?.asString()?.getOrNull()

            when (modelType) {
                "unit" -> {
                    tryDeserialize(node, jacksonTypeRef<UnitPrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(unitPrice = it, _json = json)
                        }
                }
                "package" -> {
                    tryDeserialize(node, jacksonTypeRef<PackagePrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(packagePrice = it, _json = json)
                        }
                }
                "matrix" -> {
                    tryDeserialize(node, jacksonTypeRef<MatrixPrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(matrixPrice = it, _json = json)
                        }
                }
                "tiered" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredPrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(tieredPrice = it, _json = json)
                        }
                }
                "tiered_bps" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredBpsPrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(tieredBpsPrice = it, _json = json)
                        }
                }
                "bps" -> {
                    tryDeserialize(node, jacksonTypeRef<BpsPrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(bpsPrice = it, _json = json)
                        }
                }
                "bulk_bps" -> {
                    tryDeserialize(node, jacksonTypeRef<BulkBpsPrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(bulkBpsPrice = it, _json = json)
                        }
                }
                "bulk" -> {
                    tryDeserialize(node, jacksonTypeRef<BulkPrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(bulkPrice = it, _json = json)
                        }
                }
                "threshold_total_amount" -> {
                    tryDeserialize(node, jacksonTypeRef<ThresholdTotalAmountPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return PriceModel(thresholdTotalAmountPrice = it, _json = json)
                        }
                }
                "tiered_package" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredPackagePrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(tieredPackagePrice = it, _json = json)
                        }
                }
                "grouped_tiered" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedTieredPrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(groupedTieredPrice = it, _json = json)
                        }
                }
                "tiered_with_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredWithMinimumPrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(tieredWithMinimumPrice = it, _json = json)
                        }
                }
                "tiered_package_with_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredPackageWithMinimumPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return PriceModel(tieredPackageWithMinimumPrice = it, _json = json)
                        }
                }
                "package_with_allocation" -> {
                    tryDeserialize(node, jacksonTypeRef<PackageWithAllocationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return PriceModel(packageWithAllocationPrice = it, _json = json)
                        }
                }
                "unit_with_percent" -> {
                    tryDeserialize(node, jacksonTypeRef<UnitWithPercentPrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(unitWithPercentPrice = it, _json = json)
                        }
                }
                "matrix_with_allocation" -> {
                    tryDeserialize(node, jacksonTypeRef<MatrixWithAllocationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return PriceModel(matrixWithAllocationPrice = it, _json = json)
                        }
                }
                "tiered_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<TieredWithProrationPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return PriceModel(tieredWithProrationPrice = it, _json = json)
                        }
                }
                "unit_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<UnitWithProrationPrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(unitWithProrationPrice = it, _json = json)
                        }
                }
                "grouped_allocation" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedAllocationPrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(groupedAllocationPrice = it, _json = json)
                        }
                }
                "grouped_with_prorated_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedWithProratedMinimumPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return PriceModel(groupedWithProratedMinimumPrice = it, _json = json)
                        }
                }
                "grouped_with_metered_minimum" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedWithMeteredMinimumPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return PriceModel(groupedWithMeteredMinimumPrice = it, _json = json)
                        }
                }
                "matrix_with_display_name" -> {
                    tryDeserialize(node, jacksonTypeRef<MatrixWithDisplayNamePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return PriceModel(matrixWithDisplayNamePrice = it, _json = json)
                        }
                }
                "bulk_with_proration" -> {
                    tryDeserialize(node, jacksonTypeRef<BulkWithProrationPrice>()) { it.validate() }
                        ?.let {
                            return PriceModel(bulkWithProrationPrice = it, _json = json)
                        }
                }
                "grouped_tiered_package" -> {
                    tryDeserialize(node, jacksonTypeRef<GroupedTieredPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return PriceModel(groupedTieredPackagePrice = it, _json = json)
                        }
                }
                "max_group_tiered_package" -> {
                    tryDeserialize(node, jacksonTypeRef<MaxGroupTieredPackagePrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return PriceModel(maxGroupTieredPackagePrice = it, _json = json)
                        }
                }
                "scalable_matrix_with_unit_pricing" -> {
                    tryDeserialize(node, jacksonTypeRef<ScalableMatrixWithUnitPricingPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return PriceModel(scalableMatrixWithUnitPricingPrice = it, _json = json)
                        }
                }
                "scalable_matrix_with_tiered_pricing" -> {
                    tryDeserialize(node, jacksonTypeRef<ScalableMatrixWithTieredPricingPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return PriceModel(
                                scalableMatrixWithTieredPricingPrice = it,
                                _json = json,
                            )
                        }
                }
                "cumulative_grouped_bulk" -> {
                    tryDeserialize(node, jacksonTypeRef<CumulativeGroupedBulkPrice>()) {
                            it.validate()
                        }
                        ?.let {
                            return PriceModel(cumulativeGroupedBulkPrice = it, _json = json)
                        }
                }
            }

            return PriceModel(_json = json)
        }
    }

    internal class Serializer : BaseSerializer<PriceModel>(PriceModel::class) {

        override fun serialize(
            value: PriceModel,
            generator: JsonGenerator,
            provider: SerializerProvider,
        ) {
            when {
                value.unitPrice != null -> generator.writeObject(value.unitPrice)
                value.packagePrice != null -> generator.writeObject(value.packagePrice)
                value.matrixPrice != null -> generator.writeObject(value.matrixPrice)
                value.tieredPrice != null -> generator.writeObject(value.tieredPrice)
                value.tieredBpsPrice != null -> generator.writeObject(value.tieredBpsPrice)
                value.bpsPrice != null -> generator.writeObject(value.bpsPrice)
                value.bulkBpsPrice != null -> generator.writeObject(value.bulkBpsPrice)
                value.bulkPrice != null -> generator.writeObject(value.bulkPrice)
                value.thresholdTotalAmountPrice != null ->
                    generator.writeObject(value.thresholdTotalAmountPrice)
                value.tieredPackagePrice != null -> generator.writeObject(value.tieredPackagePrice)
                value.groupedTieredPrice != null -> generator.writeObject(value.groupedTieredPrice)
                value.tieredWithMinimumPrice != null ->
                    generator.writeObject(value.tieredWithMinimumPrice)
                value.tieredPackageWithMinimumPrice != null ->
                    generator.writeObject(value.tieredPackageWithMinimumPrice)
                value.packageWithAllocationPrice != null ->
                    generator.writeObject(value.packageWithAllocationPrice)
                value.unitWithPercentPrice != null ->
                    generator.writeObject(value.unitWithPercentPrice)
                value.matrixWithAllocationPrice != null ->
                    generator.writeObject(value.matrixWithAllocationPrice)
                value.tieredWithProrationPrice != null ->
                    generator.writeObject(value.tieredWithProrationPrice)
                value.unitWithProrationPrice != null ->
                    generator.writeObject(value.unitWithProrationPrice)
                value.groupedAllocationPrice != null ->
                    generator.writeObject(value.groupedAllocationPrice)
                value.groupedWithProratedMinimumPrice != null ->
                    generator.writeObject(value.groupedWithProratedMinimumPrice)
                value.groupedWithMeteredMinimumPrice != null ->
                    generator.writeObject(value.groupedWithMeteredMinimumPrice)
                value.matrixWithDisplayNamePrice != null ->
                    generator.writeObject(value.matrixWithDisplayNamePrice)
                value.bulkWithProrationPrice != null ->
                    generator.writeObject(value.bulkWithProrationPrice)
                value.groupedTieredPackagePrice != null ->
                    generator.writeObject(value.groupedTieredPackagePrice)
                value.maxGroupTieredPackagePrice != null ->
                    generator.writeObject(value.maxGroupTieredPackagePrice)
                value.scalableMatrixWithUnitPricingPrice != null ->
                    generator.writeObject(value.scalableMatrixWithUnitPricingPrice)
                value.scalableMatrixWithTieredPricingPrice != null ->
                    generator.writeObject(value.scalableMatrixWithTieredPricingPrice)
                value.cumulativeGroupedBulkPrice != null ->
                    generator.writeObject(value.cumulativeGroupedBulkPrice)
                value._json != null -> generator.writeObject(value._json)
                else -> throw IllegalStateException("Invalid PriceModel")
            }
        }
    }

    @NoAutoDetect
    class UnitPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("unit_config")
        @ExcludeMissing
        private val unitConfig: JsonField<UnitConfigModel> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun unitConfig(): UnitConfigModel = unitConfig.getRequired("unit_config")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("unit_config")
        @ExcludeMissing
        fun _unitConfig(): JsonField<UnitConfigModel> = unitConfig

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): UnitPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            unitConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [UnitPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .unitConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [UnitPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var unitConfig: JsonField<UnitConfigModel>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(unitPrice: UnitPrice) = apply {
                id = unitPrice.id
                billableMetric = unitPrice.billableMetric
                billingCycleConfiguration = unitPrice.billingCycleConfiguration
                cadence = unitPrice.cadence
                conversionRate = unitPrice.conversionRate
                createdAt = unitPrice.createdAt
                creditAllocation = unitPrice.creditAllocation
                currency = unitPrice.currency
                discount = unitPrice.discount
                externalPriceId = unitPrice.externalPriceId
                fixedPriceQuantity = unitPrice.fixedPriceQuantity
                invoicingCycleConfiguration = unitPrice.invoicingCycleConfiguration
                item = unitPrice.item
                maximum = unitPrice.maximum
                maximumAmount = unitPrice.maximumAmount
                metadata = unitPrice.metadata
                minimum = unitPrice.minimum
                minimumAmount = unitPrice.minimumAmount
                modelType = unitPrice.modelType
                name = unitPrice.name
                planPhaseOrder = unitPrice.planPhaseOrder
                priceType = unitPrice.priceType
                unitConfig = unitPrice.unitConfig
                dimensionalPriceConfiguration = unitPrice.dimensionalPriceConfiguration
                additionalProperties = unitPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun unitConfig(unitConfig: UnitConfigModel) = unitConfig(JsonField.of(unitConfig))

            fun unitConfig(unitConfig: JsonField<UnitConfigModel>) = apply {
                this.unitConfig = unitConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): UnitPrice =
                UnitPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("unitConfig", unitConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT = of("unit")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                UNIT
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                UNIT,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    UNIT -> Value.UNIT
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    UNIT -> Known.UNIT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is UnitPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && unitConfig == other.unitConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, unitConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "UnitPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, unitConfig=$unitConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class PackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("package_config")
        @ExcludeMissing
        private val packageConfig: JsonField<PackageConfigModel> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun packageConfig(): PackageConfigModel = packageConfig.getRequired("package_config")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("package_config")
        @ExcludeMissing
        fun _packageConfig(): JsonField<PackageConfigModel> = packageConfig

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): PackagePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            packageConfig().validate()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [PackagePrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .packageConfig()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [PackagePrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var packageConfig: JsonField<PackageConfigModel>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(packagePrice: PackagePrice) = apply {
                id = packagePrice.id
                billableMetric = packagePrice.billableMetric
                billingCycleConfiguration = packagePrice.billingCycleConfiguration
                cadence = packagePrice.cadence
                conversionRate = packagePrice.conversionRate
                createdAt = packagePrice.createdAt
                creditAllocation = packagePrice.creditAllocation
                currency = packagePrice.currency
                discount = packagePrice.discount
                externalPriceId = packagePrice.externalPriceId
                fixedPriceQuantity = packagePrice.fixedPriceQuantity
                invoicingCycleConfiguration = packagePrice.invoicingCycleConfiguration
                item = packagePrice.item
                maximum = packagePrice.maximum
                maximumAmount = packagePrice.maximumAmount
                metadata = packagePrice.metadata
                minimum = packagePrice.minimum
                minimumAmount = packagePrice.minimumAmount
                modelType = packagePrice.modelType
                name = packagePrice.name
                packageConfig = packagePrice.packageConfig
                planPhaseOrder = packagePrice.planPhaseOrder
                priceType = packagePrice.priceType
                dimensionalPriceConfiguration = packagePrice.dimensionalPriceConfiguration
                additionalProperties = packagePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun packageConfig(packageConfig: PackageConfigModel) =
                packageConfig(JsonField.of(packageConfig))

            fun packageConfig(packageConfig: JsonField<PackageConfigModel>) = apply {
                this.packageConfig = packageConfig
            }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): PackagePrice =
                PackagePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("packageConfig", packageConfig),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val PACKAGE = of("package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    PACKAGE -> Value.PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    PACKAGE -> Known.PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is PackagePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && packageConfig == other.packageConfig && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, packageConfig, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "PackagePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, packageConfig=$packageConfig, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class MatrixPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("matrix_config")
        @ExcludeMissing
        private val matrixConfig: JsonField<MatrixConfigModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun matrixConfig(): MatrixConfigModel = matrixConfig.getRequired("matrix_config")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("matrix_config")
        @ExcludeMissing
        fun _matrixConfig(): JsonField<MatrixConfigModel> = matrixConfig

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): MatrixPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            matrixConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [MatrixPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [MatrixPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var matrixConfig: JsonField<MatrixConfigModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(matrixPrice: MatrixPrice) = apply {
                id = matrixPrice.id
                billableMetric = matrixPrice.billableMetric
                billingCycleConfiguration = matrixPrice.billingCycleConfiguration
                cadence = matrixPrice.cadence
                conversionRate = matrixPrice.conversionRate
                createdAt = matrixPrice.createdAt
                creditAllocation = matrixPrice.creditAllocation
                currency = matrixPrice.currency
                discount = matrixPrice.discount
                externalPriceId = matrixPrice.externalPriceId
                fixedPriceQuantity = matrixPrice.fixedPriceQuantity
                invoicingCycleConfiguration = matrixPrice.invoicingCycleConfiguration
                item = matrixPrice.item
                matrixConfig = matrixPrice.matrixConfig
                maximum = matrixPrice.maximum
                maximumAmount = matrixPrice.maximumAmount
                metadata = matrixPrice.metadata
                minimum = matrixPrice.minimum
                minimumAmount = matrixPrice.minimumAmount
                modelType = matrixPrice.modelType
                name = matrixPrice.name
                planPhaseOrder = matrixPrice.planPhaseOrder
                priceType = matrixPrice.priceType
                dimensionalPriceConfiguration = matrixPrice.dimensionalPriceConfiguration
                additionalProperties = matrixPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun matrixConfig(matrixConfig: MatrixConfigModel) =
                matrixConfig(JsonField.of(matrixConfig))

            fun matrixConfig(matrixConfig: JsonField<MatrixConfigModel>) = apply {
                this.matrixConfig = matrixConfig
            }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): MatrixPrice =
                MatrixPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixConfig", matrixConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX = of("matrix")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MATRIX
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MATRIX,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MATRIX -> Value.MATRIX
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MATRIX -> Known.MATRIX
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MatrixPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && matrixConfig == other.matrixConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, matrixConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MatrixPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixConfig=$matrixConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_config")
        @ExcludeMissing
        private val tieredConfig: JsonField<TieredConfigModel> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun tieredConfig(): TieredConfigModel = tieredConfig.getRequired("tiered_config")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("tiered_config")
        @ExcludeMissing
        fun _tieredConfig(): JsonField<TieredConfigModel> = tieredConfig

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .tieredConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredConfig: JsonField<TieredConfigModel>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredPrice: TieredPrice) = apply {
                id = tieredPrice.id
                billableMetric = tieredPrice.billableMetric
                billingCycleConfiguration = tieredPrice.billingCycleConfiguration
                cadence = tieredPrice.cadence
                conversionRate = tieredPrice.conversionRate
                createdAt = tieredPrice.createdAt
                creditAllocation = tieredPrice.creditAllocation
                currency = tieredPrice.currency
                discount = tieredPrice.discount
                externalPriceId = tieredPrice.externalPriceId
                fixedPriceQuantity = tieredPrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredPrice.invoicingCycleConfiguration
                item = tieredPrice.item
                maximum = tieredPrice.maximum
                maximumAmount = tieredPrice.maximumAmount
                metadata = tieredPrice.metadata
                minimum = tieredPrice.minimum
                minimumAmount = tieredPrice.minimumAmount
                modelType = tieredPrice.modelType
                name = tieredPrice.name
                planPhaseOrder = tieredPrice.planPhaseOrder
                priceType = tieredPrice.priceType
                tieredConfig = tieredPrice.tieredConfig
                dimensionalPriceConfiguration = tieredPrice.dimensionalPriceConfiguration
                additionalProperties = tieredPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredConfig(tieredConfig: TieredConfigModel) =
                tieredConfig(JsonField.of(tieredConfig))

            fun tieredConfig(tieredConfig: JsonField<TieredConfigModel>) = apply {
                this.tieredConfig = tieredConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredPrice =
                TieredPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredConfig", tieredConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED = of("tiered")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED -> Value.TIERED
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED -> Known.TIERED
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredConfig == other.tieredConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredConfig=$tieredConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredBpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_bps_config")
        @ExcludeMissing
        private val tieredBpsConfig: JsonField<TieredBpsConfigModel> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun tieredBpsConfig(): TieredBpsConfigModel =
            tieredBpsConfig.getRequired("tiered_bps_config")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("tiered_bps_config")
        @ExcludeMissing
        fun _tieredBpsConfig(): JsonField<TieredBpsConfigModel> = tieredBpsConfig

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredBpsPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredBpsConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredBpsPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .tieredBpsConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredBpsPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredBpsConfig: JsonField<TieredBpsConfigModel>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredBpsPrice: TieredBpsPrice) = apply {
                id = tieredBpsPrice.id
                billableMetric = tieredBpsPrice.billableMetric
                billingCycleConfiguration = tieredBpsPrice.billingCycleConfiguration
                cadence = tieredBpsPrice.cadence
                conversionRate = tieredBpsPrice.conversionRate
                createdAt = tieredBpsPrice.createdAt
                creditAllocation = tieredBpsPrice.creditAllocation
                currency = tieredBpsPrice.currency
                discount = tieredBpsPrice.discount
                externalPriceId = tieredBpsPrice.externalPriceId
                fixedPriceQuantity = tieredBpsPrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredBpsPrice.invoicingCycleConfiguration
                item = tieredBpsPrice.item
                maximum = tieredBpsPrice.maximum
                maximumAmount = tieredBpsPrice.maximumAmount
                metadata = tieredBpsPrice.metadata
                minimum = tieredBpsPrice.minimum
                minimumAmount = tieredBpsPrice.minimumAmount
                modelType = tieredBpsPrice.modelType
                name = tieredBpsPrice.name
                planPhaseOrder = tieredBpsPrice.planPhaseOrder
                priceType = tieredBpsPrice.priceType
                tieredBpsConfig = tieredBpsPrice.tieredBpsConfig
                dimensionalPriceConfiguration = tieredBpsPrice.dimensionalPriceConfiguration
                additionalProperties = tieredBpsPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredBpsConfig(tieredBpsConfig: TieredBpsConfigModel) =
                tieredBpsConfig(JsonField.of(tieredBpsConfig))

            fun tieredBpsConfig(tieredBpsConfig: JsonField<TieredBpsConfigModel>) = apply {
                this.tieredBpsConfig = tieredBpsConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredBpsPrice =
                TieredBpsPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredBpsConfig", tieredBpsConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_BPS = of("tiered_bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_BPS
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_BPS,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_BPS -> Value.TIERED_BPS
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_BPS -> Known.TIERED_BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredBpsPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredBpsConfig == other.tieredBpsConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredBpsConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredBpsPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredBpsConfig=$tieredBpsConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class BpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("bps_config")
        @ExcludeMissing
        private val bpsConfig: JsonField<BpsConfigModel> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun bpsConfig(): BpsConfigModel = bpsConfig.getRequired("bps_config")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("bps_config")
        @ExcludeMissing
        fun _bpsConfig(): JsonField<BpsConfigModel> = bpsConfig

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): BpsPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bpsConfig().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [BpsPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bpsConfig()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [BpsPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var bpsConfig: JsonField<BpsConfigModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bpsPrice: BpsPrice) = apply {
                id = bpsPrice.id
                billableMetric = bpsPrice.billableMetric
                billingCycleConfiguration = bpsPrice.billingCycleConfiguration
                bpsConfig = bpsPrice.bpsConfig
                cadence = bpsPrice.cadence
                conversionRate = bpsPrice.conversionRate
                createdAt = bpsPrice.createdAt
                creditAllocation = bpsPrice.creditAllocation
                currency = bpsPrice.currency
                discount = bpsPrice.discount
                externalPriceId = bpsPrice.externalPriceId
                fixedPriceQuantity = bpsPrice.fixedPriceQuantity
                invoicingCycleConfiguration = bpsPrice.invoicingCycleConfiguration
                item = bpsPrice.item
                maximum = bpsPrice.maximum
                maximumAmount = bpsPrice.maximumAmount
                metadata = bpsPrice.metadata
                minimum = bpsPrice.minimum
                minimumAmount = bpsPrice.minimumAmount
                modelType = bpsPrice.modelType
                name = bpsPrice.name
                planPhaseOrder = bpsPrice.planPhaseOrder
                priceType = bpsPrice.priceType
                dimensionalPriceConfiguration = bpsPrice.dimensionalPriceConfiguration
                additionalProperties = bpsPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bpsConfig(bpsConfig: BpsConfigModel) = bpsConfig(JsonField.of(bpsConfig))

            fun bpsConfig(bpsConfig: JsonField<BpsConfigModel>) = apply {
                this.bpsConfig = bpsConfig
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): BpsPrice =
                BpsPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bpsConfig", bpsConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BPS = of("bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BPS
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BPS,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BPS -> Value.BPS
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BPS -> Known.BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BpsPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bpsConfig == other.bpsConfig && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bpsConfig, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BpsPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bpsConfig=$bpsConfig, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class BulkBpsPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("bulk_bps_config")
        @ExcludeMissing
        private val bulkBpsConfig: JsonField<BulkBpsConfigModel> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun bulkBpsConfig(): BulkBpsConfigModel = bulkBpsConfig.getRequired("bulk_bps_config")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("bulk_bps_config")
        @ExcludeMissing
        fun _bulkBpsConfig(): JsonField<BulkBpsConfigModel> = bulkBpsConfig

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): BulkBpsPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bulkBpsConfig().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [BulkBpsPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bulkBpsConfig()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [BulkBpsPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var bulkBpsConfig: JsonField<BulkBpsConfigModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bulkBpsPrice: BulkBpsPrice) = apply {
                id = bulkBpsPrice.id
                billableMetric = bulkBpsPrice.billableMetric
                billingCycleConfiguration = bulkBpsPrice.billingCycleConfiguration
                bulkBpsConfig = bulkBpsPrice.bulkBpsConfig
                cadence = bulkBpsPrice.cadence
                conversionRate = bulkBpsPrice.conversionRate
                createdAt = bulkBpsPrice.createdAt
                creditAllocation = bulkBpsPrice.creditAllocation
                currency = bulkBpsPrice.currency
                discount = bulkBpsPrice.discount
                externalPriceId = bulkBpsPrice.externalPriceId
                fixedPriceQuantity = bulkBpsPrice.fixedPriceQuantity
                invoicingCycleConfiguration = bulkBpsPrice.invoicingCycleConfiguration
                item = bulkBpsPrice.item
                maximum = bulkBpsPrice.maximum
                maximumAmount = bulkBpsPrice.maximumAmount
                metadata = bulkBpsPrice.metadata
                minimum = bulkBpsPrice.minimum
                minimumAmount = bulkBpsPrice.minimumAmount
                modelType = bulkBpsPrice.modelType
                name = bulkBpsPrice.name
                planPhaseOrder = bulkBpsPrice.planPhaseOrder
                priceType = bulkBpsPrice.priceType
                dimensionalPriceConfiguration = bulkBpsPrice.dimensionalPriceConfiguration
                additionalProperties = bulkBpsPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bulkBpsConfig(bulkBpsConfig: BulkBpsConfigModel) =
                bulkBpsConfig(JsonField.of(bulkBpsConfig))

            fun bulkBpsConfig(bulkBpsConfig: JsonField<BulkBpsConfigModel>) = apply {
                this.bulkBpsConfig = bulkBpsConfig
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): BulkBpsPrice =
                BulkBpsPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bulkBpsConfig", bulkBpsConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK_BPS = of("bulk_bps")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BULK_BPS
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BULK_BPS,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BULK_BPS -> Value.BULK_BPS
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BULK_BPS -> Known.BULK_BPS
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BulkBpsPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bulkBpsConfig == other.bulkBpsConfig && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bulkBpsConfig, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BulkBpsPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bulkBpsConfig=$bulkBpsConfig, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class BulkPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("bulk_config")
        @ExcludeMissing
        private val bulkConfig: JsonField<BulkConfigModel> = JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun bulkConfig(): BulkConfigModel = bulkConfig.getRequired("bulk_config")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("bulk_config")
        @ExcludeMissing
        fun _bulkConfig(): JsonField<BulkConfigModel> = bulkConfig

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): BulkPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bulkConfig().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [BulkPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bulkConfig()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [BulkPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var bulkConfig: JsonField<BulkConfigModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bulkPrice: BulkPrice) = apply {
                id = bulkPrice.id
                billableMetric = bulkPrice.billableMetric
                billingCycleConfiguration = bulkPrice.billingCycleConfiguration
                bulkConfig = bulkPrice.bulkConfig
                cadence = bulkPrice.cadence
                conversionRate = bulkPrice.conversionRate
                createdAt = bulkPrice.createdAt
                creditAllocation = bulkPrice.creditAllocation
                currency = bulkPrice.currency
                discount = bulkPrice.discount
                externalPriceId = bulkPrice.externalPriceId
                fixedPriceQuantity = bulkPrice.fixedPriceQuantity
                invoicingCycleConfiguration = bulkPrice.invoicingCycleConfiguration
                item = bulkPrice.item
                maximum = bulkPrice.maximum
                maximumAmount = bulkPrice.maximumAmount
                metadata = bulkPrice.metadata
                minimum = bulkPrice.minimum
                minimumAmount = bulkPrice.minimumAmount
                modelType = bulkPrice.modelType
                name = bulkPrice.name
                planPhaseOrder = bulkPrice.planPhaseOrder
                priceType = bulkPrice.priceType
                dimensionalPriceConfiguration = bulkPrice.dimensionalPriceConfiguration
                additionalProperties = bulkPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bulkConfig(bulkConfig: BulkConfigModel) = bulkConfig(JsonField.of(bulkConfig))

            fun bulkConfig(bulkConfig: JsonField<BulkConfigModel>) = apply {
                this.bulkConfig = bulkConfig
            }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): BulkPrice =
                BulkPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bulkConfig", bulkConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK = of("bulk")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BULK
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BULK,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BULK -> Value.BULK
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BULK -> Known.BULK
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BulkPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bulkConfig == other.bulkConfig && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bulkConfig, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BulkPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bulkConfig=$bulkConfig, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class ThresholdTotalAmountPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("threshold_total_amount_config")
        @ExcludeMissing
        private val thresholdTotalAmountConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun thresholdTotalAmountConfig(): CustomRatingFunctionConfigModel =
            thresholdTotalAmountConfig.getRequired("threshold_total_amount_config")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("threshold_total_amount_config")
        @ExcludeMissing
        fun _thresholdTotalAmountConfig(): JsonField<CustomRatingFunctionConfigModel> =
            thresholdTotalAmountConfig

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): ThresholdTotalAmountPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            thresholdTotalAmountConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [ThresholdTotalAmountPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .thresholdTotalAmountConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [ThresholdTotalAmountPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var thresholdTotalAmountConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(thresholdTotalAmountPrice: ThresholdTotalAmountPrice) = apply {
                id = thresholdTotalAmountPrice.id
                billableMetric = thresholdTotalAmountPrice.billableMetric
                billingCycleConfiguration = thresholdTotalAmountPrice.billingCycleConfiguration
                cadence = thresholdTotalAmountPrice.cadence
                conversionRate = thresholdTotalAmountPrice.conversionRate
                createdAt = thresholdTotalAmountPrice.createdAt
                creditAllocation = thresholdTotalAmountPrice.creditAllocation
                currency = thresholdTotalAmountPrice.currency
                discount = thresholdTotalAmountPrice.discount
                externalPriceId = thresholdTotalAmountPrice.externalPriceId
                fixedPriceQuantity = thresholdTotalAmountPrice.fixedPriceQuantity
                invoicingCycleConfiguration = thresholdTotalAmountPrice.invoicingCycleConfiguration
                item = thresholdTotalAmountPrice.item
                maximum = thresholdTotalAmountPrice.maximum
                maximumAmount = thresholdTotalAmountPrice.maximumAmount
                metadata = thresholdTotalAmountPrice.metadata
                minimum = thresholdTotalAmountPrice.minimum
                minimumAmount = thresholdTotalAmountPrice.minimumAmount
                modelType = thresholdTotalAmountPrice.modelType
                name = thresholdTotalAmountPrice.name
                planPhaseOrder = thresholdTotalAmountPrice.planPhaseOrder
                priceType = thresholdTotalAmountPrice.priceType
                thresholdTotalAmountConfig = thresholdTotalAmountPrice.thresholdTotalAmountConfig
                dimensionalPriceConfiguration =
                    thresholdTotalAmountPrice.dimensionalPriceConfiguration
                additionalProperties = thresholdTotalAmountPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun thresholdTotalAmountConfig(
                thresholdTotalAmountConfig: CustomRatingFunctionConfigModel
            ) = thresholdTotalAmountConfig(JsonField.of(thresholdTotalAmountConfig))

            fun thresholdTotalAmountConfig(
                thresholdTotalAmountConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.thresholdTotalAmountConfig = thresholdTotalAmountConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): ThresholdTotalAmountPrice =
                ThresholdTotalAmountPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("thresholdTotalAmountConfig", thresholdTotalAmountConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val THRESHOLD_TOTAL_AMOUNT = of("threshold_total_amount")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                THRESHOLD_TOTAL_AMOUNT
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                THRESHOLD_TOTAL_AMOUNT,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    THRESHOLD_TOTAL_AMOUNT -> Value.THRESHOLD_TOTAL_AMOUNT
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    THRESHOLD_TOTAL_AMOUNT -> Known.THRESHOLD_TOTAL_AMOUNT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is ThresholdTotalAmountPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && thresholdTotalAmountConfig == other.thresholdTotalAmountConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, thresholdTotalAmountConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "ThresholdTotalAmountPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, thresholdTotalAmountConfig=$thresholdTotalAmountConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_package_config")
        @ExcludeMissing
        private val tieredPackageConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun tieredPackageConfig(): CustomRatingFunctionConfigModel =
            tieredPackageConfig.getRequired("tiered_package_config")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("tiered_package_config")
        @ExcludeMissing
        fun _tieredPackageConfig(): JsonField<CustomRatingFunctionConfigModel> = tieredPackageConfig

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredPackageConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .tieredPackageConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredPackagePrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredPackagePrice: TieredPackagePrice) = apply {
                id = tieredPackagePrice.id
                billableMetric = tieredPackagePrice.billableMetric
                billingCycleConfiguration = tieredPackagePrice.billingCycleConfiguration
                cadence = tieredPackagePrice.cadence
                conversionRate = tieredPackagePrice.conversionRate
                createdAt = tieredPackagePrice.createdAt
                creditAllocation = tieredPackagePrice.creditAllocation
                currency = tieredPackagePrice.currency
                discount = tieredPackagePrice.discount
                externalPriceId = tieredPackagePrice.externalPriceId
                fixedPriceQuantity = tieredPackagePrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredPackagePrice.invoicingCycleConfiguration
                item = tieredPackagePrice.item
                maximum = tieredPackagePrice.maximum
                maximumAmount = tieredPackagePrice.maximumAmount
                metadata = tieredPackagePrice.metadata
                minimum = tieredPackagePrice.minimum
                minimumAmount = tieredPackagePrice.minimumAmount
                modelType = tieredPackagePrice.modelType
                name = tieredPackagePrice.name
                planPhaseOrder = tieredPackagePrice.planPhaseOrder
                priceType = tieredPackagePrice.priceType
                tieredPackageConfig = tieredPackagePrice.tieredPackageConfig
                dimensionalPriceConfiguration = tieredPackagePrice.dimensionalPriceConfiguration
                additionalProperties = tieredPackagePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredPackageConfig(tieredPackageConfig: CustomRatingFunctionConfigModel) =
                tieredPackageConfig(JsonField.of(tieredPackageConfig))

            fun tieredPackageConfig(
                tieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.tieredPackageConfig = tieredPackageConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredPackagePrice =
                TieredPackagePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredPackageConfig", tieredPackageConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_PACKAGE = of("tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_PACKAGE -> Value.TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_PACKAGE -> Known.TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredPackagePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredPackageConfig == other.tieredPackageConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredPackageConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredPackagePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredPackageConfig=$tieredPackageConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedTieredPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_tiered_config")
        @ExcludeMissing
        private val groupedTieredConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun groupedTieredConfig(): CustomRatingFunctionConfigModel =
            groupedTieredConfig.getRequired("grouped_tiered_config")

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("grouped_tiered_config")
        @ExcludeMissing
        fun _groupedTieredConfig(): JsonField<CustomRatingFunctionConfigModel> = groupedTieredConfig

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedTieredPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedTieredConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [GroupedTieredPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedTieredConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedTieredPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedTieredConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedTieredPrice: GroupedTieredPrice) = apply {
                id = groupedTieredPrice.id
                billableMetric = groupedTieredPrice.billableMetric
                billingCycleConfiguration = groupedTieredPrice.billingCycleConfiguration
                cadence = groupedTieredPrice.cadence
                conversionRate = groupedTieredPrice.conversionRate
                createdAt = groupedTieredPrice.createdAt
                creditAllocation = groupedTieredPrice.creditAllocation
                currency = groupedTieredPrice.currency
                discount = groupedTieredPrice.discount
                externalPriceId = groupedTieredPrice.externalPriceId
                fixedPriceQuantity = groupedTieredPrice.fixedPriceQuantity
                groupedTieredConfig = groupedTieredPrice.groupedTieredConfig
                invoicingCycleConfiguration = groupedTieredPrice.invoicingCycleConfiguration
                item = groupedTieredPrice.item
                maximum = groupedTieredPrice.maximum
                maximumAmount = groupedTieredPrice.maximumAmount
                metadata = groupedTieredPrice.metadata
                minimum = groupedTieredPrice.minimum
                minimumAmount = groupedTieredPrice.minimumAmount
                modelType = groupedTieredPrice.modelType
                name = groupedTieredPrice.name
                planPhaseOrder = groupedTieredPrice.planPhaseOrder
                priceType = groupedTieredPrice.priceType
                dimensionalPriceConfiguration = groupedTieredPrice.dimensionalPriceConfiguration
                additionalProperties = groupedTieredPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedTieredConfig(groupedTieredConfig: CustomRatingFunctionConfigModel) =
                groupedTieredConfig(JsonField.of(groupedTieredConfig))

            fun groupedTieredConfig(
                groupedTieredConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedTieredConfig = groupedTieredConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedTieredPrice =
                GroupedTieredPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedTieredConfig", groupedTieredConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_TIERED = of("grouped_tiered")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_TIERED
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_TIERED,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_TIERED -> Value.GROUPED_TIERED
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_TIERED -> Known.GROUPED_TIERED
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedTieredPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedTieredConfig == other.groupedTieredConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedTieredConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedTieredPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedTieredConfig=$groupedTieredConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredWithMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_with_minimum_config")
        @ExcludeMissing
        private val tieredWithMinimumConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun tieredWithMinimumConfig(): CustomRatingFunctionConfigModel =
            tieredWithMinimumConfig.getRequired("tiered_with_minimum_config")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("tiered_with_minimum_config")
        @ExcludeMissing
        fun _tieredWithMinimumConfig(): JsonField<CustomRatingFunctionConfigModel> =
            tieredWithMinimumConfig

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredWithMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredWithMinimumConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredWithMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .tieredWithMinimumConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredWithMinimumPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredWithMinimumConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredWithMinimumPrice: TieredWithMinimumPrice) = apply {
                id = tieredWithMinimumPrice.id
                billableMetric = tieredWithMinimumPrice.billableMetric
                billingCycleConfiguration = tieredWithMinimumPrice.billingCycleConfiguration
                cadence = tieredWithMinimumPrice.cadence
                conversionRate = tieredWithMinimumPrice.conversionRate
                createdAt = tieredWithMinimumPrice.createdAt
                creditAllocation = tieredWithMinimumPrice.creditAllocation
                currency = tieredWithMinimumPrice.currency
                discount = tieredWithMinimumPrice.discount
                externalPriceId = tieredWithMinimumPrice.externalPriceId
                fixedPriceQuantity = tieredWithMinimumPrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredWithMinimumPrice.invoicingCycleConfiguration
                item = tieredWithMinimumPrice.item
                maximum = tieredWithMinimumPrice.maximum
                maximumAmount = tieredWithMinimumPrice.maximumAmount
                metadata = tieredWithMinimumPrice.metadata
                minimum = tieredWithMinimumPrice.minimum
                minimumAmount = tieredWithMinimumPrice.minimumAmount
                modelType = tieredWithMinimumPrice.modelType
                name = tieredWithMinimumPrice.name
                planPhaseOrder = tieredWithMinimumPrice.planPhaseOrder
                priceType = tieredWithMinimumPrice.priceType
                tieredWithMinimumConfig = tieredWithMinimumPrice.tieredWithMinimumConfig
                dimensionalPriceConfiguration = tieredWithMinimumPrice.dimensionalPriceConfiguration
                additionalProperties = tieredWithMinimumPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredWithMinimumConfig(tieredWithMinimumConfig: CustomRatingFunctionConfigModel) =
                tieredWithMinimumConfig(JsonField.of(tieredWithMinimumConfig))

            fun tieredWithMinimumConfig(
                tieredWithMinimumConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.tieredWithMinimumConfig = tieredWithMinimumConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredWithMinimumPrice =
                TieredWithMinimumPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredWithMinimumConfig", tieredWithMinimumConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_WITH_MINIMUM = of("tiered_with_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_WITH_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_WITH_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_WITH_MINIMUM -> Value.TIERED_WITH_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_WITH_MINIMUM -> Known.TIERED_WITH_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredWithMinimumPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredWithMinimumConfig == other.tieredWithMinimumConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredWithMinimumConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredWithMinimumPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredWithMinimumConfig=$tieredWithMinimumConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredPackageWithMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_package_with_minimum_config")
        @ExcludeMissing
        private val tieredPackageWithMinimumConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun tieredPackageWithMinimumConfig(): CustomRatingFunctionConfigModel =
            tieredPackageWithMinimumConfig.getRequired("tiered_package_with_minimum_config")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("tiered_package_with_minimum_config")
        @ExcludeMissing
        fun _tieredPackageWithMinimumConfig(): JsonField<CustomRatingFunctionConfigModel> =
            tieredPackageWithMinimumConfig

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredPackageWithMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredPackageWithMinimumConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [TieredPackageWithMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .tieredPackageWithMinimumConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredPackageWithMinimumPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredPackageWithMinimumConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredPackageWithMinimumPrice: TieredPackageWithMinimumPrice) =
                apply {
                    id = tieredPackageWithMinimumPrice.id
                    billableMetric = tieredPackageWithMinimumPrice.billableMetric
                    billingCycleConfiguration =
                        tieredPackageWithMinimumPrice.billingCycleConfiguration
                    cadence = tieredPackageWithMinimumPrice.cadence
                    conversionRate = tieredPackageWithMinimumPrice.conversionRate
                    createdAt = tieredPackageWithMinimumPrice.createdAt
                    creditAllocation = tieredPackageWithMinimumPrice.creditAllocation
                    currency = tieredPackageWithMinimumPrice.currency
                    discount = tieredPackageWithMinimumPrice.discount
                    externalPriceId = tieredPackageWithMinimumPrice.externalPriceId
                    fixedPriceQuantity = tieredPackageWithMinimumPrice.fixedPriceQuantity
                    invoicingCycleConfiguration =
                        tieredPackageWithMinimumPrice.invoicingCycleConfiguration
                    item = tieredPackageWithMinimumPrice.item
                    maximum = tieredPackageWithMinimumPrice.maximum
                    maximumAmount = tieredPackageWithMinimumPrice.maximumAmount
                    metadata = tieredPackageWithMinimumPrice.metadata
                    minimum = tieredPackageWithMinimumPrice.minimum
                    minimumAmount = tieredPackageWithMinimumPrice.minimumAmount
                    modelType = tieredPackageWithMinimumPrice.modelType
                    name = tieredPackageWithMinimumPrice.name
                    planPhaseOrder = tieredPackageWithMinimumPrice.planPhaseOrder
                    priceType = tieredPackageWithMinimumPrice.priceType
                    tieredPackageWithMinimumConfig =
                        tieredPackageWithMinimumPrice.tieredPackageWithMinimumConfig
                    dimensionalPriceConfiguration =
                        tieredPackageWithMinimumPrice.dimensionalPriceConfiguration
                    additionalProperties =
                        tieredPackageWithMinimumPrice.additionalProperties.toMutableMap()
                }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredPackageWithMinimumConfig(
                tieredPackageWithMinimumConfig: CustomRatingFunctionConfigModel
            ) = tieredPackageWithMinimumConfig(JsonField.of(tieredPackageWithMinimumConfig))

            fun tieredPackageWithMinimumConfig(
                tieredPackageWithMinimumConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.tieredPackageWithMinimumConfig = tieredPackageWithMinimumConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredPackageWithMinimumPrice =
                TieredPackageWithMinimumPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredPackageWithMinimumConfig", tieredPackageWithMinimumConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_PACKAGE_WITH_MINIMUM = of("tiered_package_with_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_PACKAGE_WITH_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_PACKAGE_WITH_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_PACKAGE_WITH_MINIMUM -> Value.TIERED_PACKAGE_WITH_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_PACKAGE_WITH_MINIMUM -> Known.TIERED_PACKAGE_WITH_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredPackageWithMinimumPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredPackageWithMinimumConfig == other.tieredPackageWithMinimumConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredPackageWithMinimumConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredPackageWithMinimumPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredPackageWithMinimumConfig=$tieredPackageWithMinimumConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class PackageWithAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("package_with_allocation_config")
        @ExcludeMissing
        private val packageWithAllocationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun packageWithAllocationConfig(): CustomRatingFunctionConfigModel =
            packageWithAllocationConfig.getRequired("package_with_allocation_config")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("package_with_allocation_config")
        @ExcludeMissing
        fun _packageWithAllocationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            packageWithAllocationConfig

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): PackageWithAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            packageWithAllocationConfig().validate()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [PackageWithAllocationPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .packageWithAllocationConfig()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [PackageWithAllocationPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var packageWithAllocationConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(packageWithAllocationPrice: PackageWithAllocationPrice) = apply {
                id = packageWithAllocationPrice.id
                billableMetric = packageWithAllocationPrice.billableMetric
                billingCycleConfiguration = packageWithAllocationPrice.billingCycleConfiguration
                cadence = packageWithAllocationPrice.cadence
                conversionRate = packageWithAllocationPrice.conversionRate
                createdAt = packageWithAllocationPrice.createdAt
                creditAllocation = packageWithAllocationPrice.creditAllocation
                currency = packageWithAllocationPrice.currency
                discount = packageWithAllocationPrice.discount
                externalPriceId = packageWithAllocationPrice.externalPriceId
                fixedPriceQuantity = packageWithAllocationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = packageWithAllocationPrice.invoicingCycleConfiguration
                item = packageWithAllocationPrice.item
                maximum = packageWithAllocationPrice.maximum
                maximumAmount = packageWithAllocationPrice.maximumAmount
                metadata = packageWithAllocationPrice.metadata
                minimum = packageWithAllocationPrice.minimum
                minimumAmount = packageWithAllocationPrice.minimumAmount
                modelType = packageWithAllocationPrice.modelType
                name = packageWithAllocationPrice.name
                packageWithAllocationConfig = packageWithAllocationPrice.packageWithAllocationConfig
                planPhaseOrder = packageWithAllocationPrice.planPhaseOrder
                priceType = packageWithAllocationPrice.priceType
                dimensionalPriceConfiguration =
                    packageWithAllocationPrice.dimensionalPriceConfiguration
                additionalProperties =
                    packageWithAllocationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun packageWithAllocationConfig(
                packageWithAllocationConfig: CustomRatingFunctionConfigModel
            ) = packageWithAllocationConfig(JsonField.of(packageWithAllocationConfig))

            fun packageWithAllocationConfig(
                packageWithAllocationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.packageWithAllocationConfig = packageWithAllocationConfig }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): PackageWithAllocationPrice =
                PackageWithAllocationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("packageWithAllocationConfig", packageWithAllocationConfig),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val PACKAGE_WITH_ALLOCATION = of("package_with_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                PACKAGE_WITH_ALLOCATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                PACKAGE_WITH_ALLOCATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    PACKAGE_WITH_ALLOCATION -> Value.PACKAGE_WITH_ALLOCATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    PACKAGE_WITH_ALLOCATION -> Known.PACKAGE_WITH_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is PackageWithAllocationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && packageWithAllocationConfig == other.packageWithAllocationConfig && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, packageWithAllocationConfig, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "PackageWithAllocationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, packageWithAllocationConfig=$packageWithAllocationConfig, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class UnitWithPercentPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("unit_with_percent_config")
        @ExcludeMissing
        private val unitWithPercentConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun unitWithPercentConfig(): CustomRatingFunctionConfigModel =
            unitWithPercentConfig.getRequired("unit_with_percent_config")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("unit_with_percent_config")
        @ExcludeMissing
        fun _unitWithPercentConfig(): JsonField<CustomRatingFunctionConfigModel> =
            unitWithPercentConfig

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): UnitWithPercentPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            unitWithPercentConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [UnitWithPercentPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .unitWithPercentConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [UnitWithPercentPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var unitWithPercentConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(unitWithPercentPrice: UnitWithPercentPrice) = apply {
                id = unitWithPercentPrice.id
                billableMetric = unitWithPercentPrice.billableMetric
                billingCycleConfiguration = unitWithPercentPrice.billingCycleConfiguration
                cadence = unitWithPercentPrice.cadence
                conversionRate = unitWithPercentPrice.conversionRate
                createdAt = unitWithPercentPrice.createdAt
                creditAllocation = unitWithPercentPrice.creditAllocation
                currency = unitWithPercentPrice.currency
                discount = unitWithPercentPrice.discount
                externalPriceId = unitWithPercentPrice.externalPriceId
                fixedPriceQuantity = unitWithPercentPrice.fixedPriceQuantity
                invoicingCycleConfiguration = unitWithPercentPrice.invoicingCycleConfiguration
                item = unitWithPercentPrice.item
                maximum = unitWithPercentPrice.maximum
                maximumAmount = unitWithPercentPrice.maximumAmount
                metadata = unitWithPercentPrice.metadata
                minimum = unitWithPercentPrice.minimum
                minimumAmount = unitWithPercentPrice.minimumAmount
                modelType = unitWithPercentPrice.modelType
                name = unitWithPercentPrice.name
                planPhaseOrder = unitWithPercentPrice.planPhaseOrder
                priceType = unitWithPercentPrice.priceType
                unitWithPercentConfig = unitWithPercentPrice.unitWithPercentConfig
                dimensionalPriceConfiguration = unitWithPercentPrice.dimensionalPriceConfiguration
                additionalProperties = unitWithPercentPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun unitWithPercentConfig(unitWithPercentConfig: CustomRatingFunctionConfigModel) =
                unitWithPercentConfig(JsonField.of(unitWithPercentConfig))

            fun unitWithPercentConfig(
                unitWithPercentConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.unitWithPercentConfig = unitWithPercentConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): UnitWithPercentPrice =
                UnitWithPercentPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("unitWithPercentConfig", unitWithPercentConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT_WITH_PERCENT = of("unit_with_percent")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                UNIT_WITH_PERCENT
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                UNIT_WITH_PERCENT,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    UNIT_WITH_PERCENT -> Value.UNIT_WITH_PERCENT
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    UNIT_WITH_PERCENT -> Known.UNIT_WITH_PERCENT
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is UnitWithPercentPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && unitWithPercentConfig == other.unitWithPercentConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, unitWithPercentConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "UnitWithPercentPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, unitWithPercentConfig=$unitWithPercentConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class MatrixWithAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("matrix_with_allocation_config")
        @ExcludeMissing
        private val matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfigModel> =
            JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun matrixWithAllocationConfig(): MatrixWithAllocationConfigModel =
            matrixWithAllocationConfig.getRequired("matrix_with_allocation_config")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("matrix_with_allocation_config")
        @ExcludeMissing
        fun _matrixWithAllocationConfig(): JsonField<MatrixWithAllocationConfigModel> =
            matrixWithAllocationConfig

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): MatrixWithAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            matrixWithAllocationConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [MatrixWithAllocationPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixWithAllocationConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [MatrixWithAllocationPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfigModel>? =
                null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(matrixWithAllocationPrice: MatrixWithAllocationPrice) = apply {
                id = matrixWithAllocationPrice.id
                billableMetric = matrixWithAllocationPrice.billableMetric
                billingCycleConfiguration = matrixWithAllocationPrice.billingCycleConfiguration
                cadence = matrixWithAllocationPrice.cadence
                conversionRate = matrixWithAllocationPrice.conversionRate
                createdAt = matrixWithAllocationPrice.createdAt
                creditAllocation = matrixWithAllocationPrice.creditAllocation
                currency = matrixWithAllocationPrice.currency
                discount = matrixWithAllocationPrice.discount
                externalPriceId = matrixWithAllocationPrice.externalPriceId
                fixedPriceQuantity = matrixWithAllocationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = matrixWithAllocationPrice.invoicingCycleConfiguration
                item = matrixWithAllocationPrice.item
                matrixWithAllocationConfig = matrixWithAllocationPrice.matrixWithAllocationConfig
                maximum = matrixWithAllocationPrice.maximum
                maximumAmount = matrixWithAllocationPrice.maximumAmount
                metadata = matrixWithAllocationPrice.metadata
                minimum = matrixWithAllocationPrice.minimum
                minimumAmount = matrixWithAllocationPrice.minimumAmount
                modelType = matrixWithAllocationPrice.modelType
                name = matrixWithAllocationPrice.name
                planPhaseOrder = matrixWithAllocationPrice.planPhaseOrder
                priceType = matrixWithAllocationPrice.priceType
                dimensionalPriceConfiguration =
                    matrixWithAllocationPrice.dimensionalPriceConfiguration
                additionalProperties = matrixWithAllocationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun matrixWithAllocationConfig(
                matrixWithAllocationConfig: MatrixWithAllocationConfigModel
            ) = matrixWithAllocationConfig(JsonField.of(matrixWithAllocationConfig))

            fun matrixWithAllocationConfig(
                matrixWithAllocationConfig: JsonField<MatrixWithAllocationConfigModel>
            ) = apply { this.matrixWithAllocationConfig = matrixWithAllocationConfig }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): MatrixWithAllocationPrice =
                MatrixWithAllocationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixWithAllocationConfig", matrixWithAllocationConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX_WITH_ALLOCATION = of("matrix_with_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MATRIX_WITH_ALLOCATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MATRIX_WITH_ALLOCATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MATRIX_WITH_ALLOCATION -> Value.MATRIX_WITH_ALLOCATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MATRIX_WITH_ALLOCATION -> Known.MATRIX_WITH_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MatrixWithAllocationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && matrixWithAllocationConfig == other.matrixWithAllocationConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, matrixWithAllocationConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MatrixWithAllocationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixWithAllocationConfig=$matrixWithAllocationConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class TieredWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("tiered_with_proration_config")
        @ExcludeMissing
        private val tieredWithProrationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun tieredWithProrationConfig(): CustomRatingFunctionConfigModel =
            tieredWithProrationConfig.getRequired("tiered_with_proration_config")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("tiered_with_proration_config")
        @ExcludeMissing
        fun _tieredWithProrationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            tieredWithProrationConfig

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): TieredWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            tieredWithProrationConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [TieredWithProrationPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .tieredWithProrationConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [TieredWithProrationPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var tieredWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(tieredWithProrationPrice: TieredWithProrationPrice) = apply {
                id = tieredWithProrationPrice.id
                billableMetric = tieredWithProrationPrice.billableMetric
                billingCycleConfiguration = tieredWithProrationPrice.billingCycleConfiguration
                cadence = tieredWithProrationPrice.cadence
                conversionRate = tieredWithProrationPrice.conversionRate
                createdAt = tieredWithProrationPrice.createdAt
                creditAllocation = tieredWithProrationPrice.creditAllocation
                currency = tieredWithProrationPrice.currency
                discount = tieredWithProrationPrice.discount
                externalPriceId = tieredWithProrationPrice.externalPriceId
                fixedPriceQuantity = tieredWithProrationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = tieredWithProrationPrice.invoicingCycleConfiguration
                item = tieredWithProrationPrice.item
                maximum = tieredWithProrationPrice.maximum
                maximumAmount = tieredWithProrationPrice.maximumAmount
                metadata = tieredWithProrationPrice.metadata
                minimum = tieredWithProrationPrice.minimum
                minimumAmount = tieredWithProrationPrice.minimumAmount
                modelType = tieredWithProrationPrice.modelType
                name = tieredWithProrationPrice.name
                planPhaseOrder = tieredWithProrationPrice.planPhaseOrder
                priceType = tieredWithProrationPrice.priceType
                tieredWithProrationConfig = tieredWithProrationPrice.tieredWithProrationConfig
                dimensionalPriceConfiguration =
                    tieredWithProrationPrice.dimensionalPriceConfiguration
                additionalProperties = tieredWithProrationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun tieredWithProrationConfig(
                tieredWithProrationConfig: CustomRatingFunctionConfigModel
            ) = tieredWithProrationConfig(JsonField.of(tieredWithProrationConfig))

            fun tieredWithProrationConfig(
                tieredWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.tieredWithProrationConfig = tieredWithProrationConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): TieredWithProrationPrice =
                TieredWithProrationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("tieredWithProrationConfig", tieredWithProrationConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val TIERED_WITH_PRORATION = of("tiered_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                TIERED_WITH_PRORATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                TIERED_WITH_PRORATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    TIERED_WITH_PRORATION -> Value.TIERED_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    TIERED_WITH_PRORATION -> Known.TIERED_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is TieredWithProrationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && tieredWithProrationConfig == other.tieredWithProrationConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, tieredWithProrationConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "TieredWithProrationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, tieredWithProrationConfig=$tieredWithProrationConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class UnitWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("unit_with_proration_config")
        @ExcludeMissing
        private val unitWithProrationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun unitWithProrationConfig(): CustomRatingFunctionConfigModel =
            unitWithProrationConfig.getRequired("unit_with_proration_config")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("unit_with_proration_config")
        @ExcludeMissing
        fun _unitWithProrationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            unitWithProrationConfig

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): UnitWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            unitWithProrationConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [UnitWithProrationPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .unitWithProrationConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [UnitWithProrationPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var unitWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(unitWithProrationPrice: UnitWithProrationPrice) = apply {
                id = unitWithProrationPrice.id
                billableMetric = unitWithProrationPrice.billableMetric
                billingCycleConfiguration = unitWithProrationPrice.billingCycleConfiguration
                cadence = unitWithProrationPrice.cadence
                conversionRate = unitWithProrationPrice.conversionRate
                createdAt = unitWithProrationPrice.createdAt
                creditAllocation = unitWithProrationPrice.creditAllocation
                currency = unitWithProrationPrice.currency
                discount = unitWithProrationPrice.discount
                externalPriceId = unitWithProrationPrice.externalPriceId
                fixedPriceQuantity = unitWithProrationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = unitWithProrationPrice.invoicingCycleConfiguration
                item = unitWithProrationPrice.item
                maximum = unitWithProrationPrice.maximum
                maximumAmount = unitWithProrationPrice.maximumAmount
                metadata = unitWithProrationPrice.metadata
                minimum = unitWithProrationPrice.minimum
                minimumAmount = unitWithProrationPrice.minimumAmount
                modelType = unitWithProrationPrice.modelType
                name = unitWithProrationPrice.name
                planPhaseOrder = unitWithProrationPrice.planPhaseOrder
                priceType = unitWithProrationPrice.priceType
                unitWithProrationConfig = unitWithProrationPrice.unitWithProrationConfig
                dimensionalPriceConfiguration = unitWithProrationPrice.dimensionalPriceConfiguration
                additionalProperties = unitWithProrationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun unitWithProrationConfig(unitWithProrationConfig: CustomRatingFunctionConfigModel) =
                unitWithProrationConfig(JsonField.of(unitWithProrationConfig))

            fun unitWithProrationConfig(
                unitWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.unitWithProrationConfig = unitWithProrationConfig }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): UnitWithProrationPrice =
                UnitWithProrationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired("unitWithProrationConfig", unitWithProrationConfig),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val UNIT_WITH_PRORATION = of("unit_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                UNIT_WITH_PRORATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                UNIT_WITH_PRORATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    UNIT_WITH_PRORATION -> Value.UNIT_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    UNIT_WITH_PRORATION -> Known.UNIT_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is UnitWithProrationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && unitWithProrationConfig == other.unitWithProrationConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, unitWithProrationConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "UnitWithProrationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, unitWithProrationConfig=$unitWithProrationConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedAllocationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_allocation_config")
        @ExcludeMissing
        private val groupedAllocationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun groupedAllocationConfig(): CustomRatingFunctionConfigModel =
            groupedAllocationConfig.getRequired("grouped_allocation_config")

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("grouped_allocation_config")
        @ExcludeMissing
        fun _groupedAllocationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            groupedAllocationConfig

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedAllocationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedAllocationConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [GroupedAllocationPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedAllocationConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedAllocationPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedAllocationConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedAllocationPrice: GroupedAllocationPrice) = apply {
                id = groupedAllocationPrice.id
                billableMetric = groupedAllocationPrice.billableMetric
                billingCycleConfiguration = groupedAllocationPrice.billingCycleConfiguration
                cadence = groupedAllocationPrice.cadence
                conversionRate = groupedAllocationPrice.conversionRate
                createdAt = groupedAllocationPrice.createdAt
                creditAllocation = groupedAllocationPrice.creditAllocation
                currency = groupedAllocationPrice.currency
                discount = groupedAllocationPrice.discount
                externalPriceId = groupedAllocationPrice.externalPriceId
                fixedPriceQuantity = groupedAllocationPrice.fixedPriceQuantity
                groupedAllocationConfig = groupedAllocationPrice.groupedAllocationConfig
                invoicingCycleConfiguration = groupedAllocationPrice.invoicingCycleConfiguration
                item = groupedAllocationPrice.item
                maximum = groupedAllocationPrice.maximum
                maximumAmount = groupedAllocationPrice.maximumAmount
                metadata = groupedAllocationPrice.metadata
                minimum = groupedAllocationPrice.minimum
                minimumAmount = groupedAllocationPrice.minimumAmount
                modelType = groupedAllocationPrice.modelType
                name = groupedAllocationPrice.name
                planPhaseOrder = groupedAllocationPrice.planPhaseOrder
                priceType = groupedAllocationPrice.priceType
                dimensionalPriceConfiguration = groupedAllocationPrice.dimensionalPriceConfiguration
                additionalProperties = groupedAllocationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedAllocationConfig(groupedAllocationConfig: CustomRatingFunctionConfigModel) =
                groupedAllocationConfig(JsonField.of(groupedAllocationConfig))

            fun groupedAllocationConfig(
                groupedAllocationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedAllocationConfig = groupedAllocationConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedAllocationPrice =
                GroupedAllocationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedAllocationConfig", groupedAllocationConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_ALLOCATION = of("grouped_allocation")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_ALLOCATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_ALLOCATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_ALLOCATION -> Value.GROUPED_ALLOCATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_ALLOCATION -> Known.GROUPED_ALLOCATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedAllocationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedAllocationConfig == other.groupedAllocationConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedAllocationConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedAllocationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedAllocationConfig=$groupedAllocationConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedWithProratedMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_with_prorated_minimum_config")
        @ExcludeMissing
        private val groupedWithProratedMinimumConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun groupedWithProratedMinimumConfig(): CustomRatingFunctionConfigModel =
            groupedWithProratedMinimumConfig.getRequired("grouped_with_prorated_minimum_config")

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("grouped_with_prorated_minimum_config")
        @ExcludeMissing
        fun _groupedWithProratedMinimumConfig(): JsonField<CustomRatingFunctionConfigModel> =
            groupedWithProratedMinimumConfig

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedWithProratedMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedWithProratedMinimumConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [GroupedWithProratedMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithProratedMinimumConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedWithProratedMinimumPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedWithProratedMinimumConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedWithProratedMinimumPrice: GroupedWithProratedMinimumPrice) =
                apply {
                    id = groupedWithProratedMinimumPrice.id
                    billableMetric = groupedWithProratedMinimumPrice.billableMetric
                    billingCycleConfiguration =
                        groupedWithProratedMinimumPrice.billingCycleConfiguration
                    cadence = groupedWithProratedMinimumPrice.cadence
                    conversionRate = groupedWithProratedMinimumPrice.conversionRate
                    createdAt = groupedWithProratedMinimumPrice.createdAt
                    creditAllocation = groupedWithProratedMinimumPrice.creditAllocation
                    currency = groupedWithProratedMinimumPrice.currency
                    discount = groupedWithProratedMinimumPrice.discount
                    externalPriceId = groupedWithProratedMinimumPrice.externalPriceId
                    fixedPriceQuantity = groupedWithProratedMinimumPrice.fixedPriceQuantity
                    groupedWithProratedMinimumConfig =
                        groupedWithProratedMinimumPrice.groupedWithProratedMinimumConfig
                    invoicingCycleConfiguration =
                        groupedWithProratedMinimumPrice.invoicingCycleConfiguration
                    item = groupedWithProratedMinimumPrice.item
                    maximum = groupedWithProratedMinimumPrice.maximum
                    maximumAmount = groupedWithProratedMinimumPrice.maximumAmount
                    metadata = groupedWithProratedMinimumPrice.metadata
                    minimum = groupedWithProratedMinimumPrice.minimum
                    minimumAmount = groupedWithProratedMinimumPrice.minimumAmount
                    modelType = groupedWithProratedMinimumPrice.modelType
                    name = groupedWithProratedMinimumPrice.name
                    planPhaseOrder = groupedWithProratedMinimumPrice.planPhaseOrder
                    priceType = groupedWithProratedMinimumPrice.priceType
                    dimensionalPriceConfiguration =
                        groupedWithProratedMinimumPrice.dimensionalPriceConfiguration
                    additionalProperties =
                        groupedWithProratedMinimumPrice.additionalProperties.toMutableMap()
                }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: CustomRatingFunctionConfigModel
            ) = groupedWithProratedMinimumConfig(JsonField.of(groupedWithProratedMinimumConfig))

            fun groupedWithProratedMinimumConfig(
                groupedWithProratedMinimumConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedWithProratedMinimumConfig = groupedWithProratedMinimumConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedWithProratedMinimumPrice =
                GroupedWithProratedMinimumPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired(
                        "groupedWithProratedMinimumConfig",
                        groupedWithProratedMinimumConfig,
                    ),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_WITH_PRORATED_MINIMUM = of("grouped_with_prorated_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_WITH_PRORATED_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_WITH_PRORATED_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_WITH_PRORATED_MINIMUM -> Value.GROUPED_WITH_PRORATED_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_WITH_PRORATED_MINIMUM -> Known.GROUPED_WITH_PRORATED_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedWithProratedMinimumPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedWithProratedMinimumConfig == other.groupedWithProratedMinimumConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedWithProratedMinimumConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedWithProratedMinimumPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedWithProratedMinimumConfig=$groupedWithProratedMinimumConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedWithMeteredMinimumPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_with_metered_minimum_config")
        @ExcludeMissing
        private val groupedWithMeteredMinimumConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun groupedWithMeteredMinimumConfig(): CustomRatingFunctionConfigModel =
            groupedWithMeteredMinimumConfig.getRequired("grouped_with_metered_minimum_config")

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("grouped_with_metered_minimum_config")
        @ExcludeMissing
        fun _groupedWithMeteredMinimumConfig(): JsonField<CustomRatingFunctionConfigModel> =
            groupedWithMeteredMinimumConfig

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedWithMeteredMinimumPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedWithMeteredMinimumConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [GroupedWithMeteredMinimumPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedWithMeteredMinimumConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedWithMeteredMinimumPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedWithMeteredMinimumConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedWithMeteredMinimumPrice: GroupedWithMeteredMinimumPrice) =
                apply {
                    id = groupedWithMeteredMinimumPrice.id
                    billableMetric = groupedWithMeteredMinimumPrice.billableMetric
                    billingCycleConfiguration =
                        groupedWithMeteredMinimumPrice.billingCycleConfiguration
                    cadence = groupedWithMeteredMinimumPrice.cadence
                    conversionRate = groupedWithMeteredMinimumPrice.conversionRate
                    createdAt = groupedWithMeteredMinimumPrice.createdAt
                    creditAllocation = groupedWithMeteredMinimumPrice.creditAllocation
                    currency = groupedWithMeteredMinimumPrice.currency
                    discount = groupedWithMeteredMinimumPrice.discount
                    externalPriceId = groupedWithMeteredMinimumPrice.externalPriceId
                    fixedPriceQuantity = groupedWithMeteredMinimumPrice.fixedPriceQuantity
                    groupedWithMeteredMinimumConfig =
                        groupedWithMeteredMinimumPrice.groupedWithMeteredMinimumConfig
                    invoicingCycleConfiguration =
                        groupedWithMeteredMinimumPrice.invoicingCycleConfiguration
                    item = groupedWithMeteredMinimumPrice.item
                    maximum = groupedWithMeteredMinimumPrice.maximum
                    maximumAmount = groupedWithMeteredMinimumPrice.maximumAmount
                    metadata = groupedWithMeteredMinimumPrice.metadata
                    minimum = groupedWithMeteredMinimumPrice.minimum
                    minimumAmount = groupedWithMeteredMinimumPrice.minimumAmount
                    modelType = groupedWithMeteredMinimumPrice.modelType
                    name = groupedWithMeteredMinimumPrice.name
                    planPhaseOrder = groupedWithMeteredMinimumPrice.planPhaseOrder
                    priceType = groupedWithMeteredMinimumPrice.priceType
                    dimensionalPriceConfiguration =
                        groupedWithMeteredMinimumPrice.dimensionalPriceConfiguration
                    additionalProperties =
                        groupedWithMeteredMinimumPrice.additionalProperties.toMutableMap()
                }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: CustomRatingFunctionConfigModel
            ) = groupedWithMeteredMinimumConfig(JsonField.of(groupedWithMeteredMinimumConfig))

            fun groupedWithMeteredMinimumConfig(
                groupedWithMeteredMinimumConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedWithMeteredMinimumConfig = groupedWithMeteredMinimumConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedWithMeteredMinimumPrice =
                GroupedWithMeteredMinimumPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired(
                        "groupedWithMeteredMinimumConfig",
                        groupedWithMeteredMinimumConfig,
                    ),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_WITH_METERED_MINIMUM = of("grouped_with_metered_minimum")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_WITH_METERED_MINIMUM
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_WITH_METERED_MINIMUM,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_WITH_METERED_MINIMUM -> Value.GROUPED_WITH_METERED_MINIMUM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_WITH_METERED_MINIMUM -> Known.GROUPED_WITH_METERED_MINIMUM
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedWithMeteredMinimumPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedWithMeteredMinimumConfig == other.groupedWithMeteredMinimumConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedWithMeteredMinimumConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedWithMeteredMinimumPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedWithMeteredMinimumConfig=$groupedWithMeteredMinimumConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class MatrixWithDisplayNamePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("matrix_with_display_name_config")
        @ExcludeMissing
        private val matrixWithDisplayNameConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun matrixWithDisplayNameConfig(): CustomRatingFunctionConfigModel =
            matrixWithDisplayNameConfig.getRequired("matrix_with_display_name_config")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("matrix_with_display_name_config")
        @ExcludeMissing
        fun _matrixWithDisplayNameConfig(): JsonField<CustomRatingFunctionConfigModel> =
            matrixWithDisplayNameConfig

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): MatrixWithDisplayNamePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            matrixWithDisplayNameConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [MatrixWithDisplayNamePrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .matrixWithDisplayNameConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [MatrixWithDisplayNamePrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var matrixWithDisplayNameConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(matrixWithDisplayNamePrice: MatrixWithDisplayNamePrice) = apply {
                id = matrixWithDisplayNamePrice.id
                billableMetric = matrixWithDisplayNamePrice.billableMetric
                billingCycleConfiguration = matrixWithDisplayNamePrice.billingCycleConfiguration
                cadence = matrixWithDisplayNamePrice.cadence
                conversionRate = matrixWithDisplayNamePrice.conversionRate
                createdAt = matrixWithDisplayNamePrice.createdAt
                creditAllocation = matrixWithDisplayNamePrice.creditAllocation
                currency = matrixWithDisplayNamePrice.currency
                discount = matrixWithDisplayNamePrice.discount
                externalPriceId = matrixWithDisplayNamePrice.externalPriceId
                fixedPriceQuantity = matrixWithDisplayNamePrice.fixedPriceQuantity
                invoicingCycleConfiguration = matrixWithDisplayNamePrice.invoicingCycleConfiguration
                item = matrixWithDisplayNamePrice.item
                matrixWithDisplayNameConfig = matrixWithDisplayNamePrice.matrixWithDisplayNameConfig
                maximum = matrixWithDisplayNamePrice.maximum
                maximumAmount = matrixWithDisplayNamePrice.maximumAmount
                metadata = matrixWithDisplayNamePrice.metadata
                minimum = matrixWithDisplayNamePrice.minimum
                minimumAmount = matrixWithDisplayNamePrice.minimumAmount
                modelType = matrixWithDisplayNamePrice.modelType
                name = matrixWithDisplayNamePrice.name
                planPhaseOrder = matrixWithDisplayNamePrice.planPhaseOrder
                priceType = matrixWithDisplayNamePrice.priceType
                dimensionalPriceConfiguration =
                    matrixWithDisplayNamePrice.dimensionalPriceConfiguration
                additionalProperties =
                    matrixWithDisplayNamePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: CustomRatingFunctionConfigModel
            ) = matrixWithDisplayNameConfig(JsonField.of(matrixWithDisplayNameConfig))

            fun matrixWithDisplayNameConfig(
                matrixWithDisplayNameConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.matrixWithDisplayNameConfig = matrixWithDisplayNameConfig }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): MatrixWithDisplayNamePrice =
                MatrixWithDisplayNamePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("matrixWithDisplayNameConfig", matrixWithDisplayNameConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MATRIX_WITH_DISPLAY_NAME = of("matrix_with_display_name")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MATRIX_WITH_DISPLAY_NAME
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MATRIX_WITH_DISPLAY_NAME,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MATRIX_WITH_DISPLAY_NAME -> Value.MATRIX_WITH_DISPLAY_NAME
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MATRIX_WITH_DISPLAY_NAME -> Known.MATRIX_WITH_DISPLAY_NAME
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MatrixWithDisplayNamePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && matrixWithDisplayNameConfig == other.matrixWithDisplayNameConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, matrixWithDisplayNameConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MatrixWithDisplayNamePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, matrixWithDisplayNameConfig=$matrixWithDisplayNameConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class BulkWithProrationPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("bulk_with_proration_config")
        @ExcludeMissing
        private val bulkWithProrationConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun bulkWithProrationConfig(): CustomRatingFunctionConfigModel =
            bulkWithProrationConfig.getRequired("bulk_with_proration_config")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("bulk_with_proration_config")
        @ExcludeMissing
        fun _bulkWithProrationConfig(): JsonField<CustomRatingFunctionConfigModel> =
            bulkWithProrationConfig

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): BulkWithProrationPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            bulkWithProrationConfig().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [BulkWithProrationPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .bulkWithProrationConfig()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [BulkWithProrationPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var bulkWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(bulkWithProrationPrice: BulkWithProrationPrice) = apply {
                id = bulkWithProrationPrice.id
                billableMetric = bulkWithProrationPrice.billableMetric
                billingCycleConfiguration = bulkWithProrationPrice.billingCycleConfiguration
                bulkWithProrationConfig = bulkWithProrationPrice.bulkWithProrationConfig
                cadence = bulkWithProrationPrice.cadence
                conversionRate = bulkWithProrationPrice.conversionRate
                createdAt = bulkWithProrationPrice.createdAt
                creditAllocation = bulkWithProrationPrice.creditAllocation
                currency = bulkWithProrationPrice.currency
                discount = bulkWithProrationPrice.discount
                externalPriceId = bulkWithProrationPrice.externalPriceId
                fixedPriceQuantity = bulkWithProrationPrice.fixedPriceQuantity
                invoicingCycleConfiguration = bulkWithProrationPrice.invoicingCycleConfiguration
                item = bulkWithProrationPrice.item
                maximum = bulkWithProrationPrice.maximum
                maximumAmount = bulkWithProrationPrice.maximumAmount
                metadata = bulkWithProrationPrice.metadata
                minimum = bulkWithProrationPrice.minimum
                minimumAmount = bulkWithProrationPrice.minimumAmount
                modelType = bulkWithProrationPrice.modelType
                name = bulkWithProrationPrice.name
                planPhaseOrder = bulkWithProrationPrice.planPhaseOrder
                priceType = bulkWithProrationPrice.priceType
                dimensionalPriceConfiguration = bulkWithProrationPrice.dimensionalPriceConfiguration
                additionalProperties = bulkWithProrationPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun bulkWithProrationConfig(bulkWithProrationConfig: CustomRatingFunctionConfigModel) =
                bulkWithProrationConfig(JsonField.of(bulkWithProrationConfig))

            fun bulkWithProrationConfig(
                bulkWithProrationConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.bulkWithProrationConfig = bulkWithProrationConfig }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): BulkWithProrationPrice =
                BulkWithProrationPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("bulkWithProrationConfig", bulkWithProrationConfig),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val BULK_WITH_PRORATION = of("bulk_with_proration")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                BULK_WITH_PRORATION
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                BULK_WITH_PRORATION,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    BULK_WITH_PRORATION -> Value.BULK_WITH_PRORATION
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    BULK_WITH_PRORATION -> Known.BULK_WITH_PRORATION
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is BulkWithProrationPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && bulkWithProrationConfig == other.bulkWithProrationConfig && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, bulkWithProrationConfig, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "BulkWithProrationPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, bulkWithProrationConfig=$bulkWithProrationConfig, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class GroupedTieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("grouped_tiered_package_config")
        @ExcludeMissing
        private val groupedTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun groupedTieredPackageConfig(): CustomRatingFunctionConfigModel =
            groupedTieredPackageConfig.getRequired("grouped_tiered_package_config")

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("grouped_tiered_package_config")
        @ExcludeMissing
        fun _groupedTieredPackageConfig(): JsonField<CustomRatingFunctionConfigModel> =
            groupedTieredPackageConfig

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): GroupedTieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            groupedTieredPackageConfig().validate()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [GroupedTieredPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .groupedTieredPackageConfig()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [GroupedTieredPackagePrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var groupedTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(groupedTieredPackagePrice: GroupedTieredPackagePrice) = apply {
                id = groupedTieredPackagePrice.id
                billableMetric = groupedTieredPackagePrice.billableMetric
                billingCycleConfiguration = groupedTieredPackagePrice.billingCycleConfiguration
                cadence = groupedTieredPackagePrice.cadence
                conversionRate = groupedTieredPackagePrice.conversionRate
                createdAt = groupedTieredPackagePrice.createdAt
                creditAllocation = groupedTieredPackagePrice.creditAllocation
                currency = groupedTieredPackagePrice.currency
                discount = groupedTieredPackagePrice.discount
                externalPriceId = groupedTieredPackagePrice.externalPriceId
                fixedPriceQuantity = groupedTieredPackagePrice.fixedPriceQuantity
                groupedTieredPackageConfig = groupedTieredPackagePrice.groupedTieredPackageConfig
                invoicingCycleConfiguration = groupedTieredPackagePrice.invoicingCycleConfiguration
                item = groupedTieredPackagePrice.item
                maximum = groupedTieredPackagePrice.maximum
                maximumAmount = groupedTieredPackagePrice.maximumAmount
                metadata = groupedTieredPackagePrice.metadata
                minimum = groupedTieredPackagePrice.minimum
                minimumAmount = groupedTieredPackagePrice.minimumAmount
                modelType = groupedTieredPackagePrice.modelType
                name = groupedTieredPackagePrice.name
                planPhaseOrder = groupedTieredPackagePrice.planPhaseOrder
                priceType = groupedTieredPackagePrice.priceType
                dimensionalPriceConfiguration =
                    groupedTieredPackagePrice.dimensionalPriceConfiguration
                additionalProperties = groupedTieredPackagePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun groupedTieredPackageConfig(
                groupedTieredPackageConfig: CustomRatingFunctionConfigModel
            ) = groupedTieredPackageConfig(JsonField.of(groupedTieredPackageConfig))

            fun groupedTieredPackageConfig(
                groupedTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.groupedTieredPackageConfig = groupedTieredPackageConfig }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): GroupedTieredPackagePrice =
                GroupedTieredPackagePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("groupedTieredPackageConfig", groupedTieredPackageConfig),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val GROUPED_TIERED_PACKAGE = of("grouped_tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                GROUPED_TIERED_PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                GROUPED_TIERED_PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    GROUPED_TIERED_PACKAGE -> Value.GROUPED_TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    GROUPED_TIERED_PACKAGE -> Known.GROUPED_TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is GroupedTieredPackagePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && groupedTieredPackageConfig == other.groupedTieredPackageConfig && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, groupedTieredPackageConfig, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "GroupedTieredPackagePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, groupedTieredPackageConfig=$groupedTieredPackageConfig, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class MaxGroupTieredPackagePrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("max_group_tiered_package_config")
        @ExcludeMissing
        private val maxGroupTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maxGroupTieredPackageConfig(): CustomRatingFunctionConfigModel =
            maxGroupTieredPackageConfig.getRequired("max_group_tiered_package_config")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("max_group_tiered_package_config")
        @ExcludeMissing
        fun _maxGroupTieredPackageConfig(): JsonField<CustomRatingFunctionConfigModel> =
            maxGroupTieredPackageConfig

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): MaxGroupTieredPackagePrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maxGroupTieredPackageConfig().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [MaxGroupTieredPackagePrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maxGroupTieredPackageConfig()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [MaxGroupTieredPackagePrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maxGroupTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(maxGroupTieredPackagePrice: MaxGroupTieredPackagePrice) = apply {
                id = maxGroupTieredPackagePrice.id
                billableMetric = maxGroupTieredPackagePrice.billableMetric
                billingCycleConfiguration = maxGroupTieredPackagePrice.billingCycleConfiguration
                cadence = maxGroupTieredPackagePrice.cadence
                conversionRate = maxGroupTieredPackagePrice.conversionRate
                createdAt = maxGroupTieredPackagePrice.createdAt
                creditAllocation = maxGroupTieredPackagePrice.creditAllocation
                currency = maxGroupTieredPackagePrice.currency
                discount = maxGroupTieredPackagePrice.discount
                externalPriceId = maxGroupTieredPackagePrice.externalPriceId
                fixedPriceQuantity = maxGroupTieredPackagePrice.fixedPriceQuantity
                invoicingCycleConfiguration = maxGroupTieredPackagePrice.invoicingCycleConfiguration
                item = maxGroupTieredPackagePrice.item
                maxGroupTieredPackageConfig = maxGroupTieredPackagePrice.maxGroupTieredPackageConfig
                maximum = maxGroupTieredPackagePrice.maximum
                maximumAmount = maxGroupTieredPackagePrice.maximumAmount
                metadata = maxGroupTieredPackagePrice.metadata
                minimum = maxGroupTieredPackagePrice.minimum
                minimumAmount = maxGroupTieredPackagePrice.minimumAmount
                modelType = maxGroupTieredPackagePrice.modelType
                name = maxGroupTieredPackagePrice.name
                planPhaseOrder = maxGroupTieredPackagePrice.planPhaseOrder
                priceType = maxGroupTieredPackagePrice.priceType
                dimensionalPriceConfiguration =
                    maxGroupTieredPackagePrice.dimensionalPriceConfiguration
                additionalProperties =
                    maxGroupTieredPackagePrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maxGroupTieredPackageConfig(
                maxGroupTieredPackageConfig: CustomRatingFunctionConfigModel
            ) = maxGroupTieredPackageConfig(JsonField.of(maxGroupTieredPackageConfig))

            fun maxGroupTieredPackageConfig(
                maxGroupTieredPackageConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.maxGroupTieredPackageConfig = maxGroupTieredPackageConfig }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): MaxGroupTieredPackagePrice =
                MaxGroupTieredPackagePrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maxGroupTieredPackageConfig", maxGroupTieredPackageConfig),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val MAX_GROUP_TIERED_PACKAGE = of("max_group_tiered_package")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                MAX_GROUP_TIERED_PACKAGE
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                MAX_GROUP_TIERED_PACKAGE,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    MAX_GROUP_TIERED_PACKAGE -> Value.MAX_GROUP_TIERED_PACKAGE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    MAX_GROUP_TIERED_PACKAGE -> Known.MAX_GROUP_TIERED_PACKAGE
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is MaxGroupTieredPackagePrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maxGroupTieredPackageConfig == other.maxGroupTieredPackageConfig && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maxGroupTieredPackageConfig, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "MaxGroupTieredPackagePrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maxGroupTieredPackageConfig=$maxGroupTieredPackageConfig, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class ScalableMatrixWithUnitPricingPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("scalable_matrix_with_unit_pricing_config")
        @ExcludeMissing
        private val scalableMatrixWithUnitPricingConfig:
            JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun scalableMatrixWithUnitPricingConfig(): CustomRatingFunctionConfigModel =
            scalableMatrixWithUnitPricingConfig.getRequired(
                "scalable_matrix_with_unit_pricing_config"
            )

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("scalable_matrix_with_unit_pricing_config")
        @ExcludeMissing
        fun _scalableMatrixWithUnitPricingConfig(): JsonField<CustomRatingFunctionConfigModel> =
            scalableMatrixWithUnitPricingConfig

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): ScalableMatrixWithUnitPricingPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            scalableMatrixWithUnitPricingConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [ScalableMatrixWithUnitPricingPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .scalableMatrixWithUnitPricingConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [ScalableMatrixWithUnitPricingPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var scalableMatrixWithUnitPricingConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                scalableMatrixWithUnitPricingPrice: ScalableMatrixWithUnitPricingPrice
            ) = apply {
                id = scalableMatrixWithUnitPricingPrice.id
                billableMetric = scalableMatrixWithUnitPricingPrice.billableMetric
                billingCycleConfiguration =
                    scalableMatrixWithUnitPricingPrice.billingCycleConfiguration
                cadence = scalableMatrixWithUnitPricingPrice.cadence
                conversionRate = scalableMatrixWithUnitPricingPrice.conversionRate
                createdAt = scalableMatrixWithUnitPricingPrice.createdAt
                creditAllocation = scalableMatrixWithUnitPricingPrice.creditAllocation
                currency = scalableMatrixWithUnitPricingPrice.currency
                discount = scalableMatrixWithUnitPricingPrice.discount
                externalPriceId = scalableMatrixWithUnitPricingPrice.externalPriceId
                fixedPriceQuantity = scalableMatrixWithUnitPricingPrice.fixedPriceQuantity
                invoicingCycleConfiguration =
                    scalableMatrixWithUnitPricingPrice.invoicingCycleConfiguration
                item = scalableMatrixWithUnitPricingPrice.item
                maximum = scalableMatrixWithUnitPricingPrice.maximum
                maximumAmount = scalableMatrixWithUnitPricingPrice.maximumAmount
                metadata = scalableMatrixWithUnitPricingPrice.metadata
                minimum = scalableMatrixWithUnitPricingPrice.minimum
                minimumAmount = scalableMatrixWithUnitPricingPrice.minimumAmount
                modelType = scalableMatrixWithUnitPricingPrice.modelType
                name = scalableMatrixWithUnitPricingPrice.name
                planPhaseOrder = scalableMatrixWithUnitPricingPrice.planPhaseOrder
                priceType = scalableMatrixWithUnitPricingPrice.priceType
                scalableMatrixWithUnitPricingConfig =
                    scalableMatrixWithUnitPricingPrice.scalableMatrixWithUnitPricingConfig
                dimensionalPriceConfiguration =
                    scalableMatrixWithUnitPricingPrice.dimensionalPriceConfiguration
                additionalProperties =
                    scalableMatrixWithUnitPricingPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun scalableMatrixWithUnitPricingConfig(
                scalableMatrixWithUnitPricingConfig: CustomRatingFunctionConfigModel
            ) =
                scalableMatrixWithUnitPricingConfig(
                    JsonField.of(scalableMatrixWithUnitPricingConfig)
                )

            fun scalableMatrixWithUnitPricingConfig(
                scalableMatrixWithUnitPricingConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply {
                this.scalableMatrixWithUnitPricingConfig = scalableMatrixWithUnitPricingConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): ScalableMatrixWithUnitPricingPrice =
                ScalableMatrixWithUnitPricingPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired(
                        "scalableMatrixWithUnitPricingConfig",
                        scalableMatrixWithUnitPricingConfig,
                    ),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField
                val SCALABLE_MATRIX_WITH_UNIT_PRICING = of("scalable_matrix_with_unit_pricing")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                SCALABLE_MATRIX_WITH_UNIT_PRICING
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                SCALABLE_MATRIX_WITH_UNIT_PRICING,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    SCALABLE_MATRIX_WITH_UNIT_PRICING -> Value.SCALABLE_MATRIX_WITH_UNIT_PRICING
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    SCALABLE_MATRIX_WITH_UNIT_PRICING -> Known.SCALABLE_MATRIX_WITH_UNIT_PRICING
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is ScalableMatrixWithUnitPricingPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && scalableMatrixWithUnitPricingConfig == other.scalableMatrixWithUnitPricingConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, scalableMatrixWithUnitPricingConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "ScalableMatrixWithUnitPricingPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, scalableMatrixWithUnitPricingConfig=$scalableMatrixWithUnitPricingConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class ScalableMatrixWithTieredPricingPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("scalable_matrix_with_tiered_pricing_config")
        @ExcludeMissing
        private val scalableMatrixWithTieredPricingConfig:
            JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun scalableMatrixWithTieredPricingConfig(): CustomRatingFunctionConfigModel =
            scalableMatrixWithTieredPricingConfig.getRequired(
                "scalable_matrix_with_tiered_pricing_config"
            )

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("scalable_matrix_with_tiered_pricing_config")
        @ExcludeMissing
        fun _scalableMatrixWithTieredPricingConfig(): JsonField<CustomRatingFunctionConfigModel> =
            scalableMatrixWithTieredPricingConfig

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): ScalableMatrixWithTieredPricingPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            scalableMatrixWithTieredPricingConfig().validate()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [ScalableMatrixWithTieredPricingPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * .scalableMatrixWithTieredPricingConfig()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [ScalableMatrixWithTieredPricingPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var scalableMatrixWithTieredPricingConfig:
                JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(
                scalableMatrixWithTieredPricingPrice: ScalableMatrixWithTieredPricingPrice
            ) = apply {
                id = scalableMatrixWithTieredPricingPrice.id
                billableMetric = scalableMatrixWithTieredPricingPrice.billableMetric
                billingCycleConfiguration =
                    scalableMatrixWithTieredPricingPrice.billingCycleConfiguration
                cadence = scalableMatrixWithTieredPricingPrice.cadence
                conversionRate = scalableMatrixWithTieredPricingPrice.conversionRate
                createdAt = scalableMatrixWithTieredPricingPrice.createdAt
                creditAllocation = scalableMatrixWithTieredPricingPrice.creditAllocation
                currency = scalableMatrixWithTieredPricingPrice.currency
                discount = scalableMatrixWithTieredPricingPrice.discount
                externalPriceId = scalableMatrixWithTieredPricingPrice.externalPriceId
                fixedPriceQuantity = scalableMatrixWithTieredPricingPrice.fixedPriceQuantity
                invoicingCycleConfiguration =
                    scalableMatrixWithTieredPricingPrice.invoicingCycleConfiguration
                item = scalableMatrixWithTieredPricingPrice.item
                maximum = scalableMatrixWithTieredPricingPrice.maximum
                maximumAmount = scalableMatrixWithTieredPricingPrice.maximumAmount
                metadata = scalableMatrixWithTieredPricingPrice.metadata
                minimum = scalableMatrixWithTieredPricingPrice.minimum
                minimumAmount = scalableMatrixWithTieredPricingPrice.minimumAmount
                modelType = scalableMatrixWithTieredPricingPrice.modelType
                name = scalableMatrixWithTieredPricingPrice.name
                planPhaseOrder = scalableMatrixWithTieredPricingPrice.planPhaseOrder
                priceType = scalableMatrixWithTieredPricingPrice.priceType
                scalableMatrixWithTieredPricingConfig =
                    scalableMatrixWithTieredPricingPrice.scalableMatrixWithTieredPricingConfig
                dimensionalPriceConfiguration =
                    scalableMatrixWithTieredPricingPrice.dimensionalPriceConfiguration
                additionalProperties =
                    scalableMatrixWithTieredPricingPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun scalableMatrixWithTieredPricingConfig(
                scalableMatrixWithTieredPricingConfig: CustomRatingFunctionConfigModel
            ) =
                scalableMatrixWithTieredPricingConfig(
                    JsonField.of(scalableMatrixWithTieredPricingConfig)
                )

            fun scalableMatrixWithTieredPricingConfig(
                scalableMatrixWithTieredPricingConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply {
                this.scalableMatrixWithTieredPricingConfig = scalableMatrixWithTieredPricingConfig
            }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): ScalableMatrixWithTieredPricingPrice =
                ScalableMatrixWithTieredPricingPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    checkRequired(
                        "scalableMatrixWithTieredPricingConfig",
                        scalableMatrixWithTieredPricingConfig,
                    ),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField
                val SCALABLE_MATRIX_WITH_TIERED_PRICING = of("scalable_matrix_with_tiered_pricing")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                SCALABLE_MATRIX_WITH_TIERED_PRICING
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                SCALABLE_MATRIX_WITH_TIERED_PRICING,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    SCALABLE_MATRIX_WITH_TIERED_PRICING -> Value.SCALABLE_MATRIX_WITH_TIERED_PRICING
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    SCALABLE_MATRIX_WITH_TIERED_PRICING -> Known.SCALABLE_MATRIX_WITH_TIERED_PRICING
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is ScalableMatrixWithTieredPricingPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && scalableMatrixWithTieredPricingConfig == other.scalableMatrixWithTieredPricingConfig && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, scalableMatrixWithTieredPricingConfig, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "ScalableMatrixWithTieredPricingPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, scalableMatrixWithTieredPricingConfig=$scalableMatrixWithTieredPricingConfig, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }

    @NoAutoDetect
    class CumulativeGroupedBulkPrice
    @JsonCreator
    private constructor(
        @JsonProperty("id") @ExcludeMissing private val id: JsonField<String> = JsonMissing.of(),
        @JsonProperty("billable_metric")
        @ExcludeMissing
        private val billableMetric: JsonField<BillableMetricTinyModel> = JsonMissing.of(),
        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        private val billingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("cadence")
        @ExcludeMissing
        private val cadence: JsonField<Cadence> = JsonMissing.of(),
        @JsonProperty("conversion_rate")
        @ExcludeMissing
        private val conversionRate: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("created_at")
        @ExcludeMissing
        private val createdAt: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("credit_allocation")
        @ExcludeMissing
        private val creditAllocation: JsonField<AllocationModel> = JsonMissing.of(),
        @JsonProperty("cumulative_grouped_bulk_config")
        @ExcludeMissing
        private val cumulativeGroupedBulkConfig: JsonField<CustomRatingFunctionConfigModel> =
            JsonMissing.of(),
        @JsonProperty("currency")
        @ExcludeMissing
        private val currency: JsonField<String> = JsonMissing.of(),
        @JsonProperty("discount")
        @ExcludeMissing
        private val discount: JsonField<Discount> = JsonMissing.of(),
        @JsonProperty("external_price_id")
        @ExcludeMissing
        private val externalPriceId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        private val fixedPriceQuantity: JsonField<Double> = JsonMissing.of(),
        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        private val invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel> =
            JsonMissing.of(),
        @JsonProperty("item")
        @ExcludeMissing
        private val item: JsonField<ItemSlimModel> = JsonMissing.of(),
        @JsonProperty("maximum")
        @ExcludeMissing
        private val maximum: JsonField<MaximumModel> = JsonMissing.of(),
        @JsonProperty("maximum_amount")
        @ExcludeMissing
        private val maximumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("metadata")
        @ExcludeMissing
        private val metadata: JsonField<Metadata> = JsonMissing.of(),
        @JsonProperty("minimum")
        @ExcludeMissing
        private val minimum: JsonField<MinimumModel> = JsonMissing.of(),
        @JsonProperty("minimum_amount")
        @ExcludeMissing
        private val minimumAmount: JsonField<String> = JsonMissing.of(),
        @JsonProperty("model_type")
        @ExcludeMissing
        private val modelType: JsonField<ModelType> = JsonMissing.of(),
        @JsonProperty("name")
        @ExcludeMissing
        private val name: JsonField<String> = JsonMissing.of(),
        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        private val planPhaseOrder: JsonField<Long> = JsonMissing.of(),
        @JsonProperty("price_type")
        @ExcludeMissing
        private val priceType: JsonField<PriceType> = JsonMissing.of(),
        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        private val dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel> =
            JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        fun id(): String = id.getRequired("id")

        fun billableMetric(): Optional<BillableMetricTinyModel> =
            Optional.ofNullable(billableMetric.getNullable("billable_metric"))

        fun billingCycleConfiguration(): BillingCycleConfigurationModel =
            billingCycleConfiguration.getRequired("billing_cycle_configuration")

        fun cadence(): Cadence = cadence.getRequired("cadence")

        fun conversionRate(): Optional<Double> =
            Optional.ofNullable(conversionRate.getNullable("conversion_rate"))

        fun createdAt(): OffsetDateTime = createdAt.getRequired("created_at")

        fun creditAllocation(): Optional<AllocationModel> =
            Optional.ofNullable(creditAllocation.getNullable("credit_allocation"))

        fun cumulativeGroupedBulkConfig(): CustomRatingFunctionConfigModel =
            cumulativeGroupedBulkConfig.getRequired("cumulative_grouped_bulk_config")

        fun currency(): String = currency.getRequired("currency")

        fun discount(): Optional<Discount> = Optional.ofNullable(discount.getNullable("discount"))

        fun externalPriceId(): Optional<String> =
            Optional.ofNullable(externalPriceId.getNullable("external_price_id"))

        fun fixedPriceQuantity(): Optional<Double> =
            Optional.ofNullable(fixedPriceQuantity.getNullable("fixed_price_quantity"))

        fun invoicingCycleConfiguration(): Optional<BillingCycleConfigurationModel> =
            Optional.ofNullable(
                invoicingCycleConfiguration.getNullable("invoicing_cycle_configuration")
            )

        fun item(): ItemSlimModel = item.getRequired("item")

        fun maximum(): Optional<MaximumModel> = Optional.ofNullable(maximum.getNullable("maximum"))

        fun maximumAmount(): Optional<String> =
            Optional.ofNullable(maximumAmount.getNullable("maximum_amount"))

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        fun metadata(): Metadata = metadata.getRequired("metadata")

        fun minimum(): Optional<MinimumModel> = Optional.ofNullable(minimum.getNullable("minimum"))

        fun minimumAmount(): Optional<String> =
            Optional.ofNullable(minimumAmount.getNullable("minimum_amount"))

        fun modelType(): ModelType = modelType.getRequired("model_type")

        fun name(): String = name.getRequired("name")

        fun planPhaseOrder(): Optional<Long> =
            Optional.ofNullable(planPhaseOrder.getNullable("plan_phase_order"))

        fun priceType(): PriceType = priceType.getRequired("price_type")

        fun dimensionalPriceConfiguration(): Optional<DimensionalPriceConfigurationModel> =
            Optional.ofNullable(
                dimensionalPriceConfiguration.getNullable("dimensional_price_configuration")
            )

        @JsonProperty("id") @ExcludeMissing fun _id(): JsonField<String> = id

        @JsonProperty("billable_metric")
        @ExcludeMissing
        fun _billableMetric(): JsonField<BillableMetricTinyModel> = billableMetric

        @JsonProperty("billing_cycle_configuration")
        @ExcludeMissing
        fun _billingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            billingCycleConfiguration

        @JsonProperty("cadence") @ExcludeMissing fun _cadence(): JsonField<Cadence> = cadence

        @JsonProperty("conversion_rate")
        @ExcludeMissing
        fun _conversionRate(): JsonField<Double> = conversionRate

        @JsonProperty("created_at")
        @ExcludeMissing
        fun _createdAt(): JsonField<OffsetDateTime> = createdAt

        @JsonProperty("credit_allocation")
        @ExcludeMissing
        fun _creditAllocation(): JsonField<AllocationModel> = creditAllocation

        @JsonProperty("cumulative_grouped_bulk_config")
        @ExcludeMissing
        fun _cumulativeGroupedBulkConfig(): JsonField<CustomRatingFunctionConfigModel> =
            cumulativeGroupedBulkConfig

        @JsonProperty("currency") @ExcludeMissing fun _currency(): JsonField<String> = currency

        @JsonProperty("discount") @ExcludeMissing fun _discount(): JsonField<Discount> = discount

        @JsonProperty("external_price_id")
        @ExcludeMissing
        fun _externalPriceId(): JsonField<String> = externalPriceId

        @JsonProperty("fixed_price_quantity")
        @ExcludeMissing
        fun _fixedPriceQuantity(): JsonField<Double> = fixedPriceQuantity

        @JsonProperty("invoicing_cycle_configuration")
        @ExcludeMissing
        fun _invoicingCycleConfiguration(): JsonField<BillingCycleConfigurationModel> =
            invoicingCycleConfiguration

        @JsonProperty("item") @ExcludeMissing fun _item(): JsonField<ItemSlimModel> = item

        @JsonProperty("maximum") @ExcludeMissing fun _maximum(): JsonField<MaximumModel> = maximum

        @JsonProperty("maximum_amount")
        @ExcludeMissing
        fun _maximumAmount(): JsonField<String> = maximumAmount

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @JsonProperty("metadata") @ExcludeMissing fun _metadata(): JsonField<Metadata> = metadata

        @JsonProperty("minimum") @ExcludeMissing fun _minimum(): JsonField<MinimumModel> = minimum

        @JsonProperty("minimum_amount")
        @ExcludeMissing
        fun _minimumAmount(): JsonField<String> = minimumAmount

        @JsonProperty("model_type")
        @ExcludeMissing
        fun _modelType(): JsonField<ModelType> = modelType

        @JsonProperty("name") @ExcludeMissing fun _name(): JsonField<String> = name

        @JsonProperty("plan_phase_order")
        @ExcludeMissing
        fun _planPhaseOrder(): JsonField<Long> = planPhaseOrder

        @JsonProperty("price_type")
        @ExcludeMissing
        fun _priceType(): JsonField<PriceType> = priceType

        @JsonProperty("dimensional_price_configuration")
        @ExcludeMissing
        fun _dimensionalPriceConfiguration(): JsonField<DimensionalPriceConfigurationModel> =
            dimensionalPriceConfiguration

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): CumulativeGroupedBulkPrice = apply {
            if (validated) {
                return@apply
            }

            id()
            billableMetric().ifPresent { it.validate() }
            billingCycleConfiguration().validate()
            cadence()
            conversionRate()
            createdAt()
            creditAllocation().ifPresent { it.validate() }
            cumulativeGroupedBulkConfig().validate()
            currency()
            discount().ifPresent { it.validate() }
            externalPriceId()
            fixedPriceQuantity()
            invoicingCycleConfiguration().ifPresent { it.validate() }
            item().validate()
            maximum().ifPresent { it.validate() }
            maximumAmount()
            metadata().validate()
            minimum().ifPresent { it.validate() }
            minimumAmount()
            modelType()
            name()
            planPhaseOrder()
            priceType()
            dimensionalPriceConfiguration().ifPresent { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of
             * [CumulativeGroupedBulkPrice].
             *
             * The following fields are required:
             * ```java
             * .id()
             * .billableMetric()
             * .billingCycleConfiguration()
             * .cadence()
             * .conversionRate()
             * .createdAt()
             * .creditAllocation()
             * .cumulativeGroupedBulkConfig()
             * .currency()
             * .discount()
             * .externalPriceId()
             * .fixedPriceQuantity()
             * .invoicingCycleConfiguration()
             * .item()
             * .maximum()
             * .maximumAmount()
             * .metadata()
             * .minimum()
             * .minimumAmount()
             * .modelType()
             * .name()
             * .planPhaseOrder()
             * .priceType()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [CumulativeGroupedBulkPrice]. */
        class Builder internal constructor() {

            private var id: JsonField<String>? = null
            private var billableMetric: JsonField<BillableMetricTinyModel>? = null
            private var billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? = null
            private var cadence: JsonField<Cadence>? = null
            private var conversionRate: JsonField<Double>? = null
            private var createdAt: JsonField<OffsetDateTime>? = null
            private var creditAllocation: JsonField<AllocationModel>? = null
            private var cumulativeGroupedBulkConfig: JsonField<CustomRatingFunctionConfigModel>? =
                null
            private var currency: JsonField<String>? = null
            private var discount: JsonField<Discount>? = null
            private var externalPriceId: JsonField<String>? = null
            private var fixedPriceQuantity: JsonField<Double>? = null
            private var invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>? =
                null
            private var item: JsonField<ItemSlimModel>? = null
            private var maximum: JsonField<MaximumModel>? = null
            private var maximumAmount: JsonField<String>? = null
            private var metadata: JsonField<Metadata>? = null
            private var minimum: JsonField<MinimumModel>? = null
            private var minimumAmount: JsonField<String>? = null
            private var modelType: JsonField<ModelType>? = null
            private var name: JsonField<String>? = null
            private var planPhaseOrder: JsonField<Long>? = null
            private var priceType: JsonField<PriceType>? = null
            private var dimensionalPriceConfiguration:
                JsonField<DimensionalPriceConfigurationModel> =
                JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(cumulativeGroupedBulkPrice: CumulativeGroupedBulkPrice) = apply {
                id = cumulativeGroupedBulkPrice.id
                billableMetric = cumulativeGroupedBulkPrice.billableMetric
                billingCycleConfiguration = cumulativeGroupedBulkPrice.billingCycleConfiguration
                cadence = cumulativeGroupedBulkPrice.cadence
                conversionRate = cumulativeGroupedBulkPrice.conversionRate
                createdAt = cumulativeGroupedBulkPrice.createdAt
                creditAllocation = cumulativeGroupedBulkPrice.creditAllocation
                cumulativeGroupedBulkConfig = cumulativeGroupedBulkPrice.cumulativeGroupedBulkConfig
                currency = cumulativeGroupedBulkPrice.currency
                discount = cumulativeGroupedBulkPrice.discount
                externalPriceId = cumulativeGroupedBulkPrice.externalPriceId
                fixedPriceQuantity = cumulativeGroupedBulkPrice.fixedPriceQuantity
                invoicingCycleConfiguration = cumulativeGroupedBulkPrice.invoicingCycleConfiguration
                item = cumulativeGroupedBulkPrice.item
                maximum = cumulativeGroupedBulkPrice.maximum
                maximumAmount = cumulativeGroupedBulkPrice.maximumAmount
                metadata = cumulativeGroupedBulkPrice.metadata
                minimum = cumulativeGroupedBulkPrice.minimum
                minimumAmount = cumulativeGroupedBulkPrice.minimumAmount
                modelType = cumulativeGroupedBulkPrice.modelType
                name = cumulativeGroupedBulkPrice.name
                planPhaseOrder = cumulativeGroupedBulkPrice.planPhaseOrder
                priceType = cumulativeGroupedBulkPrice.priceType
                dimensionalPriceConfiguration =
                    cumulativeGroupedBulkPrice.dimensionalPriceConfiguration
                additionalProperties =
                    cumulativeGroupedBulkPrice.additionalProperties.toMutableMap()
            }

            fun id(id: String) = id(JsonField.of(id))

            fun id(id: JsonField<String>) = apply { this.id = id }

            fun billableMetric(billableMetric: BillableMetricTinyModel?) =
                billableMetric(JsonField.ofNullable(billableMetric))

            fun billableMetric(billableMetric: Optional<BillableMetricTinyModel>) =
                billableMetric(billableMetric.orElse(null))

            fun billableMetric(billableMetric: JsonField<BillableMetricTinyModel>) = apply {
                this.billableMetric = billableMetric
            }

            fun billingCycleConfiguration(
                billingCycleConfiguration: BillingCycleConfigurationModel
            ) = billingCycleConfiguration(JsonField.of(billingCycleConfiguration))

            fun billingCycleConfiguration(
                billingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.billingCycleConfiguration = billingCycleConfiguration }

            fun cadence(cadence: Cadence) = cadence(JsonField.of(cadence))

            fun cadence(cadence: JsonField<Cadence>) = apply { this.cadence = cadence }

            fun conversionRate(conversionRate: Double?) =
                conversionRate(JsonField.ofNullable(conversionRate))

            fun conversionRate(conversionRate: Double) = conversionRate(conversionRate as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun conversionRate(conversionRate: Optional<Double>) =
                conversionRate(conversionRate.orElse(null) as Double?)

            fun conversionRate(conversionRate: JsonField<Double>) = apply {
                this.conversionRate = conversionRate
            }

            fun createdAt(createdAt: OffsetDateTime) = createdAt(JsonField.of(createdAt))

            fun createdAt(createdAt: JsonField<OffsetDateTime>) = apply {
                this.createdAt = createdAt
            }

            fun creditAllocation(creditAllocation: AllocationModel?) =
                creditAllocation(JsonField.ofNullable(creditAllocation))

            fun creditAllocation(creditAllocation: Optional<AllocationModel>) =
                creditAllocation(creditAllocation.orElse(null))

            fun creditAllocation(creditAllocation: JsonField<AllocationModel>) = apply {
                this.creditAllocation = creditAllocation
            }

            fun cumulativeGroupedBulkConfig(
                cumulativeGroupedBulkConfig: CustomRatingFunctionConfigModel
            ) = cumulativeGroupedBulkConfig(JsonField.of(cumulativeGroupedBulkConfig))

            fun cumulativeGroupedBulkConfig(
                cumulativeGroupedBulkConfig: JsonField<CustomRatingFunctionConfigModel>
            ) = apply { this.cumulativeGroupedBulkConfig = cumulativeGroupedBulkConfig }

            fun currency(currency: String) = currency(JsonField.of(currency))

            fun currency(currency: JsonField<String>) = apply { this.currency = currency }

            fun discount(discount: Discount?) = discount(JsonField.ofNullable(discount))

            fun discount(discount: Optional<Discount>) = discount(discount.orElse(null))

            fun discount(discount: JsonField<Discount>) = apply { this.discount = discount }

            fun discount(percentage: PercentageDiscount) =
                discount(Discount.ofPercentage(percentage))

            fun discount(trial: TrialDiscount) = discount(Discount.ofTrial(trial))

            fun trialDiscount(appliesToPriceIds: List<String>) =
                discount(
                    TrialDiscount.builder()
                        .discountType(TrialDiscount.DiscountType.TRIAL)
                        .appliesToPriceIds(appliesToPriceIds)
                        .build()
                )

            fun discount(usage: Discount.UsageDiscount) = discount(Discount.ofUsage(usage))

            fun discount(amount: AmountDiscount) = discount(Discount.ofAmount(amount))

            fun externalPriceId(externalPriceId: String?) =
                externalPriceId(JsonField.ofNullable(externalPriceId))

            fun externalPriceId(externalPriceId: Optional<String>) =
                externalPriceId(externalPriceId.orElse(null))

            fun externalPriceId(externalPriceId: JsonField<String>) = apply {
                this.externalPriceId = externalPriceId
            }

            fun fixedPriceQuantity(fixedPriceQuantity: Double?) =
                fixedPriceQuantity(JsonField.ofNullable(fixedPriceQuantity))

            fun fixedPriceQuantity(fixedPriceQuantity: Double) =
                fixedPriceQuantity(fixedPriceQuantity as Double?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun fixedPriceQuantity(fixedPriceQuantity: Optional<Double>) =
                fixedPriceQuantity(fixedPriceQuantity.orElse(null) as Double?)

            fun fixedPriceQuantity(fixedPriceQuantity: JsonField<Double>) = apply {
                this.fixedPriceQuantity = fixedPriceQuantity
            }

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: BillingCycleConfigurationModel?
            ) = invoicingCycleConfiguration(JsonField.ofNullable(invoicingCycleConfiguration))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: Optional<BillingCycleConfigurationModel>
            ) = invoicingCycleConfiguration(invoicingCycleConfiguration.orElse(null))

            fun invoicingCycleConfiguration(
                invoicingCycleConfiguration: JsonField<BillingCycleConfigurationModel>
            ) = apply { this.invoicingCycleConfiguration = invoicingCycleConfiguration }

            fun item(item: ItemSlimModel) = item(JsonField.of(item))

            fun item(item: JsonField<ItemSlimModel>) = apply { this.item = item }

            fun maximum(maximum: MaximumModel?) = maximum(JsonField.ofNullable(maximum))

            fun maximum(maximum: Optional<MaximumModel>) = maximum(maximum.orElse(null))

            fun maximum(maximum: JsonField<MaximumModel>) = apply { this.maximum = maximum }

            fun maximumAmount(maximumAmount: String?) =
                maximumAmount(JsonField.ofNullable(maximumAmount))

            fun maximumAmount(maximumAmount: Optional<String>) =
                maximumAmount(maximumAmount.orElse(null))

            fun maximumAmount(maximumAmount: JsonField<String>) = apply {
                this.maximumAmount = maximumAmount
            }

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: Metadata) = metadata(JsonField.of(metadata))

            /**
             * User specified key-value pairs for the resource. If not present, this defaults to an
             * empty dictionary. Individual keys can be removed by setting the value to `null`, and
             * the entire metadata mapping can be cleared by setting `metadata` to `null`.
             */
            fun metadata(metadata: JsonField<Metadata>) = apply { this.metadata = metadata }

            fun minimum(minimum: MinimumModel?) = minimum(JsonField.ofNullable(minimum))

            fun minimum(minimum: Optional<MinimumModel>) = minimum(minimum.orElse(null))

            fun minimum(minimum: JsonField<MinimumModel>) = apply { this.minimum = minimum }

            fun minimumAmount(minimumAmount: String?) =
                minimumAmount(JsonField.ofNullable(minimumAmount))

            fun minimumAmount(minimumAmount: Optional<String>) =
                minimumAmount(minimumAmount.orElse(null))

            fun minimumAmount(minimumAmount: JsonField<String>) = apply {
                this.minimumAmount = minimumAmount
            }

            fun modelType(modelType: ModelType) = modelType(JsonField.of(modelType))

            fun modelType(modelType: JsonField<ModelType>) = apply { this.modelType = modelType }

            fun name(name: String) = name(JsonField.of(name))

            fun name(name: JsonField<String>) = apply { this.name = name }

            fun planPhaseOrder(planPhaseOrder: Long?) =
                planPhaseOrder(JsonField.ofNullable(planPhaseOrder))

            fun planPhaseOrder(planPhaseOrder: Long) = planPhaseOrder(planPhaseOrder as Long?)

            @Suppress("USELESS_CAST") // See https://youtrack.jetbrains.com/issue/KT-74228
            fun planPhaseOrder(planPhaseOrder: Optional<Long>) =
                planPhaseOrder(planPhaseOrder.orElse(null) as Long?)

            fun planPhaseOrder(planPhaseOrder: JsonField<Long>) = apply {
                this.planPhaseOrder = planPhaseOrder
            }

            fun priceType(priceType: PriceType) = priceType(JsonField.of(priceType))

            fun priceType(priceType: JsonField<PriceType>) = apply { this.priceType = priceType }

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: DimensionalPriceConfigurationModel?
            ) = dimensionalPriceConfiguration(JsonField.ofNullable(dimensionalPriceConfiguration))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: Optional<DimensionalPriceConfigurationModel>
            ) = dimensionalPriceConfiguration(dimensionalPriceConfiguration.orElse(null))

            fun dimensionalPriceConfiguration(
                dimensionalPriceConfiguration: JsonField<DimensionalPriceConfigurationModel>
            ) = apply { this.dimensionalPriceConfiguration = dimensionalPriceConfiguration }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            fun build(): CumulativeGroupedBulkPrice =
                CumulativeGroupedBulkPrice(
                    checkRequired("id", id),
                    checkRequired("billableMetric", billableMetric),
                    checkRequired("billingCycleConfiguration", billingCycleConfiguration),
                    checkRequired("cadence", cadence),
                    checkRequired("conversionRate", conversionRate),
                    checkRequired("createdAt", createdAt),
                    checkRequired("creditAllocation", creditAllocation),
                    checkRequired("cumulativeGroupedBulkConfig", cumulativeGroupedBulkConfig),
                    checkRequired("currency", currency),
                    checkRequired("discount", discount),
                    checkRequired("externalPriceId", externalPriceId),
                    checkRequired("fixedPriceQuantity", fixedPriceQuantity),
                    checkRequired("invoicingCycleConfiguration", invoicingCycleConfiguration),
                    checkRequired("item", item),
                    checkRequired("maximum", maximum),
                    checkRequired("maximumAmount", maximumAmount),
                    checkRequired("metadata", metadata),
                    checkRequired("minimum", minimum),
                    checkRequired("minimumAmount", minimumAmount),
                    checkRequired("modelType", modelType),
                    checkRequired("name", name),
                    checkRequired("planPhaseOrder", planPhaseOrder),
                    checkRequired("priceType", priceType),
                    dimensionalPriceConfiguration,
                    additionalProperties.toImmutable(),
                )
        }

        class Cadence @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val ONE_TIME = of("one_time")

                @JvmField val MONTHLY = of("monthly")

                @JvmField val QUARTERLY = of("quarterly")

                @JvmField val SEMI_ANNUAL = of("semi_annual")

                @JvmField val ANNUAL = of("annual")

                @JvmField val CUSTOM = of("custom")

                @JvmStatic fun of(value: String) = Cadence(JsonField.of(value))
            }

            /** An enum containing [Cadence]'s known values. */
            enum class Known {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
            }

            /**
             * An enum containing [Cadence]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [Cadence] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                ONE_TIME,
                MONTHLY,
                QUARTERLY,
                SEMI_ANNUAL,
                ANNUAL,
                CUSTOM,
                /**
                 * An enum member indicating that [Cadence] was instantiated with an unknown value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    ONE_TIME -> Value.ONE_TIME
                    MONTHLY -> Value.MONTHLY
                    QUARTERLY -> Value.QUARTERLY
                    SEMI_ANNUAL -> Value.SEMI_ANNUAL
                    ANNUAL -> Value.ANNUAL
                    CUSTOM -> Value.CUSTOM
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    ONE_TIME -> Known.ONE_TIME
                    MONTHLY -> Known.MONTHLY
                    QUARTERLY -> Known.QUARTERLY
                    SEMI_ANNUAL -> Known.SEMI_ANNUAL
                    ANNUAL -> Known.ANNUAL
                    CUSTOM -> Known.CUSTOM
                    else -> throw OrbInvalidDataException("Unknown Cadence: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Cadence && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        /**
         * User specified key-value pairs for the resource. If not present, this defaults to an
         * empty dictionary. Individual keys can be removed by setting the value to `null`, and the
         * entire metadata mapping can be cleared by setting `metadata` to `null`.
         */
        @NoAutoDetect
        class Metadata
        @JsonCreator
        private constructor(
            @JsonAnySetter
            private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap()
        ) {

            @JsonAnyGetter
            @ExcludeMissing
            fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

            private var validated: Boolean = false

            fun validate(): Metadata = apply {
                if (validated) {
                    return@apply
                }

                validated = true
            }

            fun toBuilder() = Builder().from(this)

            companion object {

                /** Returns a mutable builder for constructing an instance of [Metadata]. */
                @JvmStatic fun builder() = Builder()
            }

            /** A builder for [Metadata]. */
            class Builder internal constructor() {

                private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

                @JvmSynthetic
                internal fun from(metadata: Metadata) = apply {
                    additionalProperties = metadata.additionalProperties.toMutableMap()
                }

                fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                    this.additionalProperties.clear()
                    putAllAdditionalProperties(additionalProperties)
                }

                fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                    additionalProperties.put(key, value)
                }

                fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) =
                    apply {
                        this.additionalProperties.putAll(additionalProperties)
                    }

                fun removeAdditionalProperty(key: String) = apply {
                    additionalProperties.remove(key)
                }

                fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                    keys.forEach(::removeAdditionalProperty)
                }

                fun build(): Metadata = Metadata(additionalProperties.toImmutable())
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is Metadata && additionalProperties == other.additionalProperties /* spotless:on */
            }

            /* spotless:off */
            private val hashCode: Int by lazy { Objects.hash(additionalProperties) }
            /* spotless:on */

            override fun hashCode(): Int = hashCode

            override fun toString() = "Metadata{additionalProperties=$additionalProperties}"
        }

        class ModelType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val CUMULATIVE_GROUPED_BULK = of("cumulative_grouped_bulk")

                @JvmStatic fun of(value: String) = ModelType(JsonField.of(value))
            }

            /** An enum containing [ModelType]'s known values. */
            enum class Known {
                CUMULATIVE_GROUPED_BULK
            }

            /**
             * An enum containing [ModelType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [ModelType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                CUMULATIVE_GROUPED_BULK,
                /**
                 * An enum member indicating that [ModelType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    CUMULATIVE_GROUPED_BULK -> Value.CUMULATIVE_GROUPED_BULK
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    CUMULATIVE_GROUPED_BULK -> Known.CUMULATIVE_GROUPED_BULK
                    else -> throw OrbInvalidDataException("Unknown ModelType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is ModelType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        class PriceType @JsonCreator private constructor(private val value: JsonField<String>) :
            Enum {

            /**
             * Returns this class instance's raw value.
             *
             * This is usually only useful if this instance was deserialized from data that doesn't
             * match any known member, and you want to know that value. For example, if the SDK is
             * on an older version than the API, then the API may respond with new members that the
             * SDK is unaware of.
             */
            @com.fasterxml.jackson.annotation.JsonValue fun _value(): JsonField<String> = value

            companion object {

                @JvmField val USAGE_PRICE = of("usage_price")

                @JvmField val FIXED_PRICE = of("fixed_price")

                @JvmStatic fun of(value: String) = PriceType(JsonField.of(value))
            }

            /** An enum containing [PriceType]'s known values. */
            enum class Known {
                USAGE_PRICE,
                FIXED_PRICE,
            }

            /**
             * An enum containing [PriceType]'s known values, as well as an [_UNKNOWN] member.
             *
             * An instance of [PriceType] can contain an unknown value in a couple of cases:
             * - It was deserialized from data that doesn't match any known member. For example, if
             *   the SDK is on an older version than the API, then the API may respond with new
             *   members that the SDK is unaware of.
             * - It was constructed with an arbitrary value using the [of] method.
             */
            enum class Value {
                USAGE_PRICE,
                FIXED_PRICE,
                /**
                 * An enum member indicating that [PriceType] was instantiated with an unknown
                 * value.
                 */
                _UNKNOWN,
            }

            /**
             * Returns an enum member corresponding to this class instance's value, or
             * [Value._UNKNOWN] if the class was instantiated with an unknown value.
             *
             * Use the [known] method instead if you're certain the value is always known or if you
             * want to throw for the unknown case.
             */
            fun value(): Value =
                when (this) {
                    USAGE_PRICE -> Value.USAGE_PRICE
                    FIXED_PRICE -> Value.FIXED_PRICE
                    else -> Value._UNKNOWN
                }

            /**
             * Returns an enum member corresponding to this class instance's value.
             *
             * Use the [value] method instead if you're uncertain the value is always known and
             * don't want to throw for the unknown case.
             *
             * @throws OrbInvalidDataException if this class instance's value is a not a known
             *   member.
             */
            fun known(): Known =
                when (this) {
                    USAGE_PRICE -> Known.USAGE_PRICE
                    FIXED_PRICE -> Known.FIXED_PRICE
                    else -> throw OrbInvalidDataException("Unknown PriceType: $value")
                }

            /**
             * Returns this class instance's primitive wire representation.
             *
             * This differs from the [toString] method because that method is primarily for
             * debugging and generally doesn't throw.
             *
             * @throws OrbInvalidDataException if this class instance's value does not have the
             *   expected primitive type.
             */
            fun asString(): String =
                _value().asString().orElseThrow { OrbInvalidDataException("Value is not a String") }

            override fun equals(other: Any?): Boolean {
                if (this === other) {
                    return true
                }

                return /* spotless:off */ other is PriceType && value == other.value /* spotless:on */
            }

            override fun hashCode() = value.hashCode()

            override fun toString() = value.toString()
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is CumulativeGroupedBulkPrice && id == other.id && billableMetric == other.billableMetric && billingCycleConfiguration == other.billingCycleConfiguration && cadence == other.cadence && conversionRate == other.conversionRate && createdAt == other.createdAt && creditAllocation == other.creditAllocation && cumulativeGroupedBulkConfig == other.cumulativeGroupedBulkConfig && currency == other.currency && discount == other.discount && externalPriceId == other.externalPriceId && fixedPriceQuantity == other.fixedPriceQuantity && invoicingCycleConfiguration == other.invoicingCycleConfiguration && item == other.item && maximum == other.maximum && maximumAmount == other.maximumAmount && metadata == other.metadata && minimum == other.minimum && minimumAmount == other.minimumAmount && modelType == other.modelType && name == other.name && planPhaseOrder == other.planPhaseOrder && priceType == other.priceType && dimensionalPriceConfiguration == other.dimensionalPriceConfiguration && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(id, billableMetric, billingCycleConfiguration, cadence, conversionRate, createdAt, creditAllocation, cumulativeGroupedBulkConfig, currency, discount, externalPriceId, fixedPriceQuantity, invoicingCycleConfiguration, item, maximum, maximumAmount, metadata, minimum, minimumAmount, modelType, name, planPhaseOrder, priceType, dimensionalPriceConfiguration, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "CumulativeGroupedBulkPrice{id=$id, billableMetric=$billableMetric, billingCycleConfiguration=$billingCycleConfiguration, cadence=$cadence, conversionRate=$conversionRate, createdAt=$createdAt, creditAllocation=$creditAllocation, cumulativeGroupedBulkConfig=$cumulativeGroupedBulkConfig, currency=$currency, discount=$discount, externalPriceId=$externalPriceId, fixedPriceQuantity=$fixedPriceQuantity, invoicingCycleConfiguration=$invoicingCycleConfiguration, item=$item, maximum=$maximum, maximumAmount=$maximumAmount, metadata=$metadata, minimum=$minimum, minimumAmount=$minimumAmount, modelType=$modelType, name=$name, planPhaseOrder=$planPhaseOrder, priceType=$priceType, dimensionalPriceConfiguration=$dimensionalPriceConfiguration, additionalProperties=$additionalProperties}"
    }
}
