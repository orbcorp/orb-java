// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.annotation.JsonAnyGetter
import com.fasterxml.jackson.annotation.JsonAnySetter
import com.fasterxml.jackson.annotation.JsonCreator
import com.fasterxml.jackson.annotation.JsonProperty
import com.withorb.api.core.ExcludeMissing
import com.withorb.api.core.JsonField
import com.withorb.api.core.JsonMissing
import com.withorb.api.core.JsonValue
import com.withorb.api.core.NoAutoDetect
import com.withorb.api.core.Params
import com.withorb.api.core.checkKnown
import com.withorb.api.core.checkRequired
import com.withorb.api.core.http.Headers
import com.withorb.api.core.http.QueryParams
import com.withorb.api.core.immutableEmptyMap
import com.withorb.api.core.toImmutable
import com.withorb.api.errors.OrbInvalidDataException
import java.time.OffsetDateTime
import java.util.Objects
import java.util.Optional
import kotlin.jvm.optionals.getOrNull

/**
 * Orb's event ingestion model and API is designed around two core principles:
 * 1. **Data fidelity**: The accuracy of your billing model depends on a robust foundation of
 *    events. Orb's API protocol encourages usage patterns that ensure that your data is
 *    consistently complete and correct.
 * 2. **Fast integration**: Sending events into Orb requires no tedious setup steps or explicit
 *    field schema for your event shape, making it instant to start streaming in usage in real-time.
 *
 * ## Event shape
 *
 * Events are the starting point for all usage calculations in the system, and are simple at their
 * core:
 * ```ts
 * {
 *   // customer_id and external_customer_id are used to
 *   // attribute usage to a given Customer. Exactly one of these
 *   // should be specified in a given ingestion event.
 *
 *   // `customer_id` is the Orb generated identifier for the Customer,
 *   // which is returned from the Create customer API call.
 *   customer_id: string,
 *
 *   // external_customer_id is an alternate identifier which is associated
 *   // with a Customer at creation time. This is treated as an alias for
 *   // customer_id, and is usually set to an identifier native to your system.
 *   external_customer_id: string,
 *
 *   // A string name identifying the event, usually a usage
 *   // action. By convention, this should not contain any whitespace.
 *   event_name: string,
 *
 *   // An ISO 8601 format date with no timezone offset.
 *   // This should represent the time that usage occurred
 *   // and is important to attribute usage to a given
 *   // billing period. See the notes below on determining the timestamp.
 *   // e.g. 2020-12-09T16:09:53Z
 *   timestamp: string,
 *
 *   // A unique value, generated by the client, that is
 *   // used to de-duplicate events.
 *   // Exactly one event with a given
 *   // idempotency key will be ingested, which allows for
 *   // safe request retries.
 *   idempotency_key: string
 *
 *   // Optional custom metadata to attach to the event.
 *   // This might include a numeric value used for aggregation,
 *   // or a string/boolean value used for filtering.
 *   // The schema of this dictionary need not be pre-declared, and
 *   // properties can be added at any time.
 *   properties: {
 *     [key: string]?: string | number | boolean,
 *   },
 * }
 * ```
 *
 * ## Required fields
 *
 * Because events streamed to Orb are meant to be as flexible as possible, there are only a few
 * required fields in every event.
 * - We recommend that `idempotency_key` are unique strings that you generated with V4 UUIDs, but
 *   only require that they uniquely identify an event (i.e. don’t collide).
 * - The `timestamp` field in the event body will be used to determine which billable period a given
 *   event falls into. For example, with a monthly billing cycle starting from the first of
 *   December, Orb will calculate metrics based on events that fall into the range `12-01 00:00:00
 *   <= timestamp < 01-01 00:00:00`.
 *
 * ## Logging metadata
 *
 * Orb allows tagging events with metadata using a flexible properties dictionary. Since Orb does
 * not enforce a rigid schema for this field-set, key-value pairs can be added dynamically as your
 * events evolve.
 *
 * This dictionary can be helpful for a wide variety of use cases:
 * - Numeric properties on events like `compute_time_ms` can later be inputs to our flexible query
 *   engine to determine usage.
 * - Logging a region or cluster with each event can help you provide customers more granular
 *   visibility into their usage.
 * - If you are using matrix pricing and matching a matrix price key with a property, you should
 *   ensure the value for that property is sent as a string.
 *
 * We encourage logging this metadata with an eye towards future use cases to ensure full coverage
 * for historical data. The datatype of the value in the properties dictionary is important for
 * metric creation from an event source. Values that you wish to numerically aggregate should be of
 * numeric type in the event.
 *
 * ## Determining event timestamp
 *
 * For cases where usage is being reported in real time as it is occurring, timestamp should
 * correspond to the time that usage occurred.
 *
 * In cases where usage is reported in aggregate for a historical timeframe at a regular interval,
 * we recommend setting the event `timestamp` to the midpoint of the interval. As an example, if you
 * have an hourly reporter that sends data once an hour for the previous hour of usage, setting the
 * `timestamp` to the half-hour mark will ensure that the usage is counted within the correct
 * period.
 *
 * Note that other time-related fields (e.g. time elapsed) can be added to the properties dictionary
 * as necessary.
 *
 * In cases where usage is reported in aggregate for a historical timeframe, the timestamp must be
 * within the grace period set for your account. Events with `timestamp < current_time -
 * grace_period` will not be accepted as a valid event, and will throw validation errors. Enforcing
 * the grace period enables Orb to accurately map usage to the correct billing cycle and ensure that
 * all usage is billed for in the corresponding billing period.
 *
 * In general, Orb does not expect events with future dated timestamps. In cases where the timestamp
 * is at least 24 hours ahead of the current time, the event will not be accepted as a valid event,
 * and will throw validation errors.
 *
 * ## Event validation
 *
 * Orb’s validation ensures that you recognize errors in your events as quickly as possible, and the
 * API provides informative error messages to help you fix problems quickly.
 *
 * We validate the following:
 * - Exactly one of `customer_id` and `external_customer_id` should be specified.
 * - If the `customer_id` is specified, the customer in Orb must exist.
 * - If the `external_customer_id` is specified, the customer in Orb does not need to exist. Events
 *   will be attributed to any future customers with the `external_customer_id` on subscription
 *   creation.
 * - `timestamp` must conform to ISO 8601 and represent a timestamp at most 1 hour in the future.
 *   This timestamp should be sent in UTC timezone (no timezone offset).
 *
 * ## Idempotency and retry semantics
 *
 * Orb's idempotency guarantees allow you to implement safe retry logic in the event of network or
 * machine failures, ensuring data fidelity. Each event in the request payload is associated with an
 * idempotency key, and Orb guarantees that a single idempotency key will be successfully ingested
 * at most once. Note that when Orb encounters events with duplicate idempotency keys and differing
 * event bodies in a batch of events, the entire batch will be rejected.
 * - Successful responses return a 200 HTTP status code. The response contains information about
 *   previously processed events.
 * - Requests that return a `4xx` HTTP status code indicate a payload error and contain at least one
 *   event with a validation failure. An event with a validation failure can be re-sent to the
 *   ingestion endpoint (after the payload is fixed) with the original idempotency key since that
 *   key is not marked as processed.
 * - Requests that return a `5xx` HTTP status code indicate a server-side failure. These requests
 *   should be retried in their entirety.
 *
 * ## API usage and limits
 *
 * The ingestion API is designed made for real-time streaming ingestion and architected for high
 * throughput. Even if events are later deemed unnecessary or filtered out, we encourage you to log
 * them to Orb if they may be relevant to billing calculations in the future.
 *
 * To take advantage of the real-time features of the Orb platform and avoid any chance of dropped
 * events by producers, we recommend reporting events to Orb frequently. Optionally, events can also
 * be briefly aggregated at the source, as this API accepts an array of event bodies.
 *
 * Orb does not currently enforce a hard rate-limit for API usage or a maximum request payload size,
 * but please give us a heads up if you’re changing either of these factors by an order of magnitude
 * from initial setup.
 *
 * ## Testing in debug mode
 *
 * The ingestion API supports a debug mode, which returns additional verbose output to indicate
 * which event idempotency keys were newly ingested or duplicates from previous requests. To enable
 * this mode, mark `debug=true` as a query parameter.
 *
 * If `debug=true` is not specified, the response will only contain `validation_failed`. Orb will
 * still honor the idempotency guarantees set
 * [here](/events-and-metrics/event-ingestion#event-volume-and-concurrency) in all cases.
 *
 * We strongly recommend that you only use debug mode as part of testing your initial Orb
 * integration. Once you're ready to switch to production, disable debug mode to take advantage of
 * improved performance and maximal throughput.
 *
 * #### Example: ingestion response with `debug=true`
 *
 * ```json
 * {
 *   "debug": {
 *     "duplicate": [],
 *     "ingested": ["B7E83HDMfJPAunXW", "SJs5DQJ3TnwSqEZE", "8SivfDsNKwCeAXim"]
 *   },
 *   "validation_failed": []
 * }
 * ```
 *
 * #### Example: ingestion response with `debug=false`
 *
 * ```json
 * {
 *   "validation_failed": []
 * }
 * ```
 */
class EventIngestParams
private constructor(
    private val backfillId: String?,
    private val debug: Boolean?,
    private val body: Body,
    private val additionalHeaders: Headers,
    private val additionalQueryParams: QueryParams,
) : Params {

    /**
     * If this ingestion request is part of a backfill, this parameter ties the ingested events to
     * the backfill
     */
    fun backfillId(): Optional<String> = Optional.ofNullable(backfillId)

    /** Flag to enable additional debug information in the endpoint response */
    fun debug(): Optional<Boolean> = Optional.ofNullable(debug)

    /**
     * @throws OrbInvalidDataException if the JSON field has an unexpected type or is unexpectedly
     *   missing or null (e.g. if the server responded with an unexpected value).
     */
    fun events(): List<Event> = body.events()

    /**
     * Returns the raw JSON value of [events].
     *
     * Unlike [events], this method doesn't throw if the JSON field has an unexpected type.
     */
    fun _events(): JsonField<List<Event>> = body._events()

    fun _additionalBodyProperties(): Map<String, JsonValue> = body._additionalProperties()

    fun _additionalHeaders(): Headers = additionalHeaders

    fun _additionalQueryParams(): QueryParams = additionalQueryParams

    @JvmSynthetic internal fun _body(): Body = body

    override fun _headers(): Headers = additionalHeaders

    override fun _queryParams(): QueryParams =
        QueryParams.builder()
            .apply {
                backfillId?.let { put("backfill_id", it) }
                debug?.let { put("debug", it.toString()) }
                putAll(additionalQueryParams)
            }
            .build()

    @NoAutoDetect
    class Body
    @JsonCreator
    private constructor(
        @JsonProperty("events")
        @ExcludeMissing
        private val events: JsonField<List<Event>> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun events(): List<Event> = events.getRequired("events")

        /**
         * Returns the raw JSON value of [events].
         *
         * Unlike [events], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("events") @ExcludeMissing fun _events(): JsonField<List<Event>> = events

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): Body = apply {
            if (validated) {
                return@apply
            }

            events().forEach { it.validate() }
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Body].
             *
             * The following fields are required:
             * ```java
             * .events()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [Body]. */
        class Builder internal constructor() {

            private var events: JsonField<MutableList<Event>>? = null
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(body: Body) = apply {
                events = body.events.map { it.toMutableList() }
                additionalProperties = body.additionalProperties.toMutableMap()
            }

            fun events(events: List<Event>) = events(JsonField.of(events))

            /**
             * Sets [Builder.events] to an arbitrary JSON value.
             *
             * You should usually call [Builder.events] with a well-typed `List<Event>` value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun events(events: JsonField<List<Event>>) = apply {
                this.events = events.map { it.toMutableList() }
            }

            /**
             * Adds a single [Event] to [events].
             *
             * @throws IllegalStateException if the field was previously set to a non-list.
             */
            fun addEvent(event: Event) = apply {
                events =
                    (events ?: JsonField.of(mutableListOf())).also {
                        checkKnown("events", it).add(event)
                    }
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Body].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .events()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Body =
                Body(
                    checkRequired("events", events).map { it.toImmutable() },
                    additionalProperties.toImmutable(),
                )
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Body && events == other.events && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(events, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() = "Body{events=$events, additionalProperties=$additionalProperties}"
    }

    fun toBuilder() = Builder().from(this)

    companion object {

        /**
         * Returns a mutable builder for constructing an instance of [EventIngestParams].
         *
         * The following fields are required:
         * ```java
         * .events()
         * ```
         */
        @JvmStatic fun builder() = Builder()
    }

    /** A builder for [EventIngestParams]. */
    @NoAutoDetect
    class Builder internal constructor() {

        private var backfillId: String? = null
        private var debug: Boolean? = null
        private var body: Body.Builder = Body.builder()
        private var additionalHeaders: Headers.Builder = Headers.builder()
        private var additionalQueryParams: QueryParams.Builder = QueryParams.builder()

        @JvmSynthetic
        internal fun from(eventIngestParams: EventIngestParams) = apply {
            backfillId = eventIngestParams.backfillId
            debug = eventIngestParams.debug
            body = eventIngestParams.body.toBuilder()
            additionalHeaders = eventIngestParams.additionalHeaders.toBuilder()
            additionalQueryParams = eventIngestParams.additionalQueryParams.toBuilder()
        }

        /**
         * If this ingestion request is part of a backfill, this parameter ties the ingested events
         * to the backfill
         */
        fun backfillId(backfillId: String?) = apply { this.backfillId = backfillId }

        /** Alias for calling [Builder.backfillId] with `backfillId.orElse(null)`. */
        fun backfillId(backfillId: Optional<String>) = backfillId(backfillId.getOrNull())

        /** Flag to enable additional debug information in the endpoint response */
        fun debug(debug: Boolean?) = apply { this.debug = debug }

        /**
         * Alias for [Builder.debug].
         *
         * This unboxed primitive overload exists for backwards compatibility.
         */
        fun debug(debug: Boolean) = debug(debug as Boolean?)

        /** Alias for calling [Builder.debug] with `debug.orElse(null)`. */
        fun debug(debug: Optional<Boolean>) = debug(debug.getOrNull())

        fun events(events: List<Event>) = apply { body.events(events) }

        /**
         * Sets [Builder.events] to an arbitrary JSON value.
         *
         * You should usually call [Builder.events] with a well-typed `List<Event>` value instead.
         * This method is primarily for setting the field to an undocumented or not yet supported
         * value.
         */
        fun events(events: JsonField<List<Event>>) = apply { body.events(events) }

        /**
         * Adds a single [Event] to [events].
         *
         * @throws IllegalStateException if the field was previously set to a non-list.
         */
        fun addEvent(event: Event) = apply { body.addEvent(event) }

        fun additionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) = apply {
            body.additionalProperties(additionalBodyProperties)
        }

        fun putAdditionalBodyProperty(key: String, value: JsonValue) = apply {
            body.putAdditionalProperty(key, value)
        }

        fun putAllAdditionalBodyProperties(additionalBodyProperties: Map<String, JsonValue>) =
            apply {
                body.putAllAdditionalProperties(additionalBodyProperties)
            }

        fun removeAdditionalBodyProperty(key: String) = apply { body.removeAdditionalProperty(key) }

        fun removeAllAdditionalBodyProperties(keys: Set<String>) = apply {
            body.removeAllAdditionalProperties(keys)
        }

        fun additionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun additionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.clear()
            putAllAdditionalHeaders(additionalHeaders)
        }

        fun putAdditionalHeader(name: String, value: String) = apply {
            additionalHeaders.put(name, value)
        }

        fun putAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.put(name, values)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.putAll(additionalHeaders)
        }

        fun putAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.putAll(additionalHeaders)
        }

        fun replaceAdditionalHeaders(name: String, value: String) = apply {
            additionalHeaders.replace(name, value)
        }

        fun replaceAdditionalHeaders(name: String, values: Iterable<String>) = apply {
            additionalHeaders.replace(name, values)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Headers) = apply {
            this.additionalHeaders.replaceAll(additionalHeaders)
        }

        fun replaceAllAdditionalHeaders(additionalHeaders: Map<String, Iterable<String>>) = apply {
            this.additionalHeaders.replaceAll(additionalHeaders)
        }

        fun removeAdditionalHeaders(name: String) = apply { additionalHeaders.remove(name) }

        fun removeAllAdditionalHeaders(names: Set<String>) = apply {
            additionalHeaders.removeAll(names)
        }

        fun additionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun additionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) = apply {
            this.additionalQueryParams.clear()
            putAllAdditionalQueryParams(additionalQueryParams)
        }

        fun putAdditionalQueryParam(key: String, value: String) = apply {
            additionalQueryParams.put(key, value)
        }

        fun putAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.put(key, values)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.putAll(additionalQueryParams)
        }

        fun putAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                this.additionalQueryParams.putAll(additionalQueryParams)
            }

        fun replaceAdditionalQueryParams(key: String, value: String) = apply {
            additionalQueryParams.replace(key, value)
        }

        fun replaceAdditionalQueryParams(key: String, values: Iterable<String>) = apply {
            additionalQueryParams.replace(key, values)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: QueryParams) = apply {
            this.additionalQueryParams.replaceAll(additionalQueryParams)
        }

        fun replaceAllAdditionalQueryParams(additionalQueryParams: Map<String, Iterable<String>>) =
            apply {
                this.additionalQueryParams.replaceAll(additionalQueryParams)
            }

        fun removeAdditionalQueryParams(key: String) = apply { additionalQueryParams.remove(key) }

        fun removeAllAdditionalQueryParams(keys: Set<String>) = apply {
            additionalQueryParams.removeAll(keys)
        }

        /**
         * Returns an immutable instance of [EventIngestParams].
         *
         * Further updates to this [Builder] will not mutate the returned instance.
         *
         * The following fields are required:
         * ```java
         * .events()
         * ```
         *
         * @throws IllegalStateException if any required field is unset.
         */
        fun build(): EventIngestParams =
            EventIngestParams(
                backfillId,
                debug,
                body.build(),
                additionalHeaders.build(),
                additionalQueryParams.build(),
            )
    }

    @NoAutoDetect
    class Event
    @JsonCreator
    private constructor(
        @JsonProperty("event_name")
        @ExcludeMissing
        private val eventName: JsonField<String> = JsonMissing.of(),
        @JsonProperty("idempotency_key")
        @ExcludeMissing
        private val idempotencyKey: JsonField<String> = JsonMissing.of(),
        @JsonProperty("properties")
        @ExcludeMissing
        private val properties: JsonValue = JsonMissing.of(),
        @JsonProperty("timestamp")
        @ExcludeMissing
        private val timestamp: JsonField<OffsetDateTime> = JsonMissing.of(),
        @JsonProperty("customer_id")
        @ExcludeMissing
        private val customerId: JsonField<String> = JsonMissing.of(),
        @JsonProperty("external_customer_id")
        @ExcludeMissing
        private val externalCustomerId: JsonField<String> = JsonMissing.of(),
        @JsonAnySetter
        private val additionalProperties: Map<String, JsonValue> = immutableEmptyMap(),
    ) {

        /**
         * A name to meaningfully identify the action or event type.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun eventName(): String = eventName.getRequired("event_name")

        /**
         * A unique value, generated by the client, that is used to de-duplicate events. Exactly one
         * event with a given idempotency key will be ingested, which allows for safe request
         * retries.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun idempotencyKey(): String = idempotencyKey.getRequired("idempotency_key")

        /**
         * A dictionary of custom properties. Values in this dictionary must be numeric, boolean, or
         * strings. Nested dictionaries are disallowed.
         */
        @JsonProperty("properties") @ExcludeMissing fun _properties(): JsonValue = properties

        /**
         * An ISO 8601 format date with no timezone offset (i.e. UTC). This should represent the
         * time that usage was recorded, and is particularly important to attribute usage to a given
         * billing period.
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type or is
         *   unexpectedly missing or null (e.g. if the server responded with an unexpected value).
         */
        fun timestamp(): OffsetDateTime = timestamp.getRequired("timestamp")

        /**
         * The Orb Customer identifier
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun customerId(): Optional<String> =
            Optional.ofNullable(customerId.getNullable("customer_id"))

        /**
         * An alias for the Orb customer, whose mapping is specified when creating the customer
         *
         * @throws OrbInvalidDataException if the JSON field has an unexpected type (e.g. if the
         *   server responded with an unexpected value).
         */
        fun externalCustomerId(): Optional<String> =
            Optional.ofNullable(externalCustomerId.getNullable("external_customer_id"))

        /**
         * Returns the raw JSON value of [eventName].
         *
         * Unlike [eventName], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("event_name") @ExcludeMissing fun _eventName(): JsonField<String> = eventName

        /**
         * Returns the raw JSON value of [idempotencyKey].
         *
         * Unlike [idempotencyKey], this method doesn't throw if the JSON field has an unexpected
         * type.
         */
        @JsonProperty("idempotency_key")
        @ExcludeMissing
        fun _idempotencyKey(): JsonField<String> = idempotencyKey

        /**
         * Returns the raw JSON value of [timestamp].
         *
         * Unlike [timestamp], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("timestamp")
        @ExcludeMissing
        fun _timestamp(): JsonField<OffsetDateTime> = timestamp

        /**
         * Returns the raw JSON value of [customerId].
         *
         * Unlike [customerId], this method doesn't throw if the JSON field has an unexpected type.
         */
        @JsonProperty("customer_id")
        @ExcludeMissing
        fun _customerId(): JsonField<String> = customerId

        /**
         * Returns the raw JSON value of [externalCustomerId].
         *
         * Unlike [externalCustomerId], this method doesn't throw if the JSON field has an
         * unexpected type.
         */
        @JsonProperty("external_customer_id")
        @ExcludeMissing
        fun _externalCustomerId(): JsonField<String> = externalCustomerId

        @JsonAnyGetter
        @ExcludeMissing
        fun _additionalProperties(): Map<String, JsonValue> = additionalProperties

        private var validated: Boolean = false

        fun validate(): Event = apply {
            if (validated) {
                return@apply
            }

            eventName()
            idempotencyKey()
            timestamp()
            customerId()
            externalCustomerId()
            validated = true
        }

        fun toBuilder() = Builder().from(this)

        companion object {

            /**
             * Returns a mutable builder for constructing an instance of [Event].
             *
             * The following fields are required:
             * ```java
             * .eventName()
             * .idempotencyKey()
             * .properties()
             * .timestamp()
             * ```
             */
            @JvmStatic fun builder() = Builder()
        }

        /** A builder for [Event]. */
        class Builder internal constructor() {

            private var eventName: JsonField<String>? = null
            private var idempotencyKey: JsonField<String>? = null
            private var properties: JsonValue? = null
            private var timestamp: JsonField<OffsetDateTime>? = null
            private var customerId: JsonField<String> = JsonMissing.of()
            private var externalCustomerId: JsonField<String> = JsonMissing.of()
            private var additionalProperties: MutableMap<String, JsonValue> = mutableMapOf()

            @JvmSynthetic
            internal fun from(event: Event) = apply {
                eventName = event.eventName
                idempotencyKey = event.idempotencyKey
                properties = event.properties
                timestamp = event.timestamp
                customerId = event.customerId
                externalCustomerId = event.externalCustomerId
                additionalProperties = event.additionalProperties.toMutableMap()
            }

            /** A name to meaningfully identify the action or event type. */
            fun eventName(eventName: String) = eventName(JsonField.of(eventName))

            /**
             * Sets [Builder.eventName] to an arbitrary JSON value.
             *
             * You should usually call [Builder.eventName] with a well-typed [String] value instead.
             * This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun eventName(eventName: JsonField<String>) = apply { this.eventName = eventName }

            /**
             * A unique value, generated by the client, that is used to de-duplicate events. Exactly
             * one event with a given idempotency key will be ingested, which allows for safe
             * request retries.
             */
            fun idempotencyKey(idempotencyKey: String) =
                idempotencyKey(JsonField.of(idempotencyKey))

            /**
             * Sets [Builder.idempotencyKey] to an arbitrary JSON value.
             *
             * You should usually call [Builder.idempotencyKey] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun idempotencyKey(idempotencyKey: JsonField<String>) = apply {
                this.idempotencyKey = idempotencyKey
            }

            /**
             * A dictionary of custom properties. Values in this dictionary must be numeric,
             * boolean, or strings. Nested dictionaries are disallowed.
             */
            fun properties(properties: JsonValue) = apply { this.properties = properties }

            /**
             * An ISO 8601 format date with no timezone offset (i.e. UTC). This should represent the
             * time that usage was recorded, and is particularly important to attribute usage to a
             * given billing period.
             */
            fun timestamp(timestamp: OffsetDateTime) = timestamp(JsonField.of(timestamp))

            /**
             * Sets [Builder.timestamp] to an arbitrary JSON value.
             *
             * You should usually call [Builder.timestamp] with a well-typed [OffsetDateTime] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun timestamp(timestamp: JsonField<OffsetDateTime>) = apply {
                this.timestamp = timestamp
            }

            /** The Orb Customer identifier */
            fun customerId(customerId: String?) = customerId(JsonField.ofNullable(customerId))

            /** Alias for calling [Builder.customerId] with `customerId.orElse(null)`. */
            fun customerId(customerId: Optional<String>) = customerId(customerId.getOrNull())

            /**
             * Sets [Builder.customerId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.customerId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun customerId(customerId: JsonField<String>) = apply { this.customerId = customerId }

            /**
             * An alias for the Orb customer, whose mapping is specified when creating the customer
             */
            fun externalCustomerId(externalCustomerId: String?) =
                externalCustomerId(JsonField.ofNullable(externalCustomerId))

            /**
             * Alias for calling [Builder.externalCustomerId] with
             * `externalCustomerId.orElse(null)`.
             */
            fun externalCustomerId(externalCustomerId: Optional<String>) =
                externalCustomerId(externalCustomerId.getOrNull())

            /**
             * Sets [Builder.externalCustomerId] to an arbitrary JSON value.
             *
             * You should usually call [Builder.externalCustomerId] with a well-typed [String] value
             * instead. This method is primarily for setting the field to an undocumented or not yet
             * supported value.
             */
            fun externalCustomerId(externalCustomerId: JsonField<String>) = apply {
                this.externalCustomerId = externalCustomerId
            }

            fun additionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.clear()
                putAllAdditionalProperties(additionalProperties)
            }

            fun putAdditionalProperty(key: String, value: JsonValue) = apply {
                additionalProperties.put(key, value)
            }

            fun putAllAdditionalProperties(additionalProperties: Map<String, JsonValue>) = apply {
                this.additionalProperties.putAll(additionalProperties)
            }

            fun removeAdditionalProperty(key: String) = apply { additionalProperties.remove(key) }

            fun removeAllAdditionalProperties(keys: Set<String>) = apply {
                keys.forEach(::removeAdditionalProperty)
            }

            /**
             * Returns an immutable instance of [Event].
             *
             * Further updates to this [Builder] will not mutate the returned instance.
             *
             * The following fields are required:
             * ```java
             * .eventName()
             * .idempotencyKey()
             * .properties()
             * .timestamp()
             * ```
             *
             * @throws IllegalStateException if any required field is unset.
             */
            fun build(): Event =
                Event(
                    checkRequired("eventName", eventName),
                    checkRequired("idempotencyKey", idempotencyKey),
                    checkRequired("properties", properties),
                    checkRequired("timestamp", timestamp),
                    customerId,
                    externalCustomerId,
                    additionalProperties.toImmutable(),
                )
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) {
                return true
            }

            return /* spotless:off */ other is Event && eventName == other.eventName && idempotencyKey == other.idempotencyKey && properties == other.properties && timestamp == other.timestamp && customerId == other.customerId && externalCustomerId == other.externalCustomerId && additionalProperties == other.additionalProperties /* spotless:on */
        }

        /* spotless:off */
        private val hashCode: Int by lazy { Objects.hash(eventName, idempotencyKey, properties, timestamp, customerId, externalCustomerId, additionalProperties) }
        /* spotless:on */

        override fun hashCode(): Int = hashCode

        override fun toString() =
            "Event{eventName=$eventName, idempotencyKey=$idempotencyKey, properties=$properties, timestamp=$timestamp, customerId=$customerId, externalCustomerId=$externalCustomerId, additionalProperties=$additionalProperties}"
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }

        return /* spotless:off */ other is EventIngestParams && backfillId == other.backfillId && debug == other.debug && body == other.body && additionalHeaders == other.additionalHeaders && additionalQueryParams == other.additionalQueryParams /* spotless:on */
    }

    override fun hashCode(): Int = /* spotless:off */ Objects.hash(backfillId, debug, body, additionalHeaders, additionalQueryParams) /* spotless:on */

    override fun toString() =
        "EventIngestParams{backfillId=$backfillId, debug=$debug, body=$body, additionalHeaders=$additionalHeaders, additionalQueryParams=$additionalQueryParams}"
}
