// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.withorb.api.core.JsonValue
import com.withorb.api.core.jsonMapper
import com.withorb.api.errors.OrbInvalidDataException
import java.time.OffsetDateTime
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.EnumSource

internal class PriceTest {

    @Test
    fun ofUnit() {
        val unit =
            Price.Unit.builder()
                .id("id")
                .billableMetric(Price.Unit.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.Unit.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.Unit.BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.Unit.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.Unit.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.Unit.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.Unit.CreditAllocation.CustomExpiration.DurationUnit.DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.Unit.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.Unit.InvoicingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(Price.Unit.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.Unit.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.Unit.Maximum.Filter.builder()
                                .field(Price.Unit.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.Unit.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.Unit.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.Unit.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.Unit.Minimum.Filter.builder()
                                .field(Price.Unit.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.Unit.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.Unit.PriceType.USAGE_PRICE)
                .unitConfig(Price.Unit.UnitConfig.builder().unitAmount("unit_amount").build())
                .dimensionalPriceConfiguration(
                    Price.Unit.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofUnit(unit)

        assertThat(price.unit()).contains(unit)
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofUnitRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofUnit(
                Price.Unit.builder()
                    .id("id")
                    .billableMetric(Price.Unit.BillableMetric.builder().id("id").build())
                    .billingCycleConfiguration(
                        Price.Unit.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(Price.Unit.BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.Unit.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.Unit.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.Unit.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.Unit.CreditAllocation.CustomExpiration.DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.Unit.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(Price.Unit.InvoicingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(Price.Unit.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.Unit.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.Unit.Maximum.Filter.builder()
                                    .field(Price.Unit.Maximum.Filter.Field.PRICE_ID)
                                    .operator(Price.Unit.Maximum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.Unit.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.Unit.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.Unit.Minimum.Filter.builder()
                                    .field(Price.Unit.Minimum.Filter.Field.PRICE_ID)
                                    .operator(Price.Unit.Minimum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.Unit.PriceType.USAGE_PRICE)
                    .unitConfig(Price.Unit.UnitConfig.builder().unitAmount("unit_amount").build())
                    .dimensionalPriceConfiguration(
                        Price.Unit.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofPackage() {
        val package_ =
            Price.Package.builder()
                .id("id")
                .billableMetric(Price.Package.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.Package.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.Package.BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.Package.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.Package.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.Package.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.Package.CreditAllocation.CustomExpiration.DurationUnit.DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.Package.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.Package.InvoicingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(Price.Package.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.Package.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.Package.Maximum.Filter.builder()
                                .field(Price.Package.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.Package.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.Package.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.Package.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.Package.Minimum.Filter.builder()
                                .field(Price.Package.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.Package.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .packageConfig(
                    Price.Package.PackageConfig.builder()
                        .packageAmount("package_amount")
                        .packageSize(0L)
                        .build()
                )
                .planPhaseOrder(0L)
                .priceType(Price.Package.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.Package.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofPackage(package_)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).contains(package_)
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofPackageRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofPackage(
                Price.Package.builder()
                    .id("id")
                    .billableMetric(Price.Package.BillableMetric.builder().id("id").build())
                    .billingCycleConfiguration(
                        Price.Package.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(Price.Package.BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.Package.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.Package.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.Package.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.Package.CreditAllocation.CustomExpiration.DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.Package.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.Package.InvoicingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .item(Price.Package.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.Package.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.Package.Maximum.Filter.builder()
                                    .field(Price.Package.Maximum.Filter.Field.PRICE_ID)
                                    .operator(Price.Package.Maximum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.Package.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.Package.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.Package.Minimum.Filter.builder()
                                    .field(Price.Package.Minimum.Filter.Field.PRICE_ID)
                                    .operator(Price.Package.Minimum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .packageConfig(
                        Price.Package.PackageConfig.builder()
                            .packageAmount("package_amount")
                            .packageSize(0L)
                            .build()
                    )
                    .planPhaseOrder(0L)
                    .priceType(Price.Package.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.Package.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofMatrix() {
        val matrix =
            Price.Matrix.builder()
                .id("id")
                .billableMetric(Price.Matrix.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.Matrix.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.Matrix.BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.Matrix.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.Matrix.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.Matrix.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.Matrix.CreditAllocation.CustomExpiration.DurationUnit.DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.Matrix.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.Matrix.InvoicingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(Price.Matrix.Item.builder().id("id").name("name").build())
                .matrixConfig(
                    Price.Matrix.MatrixConfig.builder()
                        .defaultUnitAmount("default_unit_amount")
                        .addDimension("string")
                        .addMatrixValue(
                            Price.Matrix.MatrixConfig.MatrixValue.builder()
                                .addDimensionValue("string")
                                .unitAmount("unit_amount")
                                .build()
                        )
                        .build()
                )
                .maximum(
                    Price.Matrix.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.Matrix.Maximum.Filter.builder()
                                .field(Price.Matrix.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.Matrix.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.Matrix.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.Matrix.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.Matrix.Minimum.Filter.builder()
                                .field(Price.Matrix.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.Matrix.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.Matrix.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.Matrix.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofMatrix(matrix)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).contains(matrix)
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofMatrixRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofMatrix(
                Price.Matrix.builder()
                    .id("id")
                    .billableMetric(Price.Matrix.BillableMetric.builder().id("id").build())
                    .billingCycleConfiguration(
                        Price.Matrix.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(Price.Matrix.BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.Matrix.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.Matrix.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.Matrix.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.Matrix.CreditAllocation.CustomExpiration.DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.Matrix.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(Price.Matrix.InvoicingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(Price.Matrix.Item.builder().id("id").name("name").build())
                    .matrixConfig(
                        Price.Matrix.MatrixConfig.builder()
                            .defaultUnitAmount("default_unit_amount")
                            .addDimension("string")
                            .addMatrixValue(
                                Price.Matrix.MatrixConfig.MatrixValue.builder()
                                    .addDimensionValue("string")
                                    .unitAmount("unit_amount")
                                    .build()
                            )
                            .build()
                    )
                    .maximum(
                        Price.Matrix.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.Matrix.Maximum.Filter.builder()
                                    .field(Price.Matrix.Maximum.Filter.Field.PRICE_ID)
                                    .operator(Price.Matrix.Maximum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.Matrix.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.Matrix.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.Matrix.Minimum.Filter.builder()
                                    .field(Price.Matrix.Minimum.Filter.Field.PRICE_ID)
                                    .operator(Price.Matrix.Minimum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.Matrix.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.Matrix.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofTiered() {
        val tiered =
            Price.Tiered.builder()
                .id("id")
                .billableMetric(Price.Tiered.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.Tiered.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.Tiered.BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.Tiered.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.Tiered.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.Tiered.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.Tiered.CreditAllocation.CustomExpiration.DurationUnit.DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.Tiered.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.Tiered.InvoicingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(Price.Tiered.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.Tiered.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.Tiered.Maximum.Filter.builder()
                                .field(Price.Tiered.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.Tiered.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.Tiered.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.Tiered.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.Tiered.Minimum.Filter.builder()
                                .field(Price.Tiered.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.Tiered.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.Tiered.PriceType.USAGE_PRICE)
                .tieredConfig(
                    Price.Tiered.TieredConfig.builder()
                        .addTier(
                            Price.Tiered.TieredConfig.Tier.builder()
                                .firstUnit(0.0)
                                .unitAmount("unit_amount")
                                .lastUnit(0.0)
                                .build()
                        )
                        .build()
                )
                .dimensionalPriceConfiguration(
                    Price.Tiered.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofTiered(tiered)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).contains(tiered)
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofTieredRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofTiered(
                Price.Tiered.builder()
                    .id("id")
                    .billableMetric(Price.Tiered.BillableMetric.builder().id("id").build())
                    .billingCycleConfiguration(
                        Price.Tiered.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(Price.Tiered.BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.Tiered.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.Tiered.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.Tiered.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.Tiered.CreditAllocation.CustomExpiration.DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.Tiered.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(Price.Tiered.InvoicingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(Price.Tiered.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.Tiered.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.Tiered.Maximum.Filter.builder()
                                    .field(Price.Tiered.Maximum.Filter.Field.PRICE_ID)
                                    .operator(Price.Tiered.Maximum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.Tiered.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.Tiered.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.Tiered.Minimum.Filter.builder()
                                    .field(Price.Tiered.Minimum.Filter.Field.PRICE_ID)
                                    .operator(Price.Tiered.Minimum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.Tiered.PriceType.USAGE_PRICE)
                    .tieredConfig(
                        Price.Tiered.TieredConfig.builder()
                            .addTier(
                                Price.Tiered.TieredConfig.Tier.builder()
                                    .firstUnit(0.0)
                                    .unitAmount("unit_amount")
                                    .lastUnit(0.0)
                                    .build()
                            )
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        Price.Tiered.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofTieredBps() {
        val tieredBps =
            Price.TieredBps.builder()
                .id("id")
                .billableMetric(Price.TieredBps.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.TieredBps.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.TieredBps.BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.TieredBps.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.TieredBps.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.TieredBps.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.TieredBps.CreditAllocation.CustomExpiration.DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.TieredBps.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.TieredBps.InvoicingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(Price.TieredBps.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.TieredBps.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.TieredBps.Maximum.Filter.builder()
                                .field(Price.TieredBps.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.TieredBps.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.TieredBps.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.TieredBps.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.TieredBps.Minimum.Filter.builder()
                                .field(Price.TieredBps.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.TieredBps.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.TieredBps.PriceType.USAGE_PRICE)
                .tieredBpsConfig(
                    Price.TieredBps.TieredBpsConfig.builder()
                        .addTier(
                            Price.TieredBps.TieredBpsConfig.Tier.builder()
                                .bps(0.0)
                                .minimumAmount("minimum_amount")
                                .maximumAmount("maximum_amount")
                                .perUnitMaximum("per_unit_maximum")
                                .build()
                        )
                        .build()
                )
                .dimensionalPriceConfiguration(
                    Price.TieredBps.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofTieredBps(tieredBps)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).contains(tieredBps)
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofTieredBpsRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofTieredBps(
                Price.TieredBps.builder()
                    .id("id")
                    .billableMetric(Price.TieredBps.BillableMetric.builder().id("id").build())
                    .billingCycleConfiguration(
                        Price.TieredBps.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.TieredBps.BillingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .cadence(Price.TieredBps.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.TieredBps.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.TieredBps.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.TieredBps.CreditAllocation.CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.TieredBps.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.TieredBps.InvoicingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .item(Price.TieredBps.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.TieredBps.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.TieredBps.Maximum.Filter.builder()
                                    .field(Price.TieredBps.Maximum.Filter.Field.PRICE_ID)
                                    .operator(Price.TieredBps.Maximum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.TieredBps.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.TieredBps.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.TieredBps.Minimum.Filter.builder()
                                    .field(Price.TieredBps.Minimum.Filter.Field.PRICE_ID)
                                    .operator(Price.TieredBps.Minimum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.TieredBps.PriceType.USAGE_PRICE)
                    .tieredBpsConfig(
                        Price.TieredBps.TieredBpsConfig.builder()
                            .addTier(
                                Price.TieredBps.TieredBpsConfig.Tier.builder()
                                    .bps(0.0)
                                    .minimumAmount("minimum_amount")
                                    .maximumAmount("maximum_amount")
                                    .perUnitMaximum("per_unit_maximum")
                                    .build()
                            )
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        Price.TieredBps.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofBps() {
        val bps =
            Price.Bps.builder()
                .id("id")
                .billableMetric(Price.Bps.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.Bps.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.Bps.BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .bpsConfig(
                    Price.Bps.BpsConfig.builder()
                        .bps(0.0)
                        .perUnitMaximum("per_unit_maximum")
                        .build()
                )
                .cadence(Price.Bps.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.Bps.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.Bps.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.Bps.CreditAllocation.CustomExpiration.DurationUnit.DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.Bps.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.Bps.InvoicingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(Price.Bps.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.Bps.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.Bps.Maximum.Filter.builder()
                                .field(Price.Bps.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.Bps.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.Bps.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.Bps.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.Bps.Minimum.Filter.builder()
                                .field(Price.Bps.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.Bps.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.Bps.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.Bps.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofBps(bps)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).contains(bps)
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofBpsRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofBps(
                Price.Bps.builder()
                    .id("id")
                    .billableMetric(Price.Bps.BillableMetric.builder().id("id").build())
                    .billingCycleConfiguration(
                        Price.Bps.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(Price.Bps.BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .bpsConfig(
                        Price.Bps.BpsConfig.builder()
                            .bps(0.0)
                            .perUnitMaximum("per_unit_maximum")
                            .build()
                    )
                    .cadence(Price.Bps.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.Bps.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.Bps.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.Bps.CreditAllocation.CustomExpiration.DurationUnit.DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.Bps.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(Price.Bps.InvoicingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(Price.Bps.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.Bps.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.Bps.Maximum.Filter.builder()
                                    .field(Price.Bps.Maximum.Filter.Field.PRICE_ID)
                                    .operator(Price.Bps.Maximum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.Bps.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.Bps.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.Bps.Minimum.Filter.builder()
                                    .field(Price.Bps.Minimum.Filter.Field.PRICE_ID)
                                    .operator(Price.Bps.Minimum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.Bps.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.Bps.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofBulkBps() {
        val bulkBps =
            Price.BulkBps.builder()
                .id("id")
                .billableMetric(Price.BulkBps.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.BulkBps.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.BulkBps.BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .bulkBpsConfig(
                    Price.BulkBps.BulkBpsConfig.builder()
                        .addTier(
                            Price.BulkBps.BulkBpsConfig.Tier.builder()
                                .bps(0.0)
                                .maximumAmount("maximum_amount")
                                .perUnitMaximum("per_unit_maximum")
                                .build()
                        )
                        .build()
                )
                .cadence(Price.BulkBps.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.BulkBps.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.BulkBps.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.BulkBps.CreditAllocation.CustomExpiration.DurationUnit.DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.BulkBps.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.BulkBps.InvoicingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(Price.BulkBps.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.BulkBps.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.BulkBps.Maximum.Filter.builder()
                                .field(Price.BulkBps.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.BulkBps.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.BulkBps.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.BulkBps.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.BulkBps.Minimum.Filter.builder()
                                .field(Price.BulkBps.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.BulkBps.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.BulkBps.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.BulkBps.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofBulkBps(bulkBps)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).contains(bulkBps)
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofBulkBpsRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofBulkBps(
                Price.BulkBps.builder()
                    .id("id")
                    .billableMetric(Price.BulkBps.BillableMetric.builder().id("id").build())
                    .billingCycleConfiguration(
                        Price.BulkBps.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(Price.BulkBps.BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .bulkBpsConfig(
                        Price.BulkBps.BulkBpsConfig.builder()
                            .addTier(
                                Price.BulkBps.BulkBpsConfig.Tier.builder()
                                    .bps(0.0)
                                    .maximumAmount("maximum_amount")
                                    .perUnitMaximum("per_unit_maximum")
                                    .build()
                            )
                            .build()
                    )
                    .cadence(Price.BulkBps.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.BulkBps.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.BulkBps.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.BulkBps.CreditAllocation.CustomExpiration.DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.BulkBps.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.BulkBps.InvoicingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .item(Price.BulkBps.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.BulkBps.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.BulkBps.Maximum.Filter.builder()
                                    .field(Price.BulkBps.Maximum.Filter.Field.PRICE_ID)
                                    .operator(Price.BulkBps.Maximum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.BulkBps.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.BulkBps.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.BulkBps.Minimum.Filter.builder()
                                    .field(Price.BulkBps.Minimum.Filter.Field.PRICE_ID)
                                    .operator(Price.BulkBps.Minimum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.BulkBps.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.BulkBps.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofBulk() {
        val bulk =
            Price.Bulk.builder()
                .id("id")
                .billableMetric(Price.Bulk.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.Bulk.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.Bulk.BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .bulkConfig(
                    Price.Bulk.BulkConfig.builder()
                        .addTier(
                            Price.Bulk.BulkConfig.Tier.builder()
                                .unitAmount("unit_amount")
                                .maximumUnits(0.0)
                                .build()
                        )
                        .build()
                )
                .cadence(Price.Bulk.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.Bulk.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.Bulk.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.Bulk.CreditAllocation.CustomExpiration.DurationUnit.DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.Bulk.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(Price.Bulk.InvoicingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(Price.Bulk.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.Bulk.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.Bulk.Maximum.Filter.builder()
                                .field(Price.Bulk.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.Bulk.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.Bulk.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.Bulk.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.Bulk.Minimum.Filter.builder()
                                .field(Price.Bulk.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.Bulk.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.Bulk.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.Bulk.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofBulk(bulk)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).contains(bulk)
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofBulkRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofBulk(
                Price.Bulk.builder()
                    .id("id")
                    .billableMetric(Price.Bulk.BillableMetric.builder().id("id").build())
                    .billingCycleConfiguration(
                        Price.Bulk.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(Price.Bulk.BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .bulkConfig(
                        Price.Bulk.BulkConfig.builder()
                            .addTier(
                                Price.Bulk.BulkConfig.Tier.builder()
                                    .unitAmount("unit_amount")
                                    .maximumUnits(0.0)
                                    .build()
                            )
                            .build()
                    )
                    .cadence(Price.Bulk.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.Bulk.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.Bulk.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.Bulk.CreditAllocation.CustomExpiration.DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.Bulk.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(Price.Bulk.InvoicingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(Price.Bulk.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.Bulk.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.Bulk.Maximum.Filter.builder()
                                    .field(Price.Bulk.Maximum.Filter.Field.PRICE_ID)
                                    .operator(Price.Bulk.Maximum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.Bulk.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.Bulk.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.Bulk.Minimum.Filter.builder()
                                    .field(Price.Bulk.Minimum.Filter.Field.PRICE_ID)
                                    .operator(Price.Bulk.Minimum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.Bulk.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.Bulk.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofThresholdTotalAmount() {
        val thresholdTotalAmount =
            Price.ThresholdTotalAmount.builder()
                .id("id")
                .billableMetric(
                    Price.ThresholdTotalAmount.BillableMetric.builder().id("id").build()
                )
                .billingCycleConfiguration(
                    Price.ThresholdTotalAmount.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.ThresholdTotalAmount.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.ThresholdTotalAmount.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.ThresholdTotalAmount.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.ThresholdTotalAmount.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.ThresholdTotalAmount.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.ThresholdTotalAmount.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.ThresholdTotalAmount.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.ThresholdTotalAmount.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.ThresholdTotalAmount.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.ThresholdTotalAmount.Maximum.Filter.builder()
                                .field(Price.ThresholdTotalAmount.Maximum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.ThresholdTotalAmount.Maximum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.ThresholdTotalAmount.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.ThresholdTotalAmount.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.ThresholdTotalAmount.Minimum.Filter.builder()
                                .field(Price.ThresholdTotalAmount.Minimum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.ThresholdTotalAmount.Minimum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.ThresholdTotalAmount.PriceType.USAGE_PRICE)
                .thresholdTotalAmountConfig(
                    Price.ThresholdTotalAmount.ThresholdTotalAmountConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    Price.ThresholdTotalAmount.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofThresholdTotalAmount(thresholdTotalAmount)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).contains(thresholdTotalAmount)
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofThresholdTotalAmountRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofThresholdTotalAmount(
                Price.ThresholdTotalAmount.builder()
                    .id("id")
                    .billableMetric(
                        Price.ThresholdTotalAmount.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.ThresholdTotalAmount.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.ThresholdTotalAmount.BillingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .cadence(Price.ThresholdTotalAmount.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.ThresholdTotalAmount.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.ThresholdTotalAmount.CreditAllocation.CustomExpiration
                                    .builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.ThresholdTotalAmount.CreditAllocation.CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.ThresholdTotalAmount.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.ThresholdTotalAmount.InvoicingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .item(Price.ThresholdTotalAmount.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.ThresholdTotalAmount.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.ThresholdTotalAmount.Maximum.Filter.builder()
                                    .field(Price.ThresholdTotalAmount.Maximum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.ThresholdTotalAmount.Maximum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.ThresholdTotalAmount.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.ThresholdTotalAmount.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.ThresholdTotalAmount.Minimum.Filter.builder()
                                    .field(Price.ThresholdTotalAmount.Minimum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.ThresholdTotalAmount.Minimum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.ThresholdTotalAmount.PriceType.USAGE_PRICE)
                    .thresholdTotalAmountConfig(
                        Price.ThresholdTotalAmount.ThresholdTotalAmountConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        Price.ThresholdTotalAmount.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofTieredPackage() {
        val tieredPackage =
            Price.TieredPackage.builder()
                .id("id")
                .billableMetric(Price.TieredPackage.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.TieredPackage.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.TieredPackage.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.TieredPackage.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.TieredPackage.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.TieredPackage.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.TieredPackage.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.TieredPackage.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.TieredPackage.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.TieredPackage.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.TieredPackage.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.TieredPackage.Maximum.Filter.builder()
                                .field(Price.TieredPackage.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.TieredPackage.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.TieredPackage.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.TieredPackage.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.TieredPackage.Minimum.Filter.builder()
                                .field(Price.TieredPackage.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.TieredPackage.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.TieredPackage.PriceType.USAGE_PRICE)
                .tieredPackageConfig(
                    Price.TieredPackage.TieredPackageConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    Price.TieredPackage.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofTieredPackage(tieredPackage)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).contains(tieredPackage)
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofTieredPackageRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofTieredPackage(
                Price.TieredPackage.builder()
                    .id("id")
                    .billableMetric(Price.TieredPackage.BillableMetric.builder().id("id").build())
                    .billingCycleConfiguration(
                        Price.TieredPackage.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.TieredPackage.BillingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .cadence(Price.TieredPackage.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.TieredPackage.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.TieredPackage.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.TieredPackage.CreditAllocation.CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.TieredPackage.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.TieredPackage.InvoicingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .item(Price.TieredPackage.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.TieredPackage.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.TieredPackage.Maximum.Filter.builder()
                                    .field(Price.TieredPackage.Maximum.Filter.Field.PRICE_ID)
                                    .operator(Price.TieredPackage.Maximum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.TieredPackage.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.TieredPackage.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.TieredPackage.Minimum.Filter.builder()
                                    .field(Price.TieredPackage.Minimum.Filter.Field.PRICE_ID)
                                    .operator(Price.TieredPackage.Minimum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.TieredPackage.PriceType.USAGE_PRICE)
                    .tieredPackageConfig(
                        Price.TieredPackage.TieredPackageConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        Price.TieredPackage.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofGroupedTiered() {
        val groupedTiered =
            Price.GroupedTiered.builder()
                .id("id")
                .billableMetric(Price.GroupedTiered.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.GroupedTiered.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.GroupedTiered.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.GroupedTiered.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.GroupedTiered.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.GroupedTiered.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.GroupedTiered.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .groupedTieredConfig(
                    Price.GroupedTiered.GroupedTieredConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .invoicingCycleConfiguration(
                    Price.GroupedTiered.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.GroupedTiered.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.GroupedTiered.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.GroupedTiered.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.GroupedTiered.Maximum.Filter.builder()
                                .field(Price.GroupedTiered.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.GroupedTiered.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.GroupedTiered.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.GroupedTiered.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.GroupedTiered.Minimum.Filter.builder()
                                .field(Price.GroupedTiered.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.GroupedTiered.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.GroupedTiered.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.GroupedTiered.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofGroupedTiered(groupedTiered)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).contains(groupedTiered)
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofGroupedTieredRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofGroupedTiered(
                Price.GroupedTiered.builder()
                    .id("id")
                    .billableMetric(Price.GroupedTiered.BillableMetric.builder().id("id").build())
                    .billingCycleConfiguration(
                        Price.GroupedTiered.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.GroupedTiered.BillingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .cadence(Price.GroupedTiered.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.GroupedTiered.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.GroupedTiered.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.GroupedTiered.CreditAllocation.CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .groupedTieredConfig(
                        Price.GroupedTiered.GroupedTieredConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .invoicingCycleConfiguration(
                        Price.GroupedTiered.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.GroupedTiered.InvoicingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .item(Price.GroupedTiered.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.GroupedTiered.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.GroupedTiered.Maximum.Filter.builder()
                                    .field(Price.GroupedTiered.Maximum.Filter.Field.PRICE_ID)
                                    .operator(Price.GroupedTiered.Maximum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.GroupedTiered.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.GroupedTiered.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.GroupedTiered.Minimum.Filter.builder()
                                    .field(Price.GroupedTiered.Minimum.Filter.Field.PRICE_ID)
                                    .operator(Price.GroupedTiered.Minimum.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.GroupedTiered.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.GroupedTiered.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofTieredWithMinimum() {
        val tieredWithMinimum =
            Price.TieredWithMinimum.builder()
                .id("id")
                .billableMetric(Price.TieredWithMinimum.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.TieredWithMinimum.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.TieredWithMinimum.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.TieredWithMinimum.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.TieredWithMinimum.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.TieredWithMinimum.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.TieredWithMinimum.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.TieredWithMinimum.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.TieredWithMinimum.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.TieredWithMinimum.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.TieredWithMinimum.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.TieredWithMinimum.Maximum.Filter.builder()
                                .field(Price.TieredWithMinimum.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.TieredWithMinimum.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.TieredWithMinimum.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.TieredWithMinimum.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.TieredWithMinimum.Minimum.Filter.builder()
                                .field(Price.TieredWithMinimum.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.TieredWithMinimum.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.TieredWithMinimum.PriceType.USAGE_PRICE)
                .tieredWithMinimumConfig(
                    Price.TieredWithMinimum.TieredWithMinimumConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    Price.TieredWithMinimum.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofTieredWithMinimum(tieredWithMinimum)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).contains(tieredWithMinimum)
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofTieredWithMinimumRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofTieredWithMinimum(
                Price.TieredWithMinimum.builder()
                    .id("id")
                    .billableMetric(
                        Price.TieredWithMinimum.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.TieredWithMinimum.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.TieredWithMinimum.BillingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .cadence(Price.TieredWithMinimum.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.TieredWithMinimum.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.TieredWithMinimum.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.TieredWithMinimum.CreditAllocation.CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.TieredWithMinimum.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.TieredWithMinimum.InvoicingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .item(Price.TieredWithMinimum.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.TieredWithMinimum.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.TieredWithMinimum.Maximum.Filter.builder()
                                    .field(Price.TieredWithMinimum.Maximum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.TieredWithMinimum.Maximum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.TieredWithMinimum.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.TieredWithMinimum.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.TieredWithMinimum.Minimum.Filter.builder()
                                    .field(Price.TieredWithMinimum.Minimum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.TieredWithMinimum.Minimum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.TieredWithMinimum.PriceType.USAGE_PRICE)
                    .tieredWithMinimumConfig(
                        Price.TieredWithMinimum.TieredWithMinimumConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        Price.TieredWithMinimum.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofTieredPackageWithMinimum() {
        val tieredPackageWithMinimum =
            Price.TieredPackageWithMinimum.builder()
                .id("id")
                .billableMetric(
                    Price.TieredPackageWithMinimum.BillableMetric.builder().id("id").build()
                )
                .billingCycleConfiguration(
                    Price.TieredPackageWithMinimum.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.TieredPackageWithMinimum.BillingCycleConfiguration.DurationUnit
                                .DAY
                        )
                        .build()
                )
                .cadence(Price.TieredPackageWithMinimum.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.TieredPackageWithMinimum.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.TieredPackageWithMinimum.CreditAllocation.CustomExpiration
                                .builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.TieredPackageWithMinimum.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.TieredPackageWithMinimum.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.TieredPackageWithMinimum.InvoicingCycleConfiguration.DurationUnit
                                .DAY
                        )
                        .build()
                )
                .item(Price.TieredPackageWithMinimum.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.TieredPackageWithMinimum.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.TieredPackageWithMinimum.Maximum.Filter.builder()
                                .field(Price.TieredPackageWithMinimum.Maximum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.TieredPackageWithMinimum.Maximum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.TieredPackageWithMinimum.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.TieredPackageWithMinimum.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.TieredPackageWithMinimum.Minimum.Filter.builder()
                                .field(Price.TieredPackageWithMinimum.Minimum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.TieredPackageWithMinimum.Minimum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.TieredPackageWithMinimum.PriceType.USAGE_PRICE)
                .tieredPackageWithMinimumConfig(
                    Price.TieredPackageWithMinimum.TieredPackageWithMinimumConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    Price.TieredPackageWithMinimum.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofTieredPackageWithMinimum(tieredPackageWithMinimum)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).contains(tieredPackageWithMinimum)
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofTieredPackageWithMinimumRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofTieredPackageWithMinimum(
                Price.TieredPackageWithMinimum.builder()
                    .id("id")
                    .billableMetric(
                        Price.TieredPackageWithMinimum.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.TieredPackageWithMinimum.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.TieredPackageWithMinimum.BillingCycleConfiguration
                                    .DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .cadence(Price.TieredPackageWithMinimum.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.TieredPackageWithMinimum.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.TieredPackageWithMinimum.CreditAllocation.CustomExpiration
                                    .builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.TieredPackageWithMinimum.CreditAllocation
                                            .CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.TieredPackageWithMinimum.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.TieredPackageWithMinimum.InvoicingCycleConfiguration
                                    .DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .item(
                        Price.TieredPackageWithMinimum.Item.builder().id("id").name("name").build()
                    )
                    .maximum(
                        Price.TieredPackageWithMinimum.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.TieredPackageWithMinimum.Maximum.Filter.builder()
                                    .field(
                                        Price.TieredPackageWithMinimum.Maximum.Filter.Field.PRICE_ID
                                    )
                                    .operator(
                                        Price.TieredPackageWithMinimum.Maximum.Filter.Operator
                                            .INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.TieredPackageWithMinimum.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.TieredPackageWithMinimum.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.TieredPackageWithMinimum.Minimum.Filter.builder()
                                    .field(
                                        Price.TieredPackageWithMinimum.Minimum.Filter.Field.PRICE_ID
                                    )
                                    .operator(
                                        Price.TieredPackageWithMinimum.Minimum.Filter.Operator
                                            .INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.TieredPackageWithMinimum.PriceType.USAGE_PRICE)
                    .tieredPackageWithMinimumConfig(
                        Price.TieredPackageWithMinimum.TieredPackageWithMinimumConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        Price.TieredPackageWithMinimum.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofPackageWithAllocation() {
        val packageWithAllocation =
            Price.PackageWithAllocation.builder()
                .id("id")
                .billableMetric(
                    Price.PackageWithAllocation.BillableMetric.builder().id("id").build()
                )
                .billingCycleConfiguration(
                    Price.PackageWithAllocation.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.PackageWithAllocation.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.PackageWithAllocation.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.PackageWithAllocation.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.PackageWithAllocation.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.PackageWithAllocation.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.PackageWithAllocation.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.PackageWithAllocation.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.PackageWithAllocation.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.PackageWithAllocation.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.PackageWithAllocation.Maximum.Filter.builder()
                                .field(Price.PackageWithAllocation.Maximum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.PackageWithAllocation.Maximum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.PackageWithAllocation.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.PackageWithAllocation.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.PackageWithAllocation.Minimum.Filter.builder()
                                .field(Price.PackageWithAllocation.Minimum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.PackageWithAllocation.Minimum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .packageWithAllocationConfig(
                    Price.PackageWithAllocation.PackageWithAllocationConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .planPhaseOrder(0L)
                .priceType(Price.PackageWithAllocation.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.PackageWithAllocation.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofPackageWithAllocation(packageWithAllocation)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).contains(packageWithAllocation)
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofPackageWithAllocationRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofPackageWithAllocation(
                Price.PackageWithAllocation.builder()
                    .id("id")
                    .billableMetric(
                        Price.PackageWithAllocation.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.PackageWithAllocation.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.PackageWithAllocation.BillingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .cadence(Price.PackageWithAllocation.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.PackageWithAllocation.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.PackageWithAllocation.CreditAllocation.CustomExpiration
                                    .builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.PackageWithAllocation.CreditAllocation
                                            .CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.PackageWithAllocation.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.PackageWithAllocation.InvoicingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .item(Price.PackageWithAllocation.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.PackageWithAllocation.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.PackageWithAllocation.Maximum.Filter.builder()
                                    .field(
                                        Price.PackageWithAllocation.Maximum.Filter.Field.PRICE_ID
                                    )
                                    .operator(
                                        Price.PackageWithAllocation.Maximum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.PackageWithAllocation.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.PackageWithAllocation.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.PackageWithAllocation.Minimum.Filter.builder()
                                    .field(
                                        Price.PackageWithAllocation.Minimum.Filter.Field.PRICE_ID
                                    )
                                    .operator(
                                        Price.PackageWithAllocation.Minimum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .packageWithAllocationConfig(
                        Price.PackageWithAllocation.PackageWithAllocationConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .planPhaseOrder(0L)
                    .priceType(Price.PackageWithAllocation.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.PackageWithAllocation.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofUnitWithPercent() {
        val unitWithPercent =
            Price.UnitWithPercent.builder()
                .id("id")
                .billableMetric(Price.UnitWithPercent.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.UnitWithPercent.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.UnitWithPercent.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.UnitWithPercent.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.UnitWithPercent.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.UnitWithPercent.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.UnitWithPercent.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.UnitWithPercent.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.UnitWithPercent.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.UnitWithPercent.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.UnitWithPercent.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.UnitWithPercent.Maximum.Filter.builder()
                                .field(Price.UnitWithPercent.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.UnitWithPercent.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.UnitWithPercent.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.UnitWithPercent.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.UnitWithPercent.Minimum.Filter.builder()
                                .field(Price.UnitWithPercent.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.UnitWithPercent.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.UnitWithPercent.PriceType.USAGE_PRICE)
                .unitWithPercentConfig(
                    Price.UnitWithPercent.UnitWithPercentConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    Price.UnitWithPercent.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofUnitWithPercent(unitWithPercent)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).contains(unitWithPercent)
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofUnitWithPercentRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofUnitWithPercent(
                Price.UnitWithPercent.builder()
                    .id("id")
                    .billableMetric(Price.UnitWithPercent.BillableMetric.builder().id("id").build())
                    .billingCycleConfiguration(
                        Price.UnitWithPercent.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.UnitWithPercent.BillingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .cadence(Price.UnitWithPercent.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.UnitWithPercent.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.UnitWithPercent.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.UnitWithPercent.CreditAllocation.CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.UnitWithPercent.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.UnitWithPercent.InvoicingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .item(Price.UnitWithPercent.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.UnitWithPercent.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.UnitWithPercent.Maximum.Filter.builder()
                                    .field(Price.UnitWithPercent.Maximum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.UnitWithPercent.Maximum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.UnitWithPercent.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.UnitWithPercent.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.UnitWithPercent.Minimum.Filter.builder()
                                    .field(Price.UnitWithPercent.Minimum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.UnitWithPercent.Minimum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.UnitWithPercent.PriceType.USAGE_PRICE)
                    .unitWithPercentConfig(
                        Price.UnitWithPercent.UnitWithPercentConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        Price.UnitWithPercent.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofMatrixWithAllocation() {
        val matrixWithAllocation =
            Price.MatrixWithAllocation.builder()
                .id("id")
                .billableMetric(
                    Price.MatrixWithAllocation.BillableMetric.builder().id("id").build()
                )
                .billingCycleConfiguration(
                    Price.MatrixWithAllocation.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.MatrixWithAllocation.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.MatrixWithAllocation.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.MatrixWithAllocation.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.MatrixWithAllocation.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.MatrixWithAllocation.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.MatrixWithAllocation.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.MatrixWithAllocation.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.MatrixWithAllocation.Item.builder().id("id").name("name").build())
                .matrixWithAllocationConfig(
                    Price.MatrixWithAllocation.MatrixWithAllocationConfig.builder()
                        .allocation(0.0)
                        .defaultUnitAmount("default_unit_amount")
                        .addDimension("string")
                        .addMatrixValue(
                            Price.MatrixWithAllocation.MatrixWithAllocationConfig.MatrixValue
                                .builder()
                                .addDimensionValue("string")
                                .unitAmount("unit_amount")
                                .build()
                        )
                        .build()
                )
                .maximum(
                    Price.MatrixWithAllocation.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.MatrixWithAllocation.Maximum.Filter.builder()
                                .field(Price.MatrixWithAllocation.Maximum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.MatrixWithAllocation.Maximum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.MatrixWithAllocation.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.MatrixWithAllocation.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.MatrixWithAllocation.Minimum.Filter.builder()
                                .field(Price.MatrixWithAllocation.Minimum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.MatrixWithAllocation.Minimum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.MatrixWithAllocation.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.MatrixWithAllocation.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofMatrixWithAllocation(matrixWithAllocation)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).contains(matrixWithAllocation)
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofMatrixWithAllocationRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofMatrixWithAllocation(
                Price.MatrixWithAllocation.builder()
                    .id("id")
                    .billableMetric(
                        Price.MatrixWithAllocation.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.MatrixWithAllocation.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.MatrixWithAllocation.BillingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .cadence(Price.MatrixWithAllocation.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.MatrixWithAllocation.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.MatrixWithAllocation.CreditAllocation.CustomExpiration
                                    .builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.MatrixWithAllocation.CreditAllocation.CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.MatrixWithAllocation.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.MatrixWithAllocation.InvoicingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .item(Price.MatrixWithAllocation.Item.builder().id("id").name("name").build())
                    .matrixWithAllocationConfig(
                        Price.MatrixWithAllocation.MatrixWithAllocationConfig.builder()
                            .allocation(0.0)
                            .defaultUnitAmount("default_unit_amount")
                            .addDimension("string")
                            .addMatrixValue(
                                Price.MatrixWithAllocation.MatrixWithAllocationConfig.MatrixValue
                                    .builder()
                                    .addDimensionValue("string")
                                    .unitAmount("unit_amount")
                                    .build()
                            )
                            .build()
                    )
                    .maximum(
                        Price.MatrixWithAllocation.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.MatrixWithAllocation.Maximum.Filter.builder()
                                    .field(Price.MatrixWithAllocation.Maximum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.MatrixWithAllocation.Maximum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.MatrixWithAllocation.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.MatrixWithAllocation.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.MatrixWithAllocation.Minimum.Filter.builder()
                                    .field(Price.MatrixWithAllocation.Minimum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.MatrixWithAllocation.Minimum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.MatrixWithAllocation.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.MatrixWithAllocation.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofTieredWithProration() {
        val tieredWithProration =
            Price.TieredWithProration.builder()
                .id("id")
                .billableMetric(Price.TieredWithProration.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.TieredWithProration.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.TieredWithProration.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.TieredWithProration.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.TieredWithProration.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.TieredWithProration.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.TieredWithProration.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.TieredWithProration.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.TieredWithProration.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.TieredWithProration.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.TieredWithProration.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.TieredWithProration.Maximum.Filter.builder()
                                .field(Price.TieredWithProration.Maximum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.TieredWithProration.Maximum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.TieredWithProration.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.TieredWithProration.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.TieredWithProration.Minimum.Filter.builder()
                                .field(Price.TieredWithProration.Minimum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.TieredWithProration.Minimum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.TieredWithProration.PriceType.USAGE_PRICE)
                .tieredWithProrationConfig(
                    Price.TieredWithProration.TieredWithProrationConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    Price.TieredWithProration.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofTieredWithProration(tieredWithProration)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).contains(tieredWithProration)
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofTieredWithProrationRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofTieredWithProration(
                Price.TieredWithProration.builder()
                    .id("id")
                    .billableMetric(
                        Price.TieredWithProration.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.TieredWithProration.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.TieredWithProration.BillingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .cadence(Price.TieredWithProration.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.TieredWithProration.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.TieredWithProration.CreditAllocation.CustomExpiration
                                    .builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.TieredWithProration.CreditAllocation.CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.TieredWithProration.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.TieredWithProration.InvoicingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .item(Price.TieredWithProration.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.TieredWithProration.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.TieredWithProration.Maximum.Filter.builder()
                                    .field(Price.TieredWithProration.Maximum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.TieredWithProration.Maximum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.TieredWithProration.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.TieredWithProration.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.TieredWithProration.Minimum.Filter.builder()
                                    .field(Price.TieredWithProration.Minimum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.TieredWithProration.Minimum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.TieredWithProration.PriceType.USAGE_PRICE)
                    .tieredWithProrationConfig(
                        Price.TieredWithProration.TieredWithProrationConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        Price.TieredWithProration.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofUnitWithProration() {
        val unitWithProration =
            Price.UnitWithProration.builder()
                .id("id")
                .billableMetric(Price.UnitWithProration.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.UnitWithProration.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.UnitWithProration.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.UnitWithProration.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.UnitWithProration.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.UnitWithProration.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.UnitWithProration.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.UnitWithProration.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.UnitWithProration.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.UnitWithProration.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.UnitWithProration.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.UnitWithProration.Maximum.Filter.builder()
                                .field(Price.UnitWithProration.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.UnitWithProration.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.UnitWithProration.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.UnitWithProration.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.UnitWithProration.Minimum.Filter.builder()
                                .field(Price.UnitWithProration.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.UnitWithProration.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.UnitWithProration.PriceType.USAGE_PRICE)
                .unitWithProrationConfig(
                    Price.UnitWithProration.UnitWithProrationConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    Price.UnitWithProration.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofUnitWithProration(unitWithProration)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).contains(unitWithProration)
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofUnitWithProrationRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofUnitWithProration(
                Price.UnitWithProration.builder()
                    .id("id")
                    .billableMetric(
                        Price.UnitWithProration.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.UnitWithProration.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.UnitWithProration.BillingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .cadence(Price.UnitWithProration.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.UnitWithProration.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.UnitWithProration.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.UnitWithProration.CreditAllocation.CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.UnitWithProration.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.UnitWithProration.InvoicingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .item(Price.UnitWithProration.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.UnitWithProration.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.UnitWithProration.Maximum.Filter.builder()
                                    .field(Price.UnitWithProration.Maximum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.UnitWithProration.Maximum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.UnitWithProration.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.UnitWithProration.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.UnitWithProration.Minimum.Filter.builder()
                                    .field(Price.UnitWithProration.Minimum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.UnitWithProration.Minimum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.UnitWithProration.PriceType.USAGE_PRICE)
                    .unitWithProrationConfig(
                        Price.UnitWithProration.UnitWithProrationConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        Price.UnitWithProration.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofGroupedAllocation() {
        val groupedAllocation =
            Price.GroupedAllocation.builder()
                .id("id")
                .billableMetric(Price.GroupedAllocation.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.GroupedAllocation.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.GroupedAllocation.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.GroupedAllocation.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.GroupedAllocation.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.GroupedAllocation.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.GroupedAllocation.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .groupedAllocationConfig(
                    Price.GroupedAllocation.GroupedAllocationConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .invoicingCycleConfiguration(
                    Price.GroupedAllocation.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.GroupedAllocation.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.GroupedAllocation.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.GroupedAllocation.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.GroupedAllocation.Maximum.Filter.builder()
                                .field(Price.GroupedAllocation.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.GroupedAllocation.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.GroupedAllocation.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.GroupedAllocation.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.GroupedAllocation.Minimum.Filter.builder()
                                .field(Price.GroupedAllocation.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.GroupedAllocation.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.GroupedAllocation.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.GroupedAllocation.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofGroupedAllocation(groupedAllocation)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).contains(groupedAllocation)
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofGroupedAllocationRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofGroupedAllocation(
                Price.GroupedAllocation.builder()
                    .id("id")
                    .billableMetric(
                        Price.GroupedAllocation.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.GroupedAllocation.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.GroupedAllocation.BillingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .cadence(Price.GroupedAllocation.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.GroupedAllocation.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.GroupedAllocation.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.GroupedAllocation.CreditAllocation.CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .groupedAllocationConfig(
                        Price.GroupedAllocation.GroupedAllocationConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .invoicingCycleConfiguration(
                        Price.GroupedAllocation.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.GroupedAllocation.InvoicingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .item(Price.GroupedAllocation.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.GroupedAllocation.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.GroupedAllocation.Maximum.Filter.builder()
                                    .field(Price.GroupedAllocation.Maximum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.GroupedAllocation.Maximum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.GroupedAllocation.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.GroupedAllocation.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.GroupedAllocation.Minimum.Filter.builder()
                                    .field(Price.GroupedAllocation.Minimum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.GroupedAllocation.Minimum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.GroupedAllocation.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.GroupedAllocation.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofGroupedWithProratedMinimum() {
        val groupedWithProratedMinimum =
            Price.GroupedWithProratedMinimum.builder()
                .id("id")
                .billableMetric(
                    Price.GroupedWithProratedMinimum.BillableMetric.builder().id("id").build()
                )
                .billingCycleConfiguration(
                    Price.GroupedWithProratedMinimum.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.GroupedWithProratedMinimum.BillingCycleConfiguration.DurationUnit
                                .DAY
                        )
                        .build()
                )
                .cadence(Price.GroupedWithProratedMinimum.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.GroupedWithProratedMinimum.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.GroupedWithProratedMinimum.CreditAllocation.CustomExpiration
                                .builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.GroupedWithProratedMinimum.CreditAllocation
                                        .CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .groupedWithProratedMinimumConfig(
                    Price.GroupedWithProratedMinimum.GroupedWithProratedMinimumConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .invoicingCycleConfiguration(
                    Price.GroupedWithProratedMinimum.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.GroupedWithProratedMinimum.InvoicingCycleConfiguration
                                .DurationUnit
                                .DAY
                        )
                        .build()
                )
                .item(Price.GroupedWithProratedMinimum.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.GroupedWithProratedMinimum.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.GroupedWithProratedMinimum.Maximum.Filter.builder()
                                .field(
                                    Price.GroupedWithProratedMinimum.Maximum.Filter.Field.PRICE_ID
                                )
                                .operator(
                                    Price.GroupedWithProratedMinimum.Maximum.Filter.Operator
                                        .INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.GroupedWithProratedMinimum.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.GroupedWithProratedMinimum.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.GroupedWithProratedMinimum.Minimum.Filter.builder()
                                .field(
                                    Price.GroupedWithProratedMinimum.Minimum.Filter.Field.PRICE_ID
                                )
                                .operator(
                                    Price.GroupedWithProratedMinimum.Minimum.Filter.Operator
                                        .INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.GroupedWithProratedMinimum.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.GroupedWithProratedMinimum.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofGroupedWithProratedMinimum(groupedWithProratedMinimum)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).contains(groupedWithProratedMinimum)
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofGroupedWithProratedMinimumRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofGroupedWithProratedMinimum(
                Price.GroupedWithProratedMinimum.builder()
                    .id("id")
                    .billableMetric(
                        Price.GroupedWithProratedMinimum.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.GroupedWithProratedMinimum.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.GroupedWithProratedMinimum.BillingCycleConfiguration
                                    .DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .cadence(Price.GroupedWithProratedMinimum.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.GroupedWithProratedMinimum.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.GroupedWithProratedMinimum.CreditAllocation.CustomExpiration
                                    .builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.GroupedWithProratedMinimum.CreditAllocation
                                            .CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .groupedWithProratedMinimumConfig(
                        Price.GroupedWithProratedMinimum.GroupedWithProratedMinimumConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .invoicingCycleConfiguration(
                        Price.GroupedWithProratedMinimum.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.GroupedWithProratedMinimum.InvoicingCycleConfiguration
                                    .DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .item(
                        Price.GroupedWithProratedMinimum.Item.builder()
                            .id("id")
                            .name("name")
                            .build()
                    )
                    .maximum(
                        Price.GroupedWithProratedMinimum.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.GroupedWithProratedMinimum.Maximum.Filter.builder()
                                    .field(
                                        Price.GroupedWithProratedMinimum.Maximum.Filter.Field
                                            .PRICE_ID
                                    )
                                    .operator(
                                        Price.GroupedWithProratedMinimum.Maximum.Filter.Operator
                                            .INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.GroupedWithProratedMinimum.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.GroupedWithProratedMinimum.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.GroupedWithProratedMinimum.Minimum.Filter.builder()
                                    .field(
                                        Price.GroupedWithProratedMinimum.Minimum.Filter.Field
                                            .PRICE_ID
                                    )
                                    .operator(
                                        Price.GroupedWithProratedMinimum.Minimum.Filter.Operator
                                            .INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.GroupedWithProratedMinimum.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.GroupedWithProratedMinimum.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofGroupedWithMeteredMinimum() {
        val groupedWithMeteredMinimum =
            Price.GroupedWithMeteredMinimum.builder()
                .id("id")
                .billableMetric(
                    Price.GroupedWithMeteredMinimum.BillableMetric.builder().id("id").build()
                )
                .billingCycleConfiguration(
                    Price.GroupedWithMeteredMinimum.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.GroupedWithMeteredMinimum.BillingCycleConfiguration.DurationUnit
                                .DAY
                        )
                        .build()
                )
                .cadence(Price.GroupedWithMeteredMinimum.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.GroupedWithMeteredMinimum.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.GroupedWithMeteredMinimum.CreditAllocation.CustomExpiration
                                .builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.GroupedWithMeteredMinimum.CreditAllocation
                                        .CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .groupedWithMeteredMinimumConfig(
                    Price.GroupedWithMeteredMinimum.GroupedWithMeteredMinimumConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .invoicingCycleConfiguration(
                    Price.GroupedWithMeteredMinimum.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.GroupedWithMeteredMinimum.InvoicingCycleConfiguration.DurationUnit
                                .DAY
                        )
                        .build()
                )
                .item(Price.GroupedWithMeteredMinimum.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.GroupedWithMeteredMinimum.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.GroupedWithMeteredMinimum.Maximum.Filter.builder()
                                .field(
                                    Price.GroupedWithMeteredMinimum.Maximum.Filter.Field.PRICE_ID
                                )
                                .operator(
                                    Price.GroupedWithMeteredMinimum.Maximum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.GroupedWithMeteredMinimum.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.GroupedWithMeteredMinimum.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.GroupedWithMeteredMinimum.Minimum.Filter.builder()
                                .field(
                                    Price.GroupedWithMeteredMinimum.Minimum.Filter.Field.PRICE_ID
                                )
                                .operator(
                                    Price.GroupedWithMeteredMinimum.Minimum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.GroupedWithMeteredMinimum.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.GroupedWithMeteredMinimum.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofGroupedWithMeteredMinimum(groupedWithMeteredMinimum)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).contains(groupedWithMeteredMinimum)
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofGroupedWithMeteredMinimumRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofGroupedWithMeteredMinimum(
                Price.GroupedWithMeteredMinimum.builder()
                    .id("id")
                    .billableMetric(
                        Price.GroupedWithMeteredMinimum.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.GroupedWithMeteredMinimum.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.GroupedWithMeteredMinimum.BillingCycleConfiguration
                                    .DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .cadence(Price.GroupedWithMeteredMinimum.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.GroupedWithMeteredMinimum.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.GroupedWithMeteredMinimum.CreditAllocation.CustomExpiration
                                    .builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.GroupedWithMeteredMinimum.CreditAllocation
                                            .CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .groupedWithMeteredMinimumConfig(
                        Price.GroupedWithMeteredMinimum.GroupedWithMeteredMinimumConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .invoicingCycleConfiguration(
                        Price.GroupedWithMeteredMinimum.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.GroupedWithMeteredMinimum.InvoicingCycleConfiguration
                                    .DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .item(
                        Price.GroupedWithMeteredMinimum.Item.builder().id("id").name("name").build()
                    )
                    .maximum(
                        Price.GroupedWithMeteredMinimum.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.GroupedWithMeteredMinimum.Maximum.Filter.builder()
                                    .field(
                                        Price.GroupedWithMeteredMinimum.Maximum.Filter.Field
                                            .PRICE_ID
                                    )
                                    .operator(
                                        Price.GroupedWithMeteredMinimum.Maximum.Filter.Operator
                                            .INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.GroupedWithMeteredMinimum.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.GroupedWithMeteredMinimum.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.GroupedWithMeteredMinimum.Minimum.Filter.builder()
                                    .field(
                                        Price.GroupedWithMeteredMinimum.Minimum.Filter.Field
                                            .PRICE_ID
                                    )
                                    .operator(
                                        Price.GroupedWithMeteredMinimum.Minimum.Filter.Operator
                                            .INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.GroupedWithMeteredMinimum.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.GroupedWithMeteredMinimum.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofMatrixWithDisplayName() {
        val matrixWithDisplayName =
            Price.MatrixWithDisplayName.builder()
                .id("id")
                .billableMetric(
                    Price.MatrixWithDisplayName.BillableMetric.builder().id("id").build()
                )
                .billingCycleConfiguration(
                    Price.MatrixWithDisplayName.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.MatrixWithDisplayName.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.MatrixWithDisplayName.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.MatrixWithDisplayName.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.MatrixWithDisplayName.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.MatrixWithDisplayName.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.MatrixWithDisplayName.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.MatrixWithDisplayName.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.MatrixWithDisplayName.Item.builder().id("id").name("name").build())
                .matrixWithDisplayNameConfig(
                    Price.MatrixWithDisplayName.MatrixWithDisplayNameConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .maximum(
                    Price.MatrixWithDisplayName.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.MatrixWithDisplayName.Maximum.Filter.builder()
                                .field(Price.MatrixWithDisplayName.Maximum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.MatrixWithDisplayName.Maximum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.MatrixWithDisplayName.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.MatrixWithDisplayName.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.MatrixWithDisplayName.Minimum.Filter.builder()
                                .field(Price.MatrixWithDisplayName.Minimum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.MatrixWithDisplayName.Minimum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.MatrixWithDisplayName.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.MatrixWithDisplayName.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofMatrixWithDisplayName(matrixWithDisplayName)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).contains(matrixWithDisplayName)
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofMatrixWithDisplayNameRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofMatrixWithDisplayName(
                Price.MatrixWithDisplayName.builder()
                    .id("id")
                    .billableMetric(
                        Price.MatrixWithDisplayName.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.MatrixWithDisplayName.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.MatrixWithDisplayName.BillingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .cadence(Price.MatrixWithDisplayName.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.MatrixWithDisplayName.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.MatrixWithDisplayName.CreditAllocation.CustomExpiration
                                    .builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.MatrixWithDisplayName.CreditAllocation
                                            .CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.MatrixWithDisplayName.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.MatrixWithDisplayName.InvoicingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .item(Price.MatrixWithDisplayName.Item.builder().id("id").name("name").build())
                    .matrixWithDisplayNameConfig(
                        Price.MatrixWithDisplayName.MatrixWithDisplayNameConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .maximum(
                        Price.MatrixWithDisplayName.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.MatrixWithDisplayName.Maximum.Filter.builder()
                                    .field(
                                        Price.MatrixWithDisplayName.Maximum.Filter.Field.PRICE_ID
                                    )
                                    .operator(
                                        Price.MatrixWithDisplayName.Maximum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.MatrixWithDisplayName.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.MatrixWithDisplayName.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.MatrixWithDisplayName.Minimum.Filter.builder()
                                    .field(
                                        Price.MatrixWithDisplayName.Minimum.Filter.Field.PRICE_ID
                                    )
                                    .operator(
                                        Price.MatrixWithDisplayName.Minimum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.MatrixWithDisplayName.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.MatrixWithDisplayName.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofBulkWithProration() {
        val bulkWithProration =
            Price.BulkWithProration.builder()
                .id("id")
                .billableMetric(Price.BulkWithProration.BillableMetric.builder().id("id").build())
                .billingCycleConfiguration(
                    Price.BulkWithProration.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.BulkWithProration.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .bulkWithProrationConfig(
                    Price.BulkWithProration.BulkWithProrationConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .cadence(Price.BulkWithProration.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.BulkWithProration.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.BulkWithProration.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.BulkWithProration.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.BulkWithProration.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.BulkWithProration.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.BulkWithProration.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.BulkWithProration.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.BulkWithProration.Maximum.Filter.builder()
                                .field(Price.BulkWithProration.Maximum.Filter.Field.PRICE_ID)
                                .operator(Price.BulkWithProration.Maximum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.BulkWithProration.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.BulkWithProration.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.BulkWithProration.Minimum.Filter.builder()
                                .field(Price.BulkWithProration.Minimum.Filter.Field.PRICE_ID)
                                .operator(Price.BulkWithProration.Minimum.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.BulkWithProration.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.BulkWithProration.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofBulkWithProration(bulkWithProration)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).contains(bulkWithProration)
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofBulkWithProrationRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofBulkWithProration(
                Price.BulkWithProration.builder()
                    .id("id")
                    .billableMetric(
                        Price.BulkWithProration.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.BulkWithProration.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.BulkWithProration.BillingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .bulkWithProrationConfig(
                        Price.BulkWithProration.BulkWithProrationConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .cadence(Price.BulkWithProration.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.BulkWithProration.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.BulkWithProration.CreditAllocation.CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.BulkWithProration.CreditAllocation.CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.BulkWithProration.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.BulkWithProration.InvoicingCycleConfiguration.DurationUnit.DAY
                            )
                            .build()
                    )
                    .item(Price.BulkWithProration.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.BulkWithProration.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.BulkWithProration.Maximum.Filter.builder()
                                    .field(Price.BulkWithProration.Maximum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.BulkWithProration.Maximum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.BulkWithProration.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.BulkWithProration.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.BulkWithProration.Minimum.Filter.builder()
                                    .field(Price.BulkWithProration.Minimum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.BulkWithProration.Minimum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.BulkWithProration.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.BulkWithProration.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofGroupedTieredPackage() {
        val groupedTieredPackage =
            Price.GroupedTieredPackage.builder()
                .id("id")
                .billableMetric(
                    Price.GroupedTieredPackage.BillableMetric.builder().id("id").build()
                )
                .billingCycleConfiguration(
                    Price.GroupedTieredPackage.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.GroupedTieredPackage.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.GroupedTieredPackage.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.GroupedTieredPackage.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.GroupedTieredPackage.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.GroupedTieredPackage.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .groupedTieredPackageConfig(
                    Price.GroupedTieredPackage.GroupedTieredPackageConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .invoicingCycleConfiguration(
                    Price.GroupedTieredPackage.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.GroupedTieredPackage.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.GroupedTieredPackage.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.GroupedTieredPackage.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.GroupedTieredPackage.Maximum.Filter.builder()
                                .field(Price.GroupedTieredPackage.Maximum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.GroupedTieredPackage.Maximum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.GroupedTieredPackage.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.GroupedTieredPackage.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.GroupedTieredPackage.Minimum.Filter.builder()
                                .field(Price.GroupedTieredPackage.Minimum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.GroupedTieredPackage.Minimum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.GroupedTieredPackage.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.GroupedTieredPackage.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofGroupedTieredPackage(groupedTieredPackage)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).contains(groupedTieredPackage)
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofGroupedTieredPackageRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofGroupedTieredPackage(
                Price.GroupedTieredPackage.builder()
                    .id("id")
                    .billableMetric(
                        Price.GroupedTieredPackage.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.GroupedTieredPackage.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.GroupedTieredPackage.BillingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .cadence(Price.GroupedTieredPackage.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.GroupedTieredPackage.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.GroupedTieredPackage.CreditAllocation.CustomExpiration
                                    .builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.GroupedTieredPackage.CreditAllocation.CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .groupedTieredPackageConfig(
                        Price.GroupedTieredPackage.GroupedTieredPackageConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .invoicingCycleConfiguration(
                        Price.GroupedTieredPackage.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.GroupedTieredPackage.InvoicingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .item(Price.GroupedTieredPackage.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.GroupedTieredPackage.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.GroupedTieredPackage.Maximum.Filter.builder()
                                    .field(Price.GroupedTieredPackage.Maximum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.GroupedTieredPackage.Maximum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.GroupedTieredPackage.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.GroupedTieredPackage.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.GroupedTieredPackage.Minimum.Filter.builder()
                                    .field(Price.GroupedTieredPackage.Minimum.Filter.Field.PRICE_ID)
                                    .operator(
                                        Price.GroupedTieredPackage.Minimum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.GroupedTieredPackage.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.GroupedTieredPackage.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofMaxGroupTieredPackage() {
        val maxGroupTieredPackage =
            Price.MaxGroupTieredPackage.builder()
                .id("id")
                .billableMetric(
                    Price.MaxGroupTieredPackage.BillableMetric.builder().id("id").build()
                )
                .billingCycleConfiguration(
                    Price.MaxGroupTieredPackage.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.MaxGroupTieredPackage.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.MaxGroupTieredPackage.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.MaxGroupTieredPackage.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.MaxGroupTieredPackage.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.MaxGroupTieredPackage.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.MaxGroupTieredPackage.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.MaxGroupTieredPackage.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.MaxGroupTieredPackage.Item.builder().id("id").name("name").build())
                .maxGroupTieredPackageConfig(
                    Price.MaxGroupTieredPackage.MaxGroupTieredPackageConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .maximum(
                    Price.MaxGroupTieredPackage.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.MaxGroupTieredPackage.Maximum.Filter.builder()
                                .field(Price.MaxGroupTieredPackage.Maximum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.MaxGroupTieredPackage.Maximum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.MaxGroupTieredPackage.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.MaxGroupTieredPackage.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.MaxGroupTieredPackage.Minimum.Filter.builder()
                                .field(Price.MaxGroupTieredPackage.Minimum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.MaxGroupTieredPackage.Minimum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.MaxGroupTieredPackage.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.MaxGroupTieredPackage.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofMaxGroupTieredPackage(maxGroupTieredPackage)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).contains(maxGroupTieredPackage)
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofMaxGroupTieredPackageRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofMaxGroupTieredPackage(
                Price.MaxGroupTieredPackage.builder()
                    .id("id")
                    .billableMetric(
                        Price.MaxGroupTieredPackage.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.MaxGroupTieredPackage.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.MaxGroupTieredPackage.BillingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .cadence(Price.MaxGroupTieredPackage.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.MaxGroupTieredPackage.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.MaxGroupTieredPackage.CreditAllocation.CustomExpiration
                                    .builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.MaxGroupTieredPackage.CreditAllocation
                                            .CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.MaxGroupTieredPackage.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.MaxGroupTieredPackage.InvoicingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .item(Price.MaxGroupTieredPackage.Item.builder().id("id").name("name").build())
                    .maxGroupTieredPackageConfig(
                        Price.MaxGroupTieredPackage.MaxGroupTieredPackageConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .maximum(
                        Price.MaxGroupTieredPackage.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.MaxGroupTieredPackage.Maximum.Filter.builder()
                                    .field(
                                        Price.MaxGroupTieredPackage.Maximum.Filter.Field.PRICE_ID
                                    )
                                    .operator(
                                        Price.MaxGroupTieredPackage.Maximum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.MaxGroupTieredPackage.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.MaxGroupTieredPackage.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.MaxGroupTieredPackage.Minimum.Filter.builder()
                                    .field(
                                        Price.MaxGroupTieredPackage.Minimum.Filter.Field.PRICE_ID
                                    )
                                    .operator(
                                        Price.MaxGroupTieredPackage.Minimum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.MaxGroupTieredPackage.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.MaxGroupTieredPackage.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofScalableMatrixWithUnitPricing() {
        val scalableMatrixWithUnitPricing =
            Price.ScalableMatrixWithUnitPricing.builder()
                .id("id")
                .billableMetric(
                    Price.ScalableMatrixWithUnitPricing.BillableMetric.builder().id("id").build()
                )
                .billingCycleConfiguration(
                    Price.ScalableMatrixWithUnitPricing.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.ScalableMatrixWithUnitPricing.BillingCycleConfiguration
                                .DurationUnit
                                .DAY
                        )
                        .build()
                )
                .cadence(Price.ScalableMatrixWithUnitPricing.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.ScalableMatrixWithUnitPricing.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.ScalableMatrixWithUnitPricing.CreditAllocation.CustomExpiration
                                .builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.ScalableMatrixWithUnitPricing.CreditAllocation
                                        .CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.ScalableMatrixWithUnitPricing.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.ScalableMatrixWithUnitPricing.InvoicingCycleConfiguration
                                .DurationUnit
                                .DAY
                        )
                        .build()
                )
                .item(
                    Price.ScalableMatrixWithUnitPricing.Item.builder().id("id").name("name").build()
                )
                .maximum(
                    Price.ScalableMatrixWithUnitPricing.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.ScalableMatrixWithUnitPricing.Maximum.Filter.builder()
                                .field(
                                    Price.ScalableMatrixWithUnitPricing.Maximum.Filter.Field
                                        .PRICE_ID
                                )
                                .operator(
                                    Price.ScalableMatrixWithUnitPricing.Maximum.Filter.Operator
                                        .INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.ScalableMatrixWithUnitPricing.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.ScalableMatrixWithUnitPricing.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.ScalableMatrixWithUnitPricing.Minimum.Filter.builder()
                                .field(
                                    Price.ScalableMatrixWithUnitPricing.Minimum.Filter.Field
                                        .PRICE_ID
                                )
                                .operator(
                                    Price.ScalableMatrixWithUnitPricing.Minimum.Filter.Operator
                                        .INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.ScalableMatrixWithUnitPricing.PriceType.USAGE_PRICE)
                .scalableMatrixWithUnitPricingConfig(
                    Price.ScalableMatrixWithUnitPricing.ScalableMatrixWithUnitPricingConfig
                        .builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    Price.ScalableMatrixWithUnitPricing.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofScalableMatrixWithUnitPricing(scalableMatrixWithUnitPricing)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).contains(scalableMatrixWithUnitPricing)
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofScalableMatrixWithUnitPricingRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofScalableMatrixWithUnitPricing(
                Price.ScalableMatrixWithUnitPricing.builder()
                    .id("id")
                    .billableMetric(
                        Price.ScalableMatrixWithUnitPricing.BillableMetric.builder()
                            .id("id")
                            .build()
                    )
                    .billingCycleConfiguration(
                        Price.ScalableMatrixWithUnitPricing.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.ScalableMatrixWithUnitPricing.BillingCycleConfiguration
                                    .DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .cadence(Price.ScalableMatrixWithUnitPricing.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.ScalableMatrixWithUnitPricing.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.ScalableMatrixWithUnitPricing.CreditAllocation
                                    .CustomExpiration
                                    .builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.ScalableMatrixWithUnitPricing.CreditAllocation
                                            .CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.ScalableMatrixWithUnitPricing.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.ScalableMatrixWithUnitPricing.InvoicingCycleConfiguration
                                    .DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .item(
                        Price.ScalableMatrixWithUnitPricing.Item.builder()
                            .id("id")
                            .name("name")
                            .build()
                    )
                    .maximum(
                        Price.ScalableMatrixWithUnitPricing.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.ScalableMatrixWithUnitPricing.Maximum.Filter.builder()
                                    .field(
                                        Price.ScalableMatrixWithUnitPricing.Maximum.Filter.Field
                                            .PRICE_ID
                                    )
                                    .operator(
                                        Price.ScalableMatrixWithUnitPricing.Maximum.Filter.Operator
                                            .INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.ScalableMatrixWithUnitPricing.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.ScalableMatrixWithUnitPricing.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.ScalableMatrixWithUnitPricing.Minimum.Filter.builder()
                                    .field(
                                        Price.ScalableMatrixWithUnitPricing.Minimum.Filter.Field
                                            .PRICE_ID
                                    )
                                    .operator(
                                        Price.ScalableMatrixWithUnitPricing.Minimum.Filter.Operator
                                            .INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.ScalableMatrixWithUnitPricing.PriceType.USAGE_PRICE)
                    .scalableMatrixWithUnitPricingConfig(
                        Price.ScalableMatrixWithUnitPricing.ScalableMatrixWithUnitPricingConfig
                            .builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        Price.ScalableMatrixWithUnitPricing.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofScalableMatrixWithTieredPricing() {
        val scalableMatrixWithTieredPricing =
            Price.ScalableMatrixWithTieredPricing.builder()
                .id("id")
                .billableMetric(
                    Price.ScalableMatrixWithTieredPricing.BillableMetric.builder().id("id").build()
                )
                .billingCycleConfiguration(
                    Price.ScalableMatrixWithTieredPricing.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.ScalableMatrixWithTieredPricing.BillingCycleConfiguration
                                .DurationUnit
                                .DAY
                        )
                        .build()
                )
                .cadence(Price.ScalableMatrixWithTieredPricing.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.ScalableMatrixWithTieredPricing.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.ScalableMatrixWithTieredPricing.CreditAllocation.CustomExpiration
                                .builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.ScalableMatrixWithTieredPricing.CreditAllocation
                                        .CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.ScalableMatrixWithTieredPricing.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.ScalableMatrixWithTieredPricing.InvoicingCycleConfiguration
                                .DurationUnit
                                .DAY
                        )
                        .build()
                )
                .item(
                    Price.ScalableMatrixWithTieredPricing.Item.builder()
                        .id("id")
                        .name("name")
                        .build()
                )
                .maximum(
                    Price.ScalableMatrixWithTieredPricing.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.ScalableMatrixWithTieredPricing.Maximum.Filter.builder()
                                .field(
                                    Price.ScalableMatrixWithTieredPricing.Maximum.Filter.Field
                                        .PRICE_ID
                                )
                                .operator(
                                    Price.ScalableMatrixWithTieredPricing.Maximum.Filter.Operator
                                        .INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.ScalableMatrixWithTieredPricing.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.ScalableMatrixWithTieredPricing.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.ScalableMatrixWithTieredPricing.Minimum.Filter.builder()
                                .field(
                                    Price.ScalableMatrixWithTieredPricing.Minimum.Filter.Field
                                        .PRICE_ID
                                )
                                .operator(
                                    Price.ScalableMatrixWithTieredPricing.Minimum.Filter.Operator
                                        .INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.ScalableMatrixWithTieredPricing.PriceType.USAGE_PRICE)
                .scalableMatrixWithTieredPricingConfig(
                    Price.ScalableMatrixWithTieredPricing.ScalableMatrixWithTieredPricingConfig
                        .builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    Price.ScalableMatrixWithTieredPricing.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofScalableMatrixWithTieredPricing(scalableMatrixWithTieredPricing)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing())
            .contains(scalableMatrixWithTieredPricing)
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofScalableMatrixWithTieredPricingRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofScalableMatrixWithTieredPricing(
                Price.ScalableMatrixWithTieredPricing.builder()
                    .id("id")
                    .billableMetric(
                        Price.ScalableMatrixWithTieredPricing.BillableMetric.builder()
                            .id("id")
                            .build()
                    )
                    .billingCycleConfiguration(
                        Price.ScalableMatrixWithTieredPricing.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.ScalableMatrixWithTieredPricing.BillingCycleConfiguration
                                    .DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .cadence(Price.ScalableMatrixWithTieredPricing.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.ScalableMatrixWithTieredPricing.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.ScalableMatrixWithTieredPricing.CreditAllocation
                                    .CustomExpiration
                                    .builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.ScalableMatrixWithTieredPricing.CreditAllocation
                                            .CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.ScalableMatrixWithTieredPricing.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.ScalableMatrixWithTieredPricing.InvoicingCycleConfiguration
                                    .DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .item(
                        Price.ScalableMatrixWithTieredPricing.Item.builder()
                            .id("id")
                            .name("name")
                            .build()
                    )
                    .maximum(
                        Price.ScalableMatrixWithTieredPricing.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.ScalableMatrixWithTieredPricing.Maximum.Filter.builder()
                                    .field(
                                        Price.ScalableMatrixWithTieredPricing.Maximum.Filter.Field
                                            .PRICE_ID
                                    )
                                    .operator(
                                        Price.ScalableMatrixWithTieredPricing.Maximum.Filter
                                            .Operator
                                            .INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.ScalableMatrixWithTieredPricing.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.ScalableMatrixWithTieredPricing.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.ScalableMatrixWithTieredPricing.Minimum.Filter.builder()
                                    .field(
                                        Price.ScalableMatrixWithTieredPricing.Minimum.Filter.Field
                                            .PRICE_ID
                                    )
                                    .operator(
                                        Price.ScalableMatrixWithTieredPricing.Minimum.Filter
                                            .Operator
                                            .INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.ScalableMatrixWithTieredPricing.PriceType.USAGE_PRICE)
                    .scalableMatrixWithTieredPricingConfig(
                        Price.ScalableMatrixWithTieredPricing.ScalableMatrixWithTieredPricingConfig
                            .builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        Price.ScalableMatrixWithTieredPricing.DimensionalPriceConfiguration
                            .builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofCumulativeGroupedBulk() {
        val cumulativeGroupedBulk =
            Price.CumulativeGroupedBulk.builder()
                .id("id")
                .billableMetric(
                    Price.CumulativeGroupedBulk.BillableMetric.builder().id("id").build()
                )
                .billingCycleConfiguration(
                    Price.CumulativeGroupedBulk.BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.CumulativeGroupedBulk.BillingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .cadence(Price.CumulativeGroupedBulk.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Price.CumulativeGroupedBulk.CreditAllocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            Price.CumulativeGroupedBulk.CreditAllocation.CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(
                                    Price.CumulativeGroupedBulk.CreditAllocation.CustomExpiration
                                        .DurationUnit
                                        .DAY
                                )
                                .build()
                        )
                        .build()
                )
                .cumulativeGroupedBulkConfig(
                    Price.CumulativeGroupedBulk.CumulativeGroupedBulkConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            PercentageDiscount.Filter.builder()
                                .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    Price.CumulativeGroupedBulk.InvoicingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(
                            Price.CumulativeGroupedBulk.InvoicingCycleConfiguration.DurationUnit.DAY
                        )
                        .build()
                )
                .item(Price.CumulativeGroupedBulk.Item.builder().id("id").name("name").build())
                .maximum(
                    Price.CumulativeGroupedBulk.Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.CumulativeGroupedBulk.Maximum.Filter.builder()
                                .field(Price.CumulativeGroupedBulk.Maximum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.CumulativeGroupedBulk.Maximum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.CumulativeGroupedBulk.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Price.CumulativeGroupedBulk.Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            Price.CumulativeGroupedBulk.Minimum.Filter.builder()
                                .field(Price.CumulativeGroupedBulk.Minimum.Filter.Field.PRICE_ID)
                                .operator(
                                    Price.CumulativeGroupedBulk.Minimum.Filter.Operator.INCLUDES
                                )
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.CumulativeGroupedBulk.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    Price.CumulativeGroupedBulk.DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofCumulativeGroupedBulk(cumulativeGroupedBulk)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).contains(cumulativeGroupedBulk)
    }

    @Test
    fun ofCumulativeGroupedBulkRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofCumulativeGroupedBulk(
                Price.CumulativeGroupedBulk.builder()
                    .id("id")
                    .billableMetric(
                        Price.CumulativeGroupedBulk.BillableMetric.builder().id("id").build()
                    )
                    .billingCycleConfiguration(
                        Price.CumulativeGroupedBulk.BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.CumulativeGroupedBulk.BillingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .cadence(Price.CumulativeGroupedBulk.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Price.CumulativeGroupedBulk.CreditAllocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                Price.CumulativeGroupedBulk.CreditAllocation.CustomExpiration
                                    .builder()
                                    .duration(0L)
                                    .durationUnit(
                                        Price.CumulativeGroupedBulk.CreditAllocation
                                            .CustomExpiration
                                            .DurationUnit
                                            .DAY
                                    )
                                    .build()
                            )
                            .build()
                    )
                    .cumulativeGroupedBulkConfig(
                        Price.CumulativeGroupedBulk.CumulativeGroupedBulkConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                PercentageDiscount.Filter.builder()
                                    .field(PercentageDiscount.Filter.Field.PRICE_ID)
                                    .operator(PercentageDiscount.Filter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        Price.CumulativeGroupedBulk.InvoicingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(
                                Price.CumulativeGroupedBulk.InvoicingCycleConfiguration.DurationUnit
                                    .DAY
                            )
                            .build()
                    )
                    .item(Price.CumulativeGroupedBulk.Item.builder().id("id").name("name").build())
                    .maximum(
                        Price.CumulativeGroupedBulk.Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.CumulativeGroupedBulk.Maximum.Filter.builder()
                                    .field(
                                        Price.CumulativeGroupedBulk.Maximum.Filter.Field.PRICE_ID
                                    )
                                    .operator(
                                        Price.CumulativeGroupedBulk.Maximum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.CumulativeGroupedBulk.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Price.CumulativeGroupedBulk.Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                Price.CumulativeGroupedBulk.Minimum.Filter.builder()
                                    .field(
                                        Price.CumulativeGroupedBulk.Minimum.Filter.Field.PRICE_ID
                                    )
                                    .operator(
                                        Price.CumulativeGroupedBulk.Minimum.Filter.Operator.INCLUDES
                                    )
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.CumulativeGroupedBulk.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        Price.CumulativeGroupedBulk.DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    enum class IncompatibleJsonShapeTestCase(val value: JsonValue) {
        BOOLEAN(JsonValue.from(false)),
        STRING(JsonValue.from("invalid")),
        INTEGER(JsonValue.from(-1)),
        FLOAT(JsonValue.from(3.14)),
        ARRAY(JsonValue.from(listOf("invalid", "array"))),
    }

    @ParameterizedTest
    @EnumSource
    fun incompatibleJsonShapeDeserializesToUnknown(testCase: IncompatibleJsonShapeTestCase) {
        val price = jsonMapper().convertValue(testCase.value, jacksonTypeRef<Price>())

        val e = assertThrows<OrbInvalidDataException> { price.validate() }
        assertThat(e).hasMessageStartingWith("Unknown ")
    }
}
