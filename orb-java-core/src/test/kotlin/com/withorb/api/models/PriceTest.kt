// File generated from our OpenAPI spec by Stainless.

package com.withorb.api.models

import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.withorb.api.core.JsonValue
import com.withorb.api.core.jsonMapper
import com.withorb.api.errors.OrbInvalidDataException
import java.time.OffsetDateTime
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import org.junit.jupiter.params.ParameterizedTest
import org.junit.jupiter.params.provider.EnumSource

internal class PriceTest {

    @Test
    fun ofUnit() {
        val unit =
            Price.Unit.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.Unit.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.Unit.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.Unit.PriceType.USAGE_PRICE)
                .unitConfig(UnitConfig.builder().unitAmount("unit_amount").build())
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofUnit(unit)

        assertThat(price.unit()).contains(unit)
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofUnitRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofUnit(
                Price.Unit.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.Unit.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.Unit.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.Unit.PriceType.USAGE_PRICE)
                    .unitConfig(UnitConfig.builder().unitAmount("unit_amount").build())
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofPackage() {
        val package_ =
            Price.Package.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.Package.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.Package.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .packageConfig(
                    PackageConfig.builder().packageAmount("package_amount").packageSize(0L).build()
                )
                .planPhaseOrder(0L)
                .priceType(Price.Package.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofPackage(package_)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).contains(package_)
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofPackageRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofPackage(
                Price.Package.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.Package.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.Package.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .packageConfig(
                        PackageConfig.builder()
                            .packageAmount("package_amount")
                            .packageSize(0L)
                            .build()
                    )
                    .planPhaseOrder(0L)
                    .priceType(Price.Package.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofMatrix() {
        val matrix =
            Price.Matrix.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.Matrix.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .matrixConfig(
                    MatrixConfig.builder()
                        .defaultUnitAmount("default_unit_amount")
                        .addDimension("string")
                        .addMatrixValue(
                            MatrixValue.builder()
                                .addDimensionValue("string")
                                .unitAmount("unit_amount")
                                .build()
                        )
                        .build()
                )
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.Matrix.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.Matrix.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofMatrix(matrix)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).contains(matrix)
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofMatrixRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofMatrix(
                Price.Matrix.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.Matrix.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .matrixConfig(
                        MatrixConfig.builder()
                            .defaultUnitAmount("default_unit_amount")
                            .addDimension("string")
                            .addMatrixValue(
                                MatrixValue.builder()
                                    .addDimensionValue("string")
                                    .unitAmount("unit_amount")
                                    .build()
                            )
                            .build()
                    )
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.Matrix.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.Matrix.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofTiered() {
        val tiered =
            Price.Tiered.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.Tiered.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.Tiered.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.Tiered.PriceType.USAGE_PRICE)
                .tieredConfig(
                    TieredConfig.builder()
                        .addTier(
                            Tier.builder()
                                .firstUnit(0.0)
                                .unitAmount("unit_amount")
                                .lastUnit(0.0)
                                .build()
                        )
                        .build()
                )
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofTiered(tiered)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).contains(tiered)
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofTieredRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofTiered(
                Price.Tiered.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.Tiered.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.Tiered.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.Tiered.PriceType.USAGE_PRICE)
                    .tieredConfig(
                        TieredConfig.builder()
                            .addTier(
                                Tier.builder()
                                    .firstUnit(0.0)
                                    .unitAmount("unit_amount")
                                    .lastUnit(0.0)
                                    .build()
                            )
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofTieredBps() {
        val tieredBps =
            Price.TieredBps.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.TieredBps.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.TieredBps.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.TieredBps.PriceType.USAGE_PRICE)
                .tieredBpsConfig(
                    TieredBpsConfig.builder()
                        .addTier(
                            BpsTier.builder()
                                .bps(0.0)
                                .minimumAmount("minimum_amount")
                                .maximumAmount("maximum_amount")
                                .perUnitMaximum("per_unit_maximum")
                                .build()
                        )
                        .build()
                )
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofTieredBps(tieredBps)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).contains(tieredBps)
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofTieredBpsRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofTieredBps(
                Price.TieredBps.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.TieredBps.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.TieredBps.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.TieredBps.PriceType.USAGE_PRICE)
                    .tieredBpsConfig(
                        TieredBpsConfig.builder()
                            .addTier(
                                BpsTier.builder()
                                    .bps(0.0)
                                    .minimumAmount("minimum_amount")
                                    .maximumAmount("maximum_amount")
                                    .perUnitMaximum("per_unit_maximum")
                                    .build()
                            )
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofBps() {
        val bps =
            Price.Bps.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .bpsConfig(BpsConfig.builder().bps(0.0).perUnitMaximum("per_unit_maximum").build())
                .cadence(Price.Bps.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.Bps.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.Bps.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofBps(bps)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).contains(bps)
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofBpsRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofBps(
                Price.Bps.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .bpsConfig(
                        BpsConfig.builder().bps(0.0).perUnitMaximum("per_unit_maximum").build()
                    )
                    .cadence(Price.Bps.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.Bps.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.Bps.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofBulkBps() {
        val bulkBps =
            Price.BulkBps.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .bulkBpsConfig(
                    BulkBpsConfig.builder()
                        .addTier(
                            BulkBpsTier.builder()
                                .bps(0.0)
                                .maximumAmount("maximum_amount")
                                .perUnitMaximum("per_unit_maximum")
                                .build()
                        )
                        .build()
                )
                .cadence(Price.BulkBps.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.BulkBps.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.BulkBps.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofBulkBps(bulkBps)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).contains(bulkBps)
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofBulkBpsRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofBulkBps(
                Price.BulkBps.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .bulkBpsConfig(
                        BulkBpsConfig.builder()
                            .addTier(
                                BulkBpsTier.builder()
                                    .bps(0.0)
                                    .maximumAmount("maximum_amount")
                                    .perUnitMaximum("per_unit_maximum")
                                    .build()
                            )
                            .build()
                    )
                    .cadence(Price.BulkBps.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.BulkBps.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.BulkBps.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofBulk() {
        val bulk =
            Price.Bulk.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .bulkConfig(
                    BulkConfig.builder()
                        .addTier(
                            BulkTier.builder().unitAmount("unit_amount").maximumUnits(0.0).build()
                        )
                        .build()
                )
                .cadence(Price.Bulk.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.Bulk.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.Bulk.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofBulk(bulk)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).contains(bulk)
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofBulkRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofBulk(
                Price.Bulk.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .bulkConfig(
                        BulkConfig.builder()
                            .addTier(
                                BulkTier.builder()
                                    .unitAmount("unit_amount")
                                    .maximumUnits(0.0)
                                    .build()
                            )
                            .build()
                    )
                    .cadence(Price.Bulk.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.Bulk.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.Bulk.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofThresholdTotalAmount() {
        val thresholdTotalAmount =
            Price.ThresholdTotalAmount.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.ThresholdTotalAmount.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.ThresholdTotalAmount.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.ThresholdTotalAmount.PriceType.USAGE_PRICE)
                .thresholdTotalAmountConfig(
                    Price.ThresholdTotalAmount.ThresholdTotalAmountConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofThresholdTotalAmount(thresholdTotalAmount)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).contains(thresholdTotalAmount)
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofThresholdTotalAmountRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofThresholdTotalAmount(
                Price.ThresholdTotalAmount.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.ThresholdTotalAmount.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.ThresholdTotalAmount.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.ThresholdTotalAmount.PriceType.USAGE_PRICE)
                    .thresholdTotalAmountConfig(
                        Price.ThresholdTotalAmount.ThresholdTotalAmountConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofTieredPackage() {
        val tieredPackage =
            Price.TieredPackage.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.TieredPackage.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.TieredPackage.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.TieredPackage.PriceType.USAGE_PRICE)
                .tieredPackageConfig(
                    Price.TieredPackage.TieredPackageConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofTieredPackage(tieredPackage)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).contains(tieredPackage)
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofTieredPackageRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofTieredPackage(
                Price.TieredPackage.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.TieredPackage.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.TieredPackage.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.TieredPackage.PriceType.USAGE_PRICE)
                    .tieredPackageConfig(
                        Price.TieredPackage.TieredPackageConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofGroupedTiered() {
        val groupedTiered =
            Price.GroupedTiered.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.GroupedTiered.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .groupedTieredConfig(
                    Price.GroupedTiered.GroupedTieredConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.GroupedTiered.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.GroupedTiered.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofGroupedTiered(groupedTiered)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).contains(groupedTiered)
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofGroupedTieredRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofGroupedTiered(
                Price.GroupedTiered.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.GroupedTiered.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .groupedTieredConfig(
                        Price.GroupedTiered.GroupedTieredConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.GroupedTiered.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.GroupedTiered.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofTieredWithMinimum() {
        val tieredWithMinimum =
            Price.TieredWithMinimum.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.TieredWithMinimum.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.TieredWithMinimum.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.TieredWithMinimum.PriceType.USAGE_PRICE)
                .tieredWithMinimumConfig(
                    Price.TieredWithMinimum.TieredWithMinimumConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofTieredWithMinimum(tieredWithMinimum)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).contains(tieredWithMinimum)
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofTieredWithMinimumRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofTieredWithMinimum(
                Price.TieredWithMinimum.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.TieredWithMinimum.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.TieredWithMinimum.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.TieredWithMinimum.PriceType.USAGE_PRICE)
                    .tieredWithMinimumConfig(
                        Price.TieredWithMinimum.TieredWithMinimumConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofTieredPackageWithMinimum() {
        val tieredPackageWithMinimum =
            Price.TieredPackageWithMinimum.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.TieredPackageWithMinimum.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.TieredPackageWithMinimum.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.TieredPackageWithMinimum.PriceType.USAGE_PRICE)
                .tieredPackageWithMinimumConfig(
                    Price.TieredPackageWithMinimum.TieredPackageWithMinimumConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofTieredPackageWithMinimum(tieredPackageWithMinimum)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).contains(tieredPackageWithMinimum)
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofTieredPackageWithMinimumRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofTieredPackageWithMinimum(
                Price.TieredPackageWithMinimum.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.TieredPackageWithMinimum.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.TieredPackageWithMinimum.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.TieredPackageWithMinimum.PriceType.USAGE_PRICE)
                    .tieredPackageWithMinimumConfig(
                        Price.TieredPackageWithMinimum.TieredPackageWithMinimumConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofPackageWithAllocation() {
        val packageWithAllocation =
            Price.PackageWithAllocation.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.PackageWithAllocation.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.PackageWithAllocation.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .packageWithAllocationConfig(
                    Price.PackageWithAllocation.PackageWithAllocationConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .planPhaseOrder(0L)
                .priceType(Price.PackageWithAllocation.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofPackageWithAllocation(packageWithAllocation)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).contains(packageWithAllocation)
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofPackageWithAllocationRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofPackageWithAllocation(
                Price.PackageWithAllocation.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.PackageWithAllocation.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.PackageWithAllocation.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .packageWithAllocationConfig(
                        Price.PackageWithAllocation.PackageWithAllocationConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .planPhaseOrder(0L)
                    .priceType(Price.PackageWithAllocation.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofUnitWithPercent() {
        val unitWithPercent =
            Price.UnitWithPercent.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.UnitWithPercent.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.UnitWithPercent.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.UnitWithPercent.PriceType.USAGE_PRICE)
                .unitWithPercentConfig(
                    Price.UnitWithPercent.UnitWithPercentConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofUnitWithPercent(unitWithPercent)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).contains(unitWithPercent)
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofUnitWithPercentRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofUnitWithPercent(
                Price.UnitWithPercent.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.UnitWithPercent.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.UnitWithPercent.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.UnitWithPercent.PriceType.USAGE_PRICE)
                    .unitWithPercentConfig(
                        Price.UnitWithPercent.UnitWithPercentConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofMatrixWithAllocation() {
        val matrixWithAllocation =
            Price.MatrixWithAllocation.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.MatrixWithAllocation.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .matrixWithAllocationConfig(
                    MatrixWithAllocationConfig.builder()
                        .allocation(0.0)
                        .defaultUnitAmount("default_unit_amount")
                        .addDimension("string")
                        .addMatrixValue(
                            MatrixValue.builder()
                                .addDimensionValue("string")
                                .unitAmount("unit_amount")
                                .build()
                        )
                        .build()
                )
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.MatrixWithAllocation.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.MatrixWithAllocation.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofMatrixWithAllocation(matrixWithAllocation)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).contains(matrixWithAllocation)
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofMatrixWithAllocationRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofMatrixWithAllocation(
                Price.MatrixWithAllocation.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.MatrixWithAllocation.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .matrixWithAllocationConfig(
                        MatrixWithAllocationConfig.builder()
                            .allocation(0.0)
                            .defaultUnitAmount("default_unit_amount")
                            .addDimension("string")
                            .addMatrixValue(
                                MatrixValue.builder()
                                    .addDimensionValue("string")
                                    .unitAmount("unit_amount")
                                    .build()
                            )
                            .build()
                    )
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.MatrixWithAllocation.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.MatrixWithAllocation.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofTieredWithProration() {
        val tieredWithProration =
            Price.TieredWithProration.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.TieredWithProration.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.TieredWithProration.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.TieredWithProration.PriceType.USAGE_PRICE)
                .tieredWithProrationConfig(
                    Price.TieredWithProration.TieredWithProrationConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofTieredWithProration(tieredWithProration)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).contains(tieredWithProration)
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofTieredWithProrationRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofTieredWithProration(
                Price.TieredWithProration.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.TieredWithProration.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.TieredWithProration.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.TieredWithProration.PriceType.USAGE_PRICE)
                    .tieredWithProrationConfig(
                        Price.TieredWithProration.TieredWithProrationConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofUnitWithProration() {
        val unitWithProration =
            Price.UnitWithProration.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.UnitWithProration.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.UnitWithProration.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.UnitWithProration.PriceType.USAGE_PRICE)
                .unitWithProrationConfig(
                    Price.UnitWithProration.UnitWithProrationConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofUnitWithProration(unitWithProration)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).contains(unitWithProration)
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofUnitWithProrationRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofUnitWithProration(
                Price.UnitWithProration.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.UnitWithProration.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.UnitWithProration.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.UnitWithProration.PriceType.USAGE_PRICE)
                    .unitWithProrationConfig(
                        Price.UnitWithProration.UnitWithProrationConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofGroupedAllocation() {
        val groupedAllocation =
            Price.GroupedAllocation.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.GroupedAllocation.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .groupedAllocationConfig(
                    Price.GroupedAllocation.GroupedAllocationConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.GroupedAllocation.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.GroupedAllocation.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofGroupedAllocation(groupedAllocation)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).contains(groupedAllocation)
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofGroupedAllocationRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofGroupedAllocation(
                Price.GroupedAllocation.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.GroupedAllocation.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .groupedAllocationConfig(
                        Price.GroupedAllocation.GroupedAllocationConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.GroupedAllocation.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.GroupedAllocation.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofGroupedWithProratedMinimum() {
        val groupedWithProratedMinimum =
            Price.GroupedWithProratedMinimum.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.GroupedWithProratedMinimum.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .groupedWithProratedMinimumConfig(
                    Price.GroupedWithProratedMinimum.GroupedWithProratedMinimumConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.GroupedWithProratedMinimum.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.GroupedWithProratedMinimum.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofGroupedWithProratedMinimum(groupedWithProratedMinimum)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).contains(groupedWithProratedMinimum)
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofGroupedWithProratedMinimumRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofGroupedWithProratedMinimum(
                Price.GroupedWithProratedMinimum.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.GroupedWithProratedMinimum.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .groupedWithProratedMinimumConfig(
                        Price.GroupedWithProratedMinimum.GroupedWithProratedMinimumConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.GroupedWithProratedMinimum.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.GroupedWithProratedMinimum.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofGroupedWithMeteredMinimum() {
        val groupedWithMeteredMinimum =
            Price.GroupedWithMeteredMinimum.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.GroupedWithMeteredMinimum.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .groupedWithMeteredMinimumConfig(
                    Price.GroupedWithMeteredMinimum.GroupedWithMeteredMinimumConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.GroupedWithMeteredMinimum.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.GroupedWithMeteredMinimum.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofGroupedWithMeteredMinimum(groupedWithMeteredMinimum)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).contains(groupedWithMeteredMinimum)
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofGroupedWithMeteredMinimumRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofGroupedWithMeteredMinimum(
                Price.GroupedWithMeteredMinimum.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.GroupedWithMeteredMinimum.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .groupedWithMeteredMinimumConfig(
                        Price.GroupedWithMeteredMinimum.GroupedWithMeteredMinimumConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.GroupedWithMeteredMinimum.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.GroupedWithMeteredMinimum.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofMatrixWithDisplayName() {
        val matrixWithDisplayName =
            Price.MatrixWithDisplayName.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.MatrixWithDisplayName.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .matrixWithDisplayNameConfig(
                    Price.MatrixWithDisplayName.MatrixWithDisplayNameConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.MatrixWithDisplayName.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.MatrixWithDisplayName.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofMatrixWithDisplayName(matrixWithDisplayName)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).contains(matrixWithDisplayName)
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofMatrixWithDisplayNameRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofMatrixWithDisplayName(
                Price.MatrixWithDisplayName.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.MatrixWithDisplayName.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .matrixWithDisplayNameConfig(
                        Price.MatrixWithDisplayName.MatrixWithDisplayNameConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.MatrixWithDisplayName.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.MatrixWithDisplayName.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofBulkWithProration() {
        val bulkWithProration =
            Price.BulkWithProration.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .bulkWithProrationConfig(
                    Price.BulkWithProration.BulkWithProrationConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .cadence(Price.BulkWithProration.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.BulkWithProration.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.BulkWithProration.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofBulkWithProration(bulkWithProration)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).contains(bulkWithProration)
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofBulkWithProrationRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofBulkWithProration(
                Price.BulkWithProration.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .bulkWithProrationConfig(
                        Price.BulkWithProration.BulkWithProrationConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .cadence(Price.BulkWithProration.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.BulkWithProration.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.BulkWithProration.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofGroupedTieredPackage() {
        val groupedTieredPackage =
            Price.GroupedTieredPackage.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.GroupedTieredPackage.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .groupedTieredPackageConfig(
                    Price.GroupedTieredPackage.GroupedTieredPackageConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.GroupedTieredPackage.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.GroupedTieredPackage.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofGroupedTieredPackage(groupedTieredPackage)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).contains(groupedTieredPackage)
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofGroupedTieredPackageRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofGroupedTieredPackage(
                Price.GroupedTieredPackage.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.GroupedTieredPackage.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .groupedTieredPackageConfig(
                        Price.GroupedTieredPackage.GroupedTieredPackageConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.GroupedTieredPackage.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.GroupedTieredPackage.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofMaxGroupTieredPackage() {
        val maxGroupTieredPackage =
            Price.MaxGroupTieredPackage.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.MaxGroupTieredPackage.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maxGroupTieredPackageConfig(
                    Price.MaxGroupTieredPackage.MaxGroupTieredPackageConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.MaxGroupTieredPackage.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.MaxGroupTieredPackage.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofMaxGroupTieredPackage(maxGroupTieredPackage)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).contains(maxGroupTieredPackage)
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofMaxGroupTieredPackageRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofMaxGroupTieredPackage(
                Price.MaxGroupTieredPackage.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.MaxGroupTieredPackage.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maxGroupTieredPackageConfig(
                        Price.MaxGroupTieredPackage.MaxGroupTieredPackageConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.MaxGroupTieredPackage.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.MaxGroupTieredPackage.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofScalableMatrixWithUnitPricing() {
        val scalableMatrixWithUnitPricing =
            Price.ScalableMatrixWithUnitPricing.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.ScalableMatrixWithUnitPricing.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.ScalableMatrixWithUnitPricing.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.ScalableMatrixWithUnitPricing.PriceType.USAGE_PRICE)
                .scalableMatrixWithUnitPricingConfig(
                    Price.ScalableMatrixWithUnitPricing.ScalableMatrixWithUnitPricingConfig
                        .builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofScalableMatrixWithUnitPricing(scalableMatrixWithUnitPricing)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).contains(scalableMatrixWithUnitPricing)
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofScalableMatrixWithUnitPricingRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofScalableMatrixWithUnitPricing(
                Price.ScalableMatrixWithUnitPricing.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.ScalableMatrixWithUnitPricing.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.ScalableMatrixWithUnitPricing.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.ScalableMatrixWithUnitPricing.PriceType.USAGE_PRICE)
                    .scalableMatrixWithUnitPricingConfig(
                        Price.ScalableMatrixWithUnitPricing.ScalableMatrixWithUnitPricingConfig
                            .builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofScalableMatrixWithTieredPricing() {
        val scalableMatrixWithTieredPricing =
            Price.ScalableMatrixWithTieredPricing.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.ScalableMatrixWithTieredPricing.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.ScalableMatrixWithTieredPricing.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.ScalableMatrixWithTieredPricing.PriceType.USAGE_PRICE)
                .scalableMatrixWithTieredPricingConfig(
                    Price.ScalableMatrixWithTieredPricing.ScalableMatrixWithTieredPricingConfig
                        .builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofScalableMatrixWithTieredPricing(scalableMatrixWithTieredPricing)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing())
            .contains(scalableMatrixWithTieredPricing)
        assertThat(price.cumulativeGroupedBulk()).isEmpty
    }

    @Test
    fun ofScalableMatrixWithTieredPricingRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofScalableMatrixWithTieredPricing(
                Price.ScalableMatrixWithTieredPricing.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.ScalableMatrixWithTieredPricing.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.ScalableMatrixWithTieredPricing.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.ScalableMatrixWithTieredPricing.PriceType.USAGE_PRICE)
                    .scalableMatrixWithTieredPricingConfig(
                        Price.ScalableMatrixWithTieredPricing.ScalableMatrixWithTieredPricingConfig
                            .builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    @Test
    fun ofCumulativeGroupedBulk() {
        val cumulativeGroupedBulk =
            Price.CumulativeGroupedBulk.builder()
                .id("id")
                .billableMetric(BillableMetricTiny.builder().id("id").build())
                .billingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .cadence(Price.CumulativeGroupedBulk.Cadence.ONE_TIME)
                .conversionRate(0.0)
                .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .creditAllocation(
                    Allocation.builder()
                        .allowsRollover(true)
                        .currency("currency")
                        .customExpiration(
                            CustomExpiration.builder()
                                .duration(0L)
                                .durationUnit(CustomExpiration.DurationUnit.DAY)
                                .build()
                        )
                        .build()
                )
                .cumulativeGroupedBulkConfig(
                    Price.CumulativeGroupedBulk.CumulativeGroupedBulkConfig.builder()
                        .putAdditionalProperty("foo", JsonValue.from("bar"))
                        .build()
                )
                .currency("currency")
                .discount(
                    PercentageDiscount.builder()
                        .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                        .percentageDiscount(0.15)
                        .addAppliesToPriceId("h74gfhdjvn7ujokd")
                        .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .reason("reason")
                        .build()
                )
                .externalPriceId("external_price_id")
                .fixedPriceQuantity(0.0)
                .invoicingCycleConfiguration(
                    BillingCycleConfiguration.builder()
                        .duration(0L)
                        .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                        .build()
                )
                .item(ItemSlim.builder().id("id").name("name").build())
                .maximum(
                    Maximum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .maximumAmount("maximum_amount")
                        .build()
                )
                .maximumAmount("maximum_amount")
                .metadata(
                    Price.CumulativeGroupedBulk.Metadata.builder()
                        .putAdditionalProperty("foo", JsonValue.from("string"))
                        .build()
                )
                .minimum(
                    Minimum.builder()
                        .addAppliesToPriceId("string")
                        .addFilter(
                            TransformPriceFilter.builder()
                                .field(TransformPriceFilter.Field.PRICE_ID)
                                .operator(TransformPriceFilter.Operator.INCLUDES)
                                .addValue("string")
                                .build()
                        )
                        .minimumAmount("minimum_amount")
                        .build()
                )
                .minimumAmount("minimum_amount")
                .name("name")
                .planPhaseOrder(0L)
                .priceType(Price.CumulativeGroupedBulk.PriceType.USAGE_PRICE)
                .dimensionalPriceConfiguration(
                    DimensionalPriceConfiguration.builder()
                        .addDimensionValue("string")
                        .dimensionalPriceGroupId("dimensional_price_group_id")
                        .build()
                )
                .build()

        val price = Price.ofCumulativeGroupedBulk(cumulativeGroupedBulk)

        assertThat(price.unit()).isEmpty
        assertThat(price.package_()).isEmpty
        assertThat(price.matrix()).isEmpty
        assertThat(price.tiered()).isEmpty
        assertThat(price.tieredBps()).isEmpty
        assertThat(price.bps()).isEmpty
        assertThat(price.bulkBps()).isEmpty
        assertThat(price.bulk()).isEmpty
        assertThat(price.thresholdTotalAmount()).isEmpty
        assertThat(price.tieredPackage()).isEmpty
        assertThat(price.groupedTiered()).isEmpty
        assertThat(price.tieredWithMinimum()).isEmpty
        assertThat(price.tieredPackageWithMinimum()).isEmpty
        assertThat(price.packageWithAllocation()).isEmpty
        assertThat(price.unitWithPercent()).isEmpty
        assertThat(price.matrixWithAllocation()).isEmpty
        assertThat(price.tieredWithProration()).isEmpty
        assertThat(price.unitWithProration()).isEmpty
        assertThat(price.groupedAllocation()).isEmpty
        assertThat(price.groupedWithProratedMinimum()).isEmpty
        assertThat(price.groupedWithMeteredMinimum()).isEmpty
        assertThat(price.matrixWithDisplayName()).isEmpty
        assertThat(price.bulkWithProration()).isEmpty
        assertThat(price.groupedTieredPackage()).isEmpty
        assertThat(price.maxGroupTieredPackage()).isEmpty
        assertThat(price.scalableMatrixWithUnitPricing()).isEmpty
        assertThat(price.scalableMatrixWithTieredPricing()).isEmpty
        assertThat(price.cumulativeGroupedBulk()).contains(cumulativeGroupedBulk)
    }

    @Test
    fun ofCumulativeGroupedBulkRoundtrip() {
        val jsonMapper = jsonMapper()
        val price =
            Price.ofCumulativeGroupedBulk(
                Price.CumulativeGroupedBulk.builder()
                    .id("id")
                    .billableMetric(BillableMetricTiny.builder().id("id").build())
                    .billingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .cadence(Price.CumulativeGroupedBulk.Cadence.ONE_TIME)
                    .conversionRate(0.0)
                    .createdAt(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .creditAllocation(
                        Allocation.builder()
                            .allowsRollover(true)
                            .currency("currency")
                            .customExpiration(
                                CustomExpiration.builder()
                                    .duration(0L)
                                    .durationUnit(CustomExpiration.DurationUnit.DAY)
                                    .build()
                            )
                            .build()
                    )
                    .cumulativeGroupedBulkConfig(
                        Price.CumulativeGroupedBulk.CumulativeGroupedBulkConfig.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .currency("currency")
                    .discount(
                        PercentageDiscount.builder()
                            .discountType(PercentageDiscount.DiscountType.PERCENTAGE)
                            .percentageDiscount(0.15)
                            .addAppliesToPriceId("h74gfhdjvn7ujokd")
                            .addAppliesToPriceId("7hfgtgjnbvc3ujkl")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .reason("reason")
                            .build()
                    )
                    .externalPriceId("external_price_id")
                    .fixedPriceQuantity(0.0)
                    .invoicingCycleConfiguration(
                        BillingCycleConfiguration.builder()
                            .duration(0L)
                            .durationUnit(BillingCycleConfiguration.DurationUnit.DAY)
                            .build()
                    )
                    .item(ItemSlim.builder().id("id").name("name").build())
                    .maximum(
                        Maximum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .maximumAmount("maximum_amount")
                            .build()
                    )
                    .maximumAmount("maximum_amount")
                    .metadata(
                        Price.CumulativeGroupedBulk.Metadata.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .minimum(
                        Minimum.builder()
                            .addAppliesToPriceId("string")
                            .addFilter(
                                TransformPriceFilter.builder()
                                    .field(TransformPriceFilter.Field.PRICE_ID)
                                    .operator(TransformPriceFilter.Operator.INCLUDES)
                                    .addValue("string")
                                    .build()
                            )
                            .minimumAmount("minimum_amount")
                            .build()
                    )
                    .minimumAmount("minimum_amount")
                    .name("name")
                    .planPhaseOrder(0L)
                    .priceType(Price.CumulativeGroupedBulk.PriceType.USAGE_PRICE)
                    .dimensionalPriceConfiguration(
                        DimensionalPriceConfiguration.builder()
                            .addDimensionValue("string")
                            .dimensionalPriceGroupId("dimensional_price_group_id")
                            .build()
                    )
                    .build()
            )

        val roundtrippedPrice =
            jsonMapper.readValue(jsonMapper.writeValueAsString(price), jacksonTypeRef<Price>())

        assertThat(roundtrippedPrice).isEqualTo(price)
    }

    enum class IncompatibleJsonShapeTestCase(val value: JsonValue) {
        BOOLEAN(JsonValue.from(false)),
        STRING(JsonValue.from("invalid")),
        INTEGER(JsonValue.from(-1)),
        FLOAT(JsonValue.from(3.14)),
        ARRAY(JsonValue.from(listOf("invalid", "array"))),
    }

    @ParameterizedTest
    @EnumSource
    fun incompatibleJsonShapeDeserializesToUnknown(testCase: IncompatibleJsonShapeTestCase) {
        val price = jsonMapper().convertValue(testCase.value, jacksonTypeRef<Price>())

        val e = assertThrows<OrbInvalidDataException> { price.validate() }
        assertThat(e).hasMessageStartingWith("Unknown ")
    }
}
